========================================
OPS MATRIX FRAMEWORK - ASSET INTEGRATION CONTEXT
Generated: Mon Dec 29 21:49:54 CET 2025
========================================


###############################################
### MODULE: ops_matrix_core (Architecture)
###############################################

>>> ops_matrix_core/__manifest__.py <<<
# -*- coding: utf-8 -*-
{
    'name': 'OPS Matrix Core',
    'version': '19.0.1.3',
    'category': 'Operations',
    'summary': 'Core module for OPS Matrix Framework',
    'description': """
        OPS Matrix Framework - Core Module
        ==================================
        This module provides the foundation for the OPS Matrix Framework.
        It includes Company, Branch, Business Unit models and the security framework.
    """,
    'author': 'Gemini Agent',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': [
        'base',
        'mail',
        'analytic',
        'account',
        'sale',
        'purchase',
        'stock',
        'hr',  # Required for ops.persona employee_id field
    ],
    'data': [
        # Load in exact order
        # Data & Config (Groups must load first)
        'data/ir_module_category.xml',
        'data/res_groups.xml',
        
        # Security (depends on groups)
        'security/ir.model.access.csv',
        'security/ir_rule.xml',
        
        # Sequences and core data
        'data/ir_sequence_data.xml',
        
        # Template Data Files (Active templates for reference)
        'data/templates/ops_persona_templates.xml',
        'data/templates/ops_governance_rule_templates.xml',
        'data/templates/ops_sla_templates.xml',
        
        # Views - Main Structure (load Business Unit before Branch, as Branch references BU action)
        'views/ops_business_unit_views.xml',
        'views/ops_branch_views.xml',
        'views/res_company_views.xml',
        'views/ops_inter_branch_transfer_views.xml',
        
        # Views - Persona Engine
        'views/ops_persona_views.xml',
        'views/ops_persona_delegation_views.xml',
        'views/res_users_views.xml',
        
        # Views - Governance & Approvals
        'views/ops_approval_request_views.xml',
        'views/ops_governance_rule_views.xml',
        'views/ops_approval_dashboard_views.xml',
        'views/ops_governance_violation_report_views.xml',
        'views/ops_archive_policy_views.xml',
        'views/ops_analytic_views.xml',
        
        # Views - SLA
        'views/ops_sla_template_views.xml',
        'views/ops_sla_instance_views.xml',
        
        # Views - Dashboards (CE compatible)
        'views/ops_executive_dashboard_views.xml',
        'views/ops_branch_dashboard_views.xml',
        'views/ops_bu_dashboard_views.xml',
        'views/ops_sales_dashboard_views.xml',
        'views/ops_dashboard_menu.xml',
        'views/ops_dashboard_config_views.xml',
        
        # Views - Standard Model Extensions
        'views/product_views.xml',
        'views/partner_views.xml',
        'views/sale_order_views.xml',
        'views/sale_order_import_wizard_views.xml',
        'views/account_move_views.xml',
        'views/stock_picking_views.xml',
        'views/stock_warehouse_orderpoint_views.xml',
        'views/product_silo_views.xml',
        
        # Views - API Integration & Security
        'views/ops_api_key_views.xml',
        'views/ops_audit_log_views.xml',
        
        # Additional data
        'data/ir_cron_data.xml',
        'data/ir_cron_archiver.xml',
        'data/sale_order_actions.xml',
        
        # Archive policy templates (inactive by default)
        'data/ops_archive_templates.xml',
        
        # Reports
        'reports/ops_products_availability_report.xml',
    ],
    'demo': [
        'demo/ops_demo_data.xml',
    ],
    'assets': {
        'web.assets_backend': [
            'ops_matrix_core/static/src/js/storage_guard.js',  # Load first for safety
            'ops_matrix_core/static/src/js/report_action_override.js',
        ],
    },
    'post_init_hook': 'post_init_hook',
    'installable': True,
    'application': True,
    'auto_install': False,
}
>>> ops_matrix_core/models/__init__.py <<<
# -*- coding: utf-8 -*-

# ==================================================================
# CRITICAL: Import Order Matters - Dependencies!
# ==================================================================
# 1. Core Structure (Company → Branch → BU → Config → Mixin)
from . import res_company          # First: base Odoo model
from . import ops_branch            # Second: Branch model (depends on company)
from . import ops_business_unit     # Third: BU model (depends on branch)
from . import ops_matrix_config     # Fourth: Configuration model
from . import ops_mixin             # Fifth: Mixin (depends on branch/BU)
from . import ops_matrix_mixin      # Sixth: Matrix dimension propagation mixin
from . import ops_analytic_setup    # Analytic accounting setup wizard
from . import ops_performance_indexes  # Performance optimization indexes

# 2. Security Engine (depends on user model)
from . import ops_security_rules    # Security rule engine
from . import ops_security_audit    # Security audit logging

# 2a. API Authentication & Audit Logging
from . import ops_api_key           # API key management
from . import ops_audit_log         # API audit logging

# 3. Persona Engine (depends on branch/BU)
from . import ops_persona
from . import ops_persona_delegation
from . import res_users

# 3a. Inter-Branch Transfers
from . import ops_inter_branch_transfer

# 4. Governance & Approvals
from . import ops_governance_mixin
from . import ops_governance_limits      # NEW: Related limit models
from . import ops_governance_rule
from . import ops_approval_request
from . import ops_approval_dashboard
from . import ops_archive_policy

# 5. SLA Engine
from . import ops_sla_mixin
from . import ops_sla_template
from . import ops_sla_instance

# 6. Dashboard Configuration
from . import ops_dashboard_config
from . import ops_dashboard_widget

# 7. Standard Model Extensions
from . import ir_actions_report  # Governance enforcement on PDF generation
from . import product
from . import partner
from . import pricelist
from . import sale_order
from . import purchase_order
from . import account_move
from . import stock_warehouse
from . import stock_warehouse_orderpoint
from . import stock_picking
from . import stock_move
from . import stock_quant
from . import mail_message

# 7. Product Requests
from . import ops_product_request

# 8. Wizards (Located in models folder currently)
from . import sale_order_import_wizard

>>> ops_matrix_core/models/ops_branch.py <<<
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
from typing import List, Dict, Any

class OpsBranch(models.Model):
    _name = 'ops.branch'
    _description = 'Operational Branch (not a legal entity)'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'sequence, id'
    _check_company_auto = True

    # ---------------------------------------------------------
    # Required Fields
    # ---------------------------------------------------------
    name = fields.Char(
        required=True,
        tracking=True,
        string='Branch Name',
        help='Descriptive name for this branch/location. '
             'Example: "Downtown Store", "North Region HQ", "Warehouse 3". '
             'This name appears throughout the system in reports and transactions.'
    )
    code = fields.Char(
        string='Code',
        required=True,
        readonly=True,
        copy=False,
        default=lambda self: _('New'),
        tracking=True,
        help='Unique identifier for this branch within the company. '
             'Auto-generated on save (format: BR-XXXX). '
             'Used in reports, analytics, and as reference in transactions. '
             'Cannot be changed after creation. '
             'Example: BR-001, BR-NORTH, BR-WH3'
    )
    company_id = fields.Many2one(
        'res.company',
        required=True,
        ondelete='restrict',
        default=lambda self: self.env.company,
        index=True,
        tracking=True,
        string='Legal Entity',
        help='The legal entity (company) this branch belongs to. '
             'All branches must be associated with a company for legal and tax purposes. '
             'A company can have multiple branches, but a branch belongs to one company. '
             'Note: This is the LEGAL entity, not the operational structure. '
             'Cannot be changed after transactions are created.'
    )
    manager_id = fields.Many2one(
        'res.users',
        string='Branch Manager',
        domain="[('share', '=', False)]",
        tracking=True,
        help='User responsible for this branch\'s operations. '
             'The manager typically has: approval authority, access to branch reports, '
             'and ability to manage branch-specific settings. '
             'Only internal users (not portal users) can be managers. '
             'Related: Configure persona for the manager to set approval limits and permissions.'
    )
    active = fields.Boolean(
        default=True,
        tracking=True,
        help='If unchecked, this branch becomes invisible in most views but data is preserved. '
             'Use this instead of deleting branches that have historical transactions. '
             'Inactive branches cannot be selected in new transactions but existing records remain visible. '
             'To reactivate: check this box again. '
             'Use Case: Closed stores, merged branches, or temporarily inactive locations.'
    )
    
    # ---------------------------------------------------------
    # Optional Fields
    # ---------------------------------------------------------
    parent_id = fields.Many2one(
        'ops.branch',
        string='Parent Branch',
        index=True,
        help='Parent branch in the organizational hierarchy for multi-level structures. '
             'Example: "North Region HQ" (parent) → "Seattle Store" (child) → "Seattle Outlet" (grandchild). '
             'Child branches can inherit settings and roll up reporting to parents. '
             'Leave empty if this is a top-level branch. '
             'Use Cases: Regional→City→Store, Corporate→Division→Department. '
             'Warning: Circular hierarchies (A→B→A) are automatically prevented.'
    )
    child_ids = fields.One2many(
        'ops.branch',
        'parent_id',
        string='Sub-Branches',
        help='Branches that report to this branch in the hierarchy. '
             'Example: If this is "North Region", children might be "Seattle", "Portland", "Vancouver". '
             'Use for consolidated reporting: parent branch reports include all child branch data. '
             'Automatically populated when child branches set this branch as their parent.'
    )
    address = fields.Text(
        string='Physical Address',
        help='Complete physical address of this branch location. '
             'Include: Street, City, State/Province, ZIP/Postal Code, Country. '
             'Used in: Customer-facing documents (invoices, delivery notes), shipping labels, branch reports. '
             'Format: Use line breaks for readability. '
             'Example: "123 Main Street\\nSuite 400\\nSeattle, WA 98101\\nUnited States". '
             'Best Practice: Keep updated for accurate shipping and legal compliance.'
    )
    phone = fields.Char(
        string='Phone',
        help='Primary contact phone number for this branch. '
             'Used for: Customer service inquiries, inter-branch communication, emergency contacts. '
             'Format: Use your local convention (e.g., +1-555-123-4567, (555) 123-4567, +44 20 1234 5678). '
             'Best Practice: Include country code for international branches. '
             'Example: "+1-206-555-0100" or "(206) 555-0100"'
    )
    email = fields.Char(
        string='Email',
        help='Primary email address for this branch. '
             'Used for: Automated system notifications, inter-branch communication, customer inquiries. '
             'Format: branch@company.com or location-name@company.com. '
             'Examples: "seattle@acme.com", "north-region@acme.com", "warehouse3@acme.com". '
             'Best Practice: Use a group/department email (not personal) to ensure continuity. '
             'This email may appear on customer-facing documents.'
    )
    warehouse_id = fields.Many2one(
        'stock.warehouse',
        string='Primary Warehouse',
        help='The main warehouse associated with this branch for inventory operations. '
             'This warehouse is used by default when creating: stock transfers, sales orders, purchase orders. '
             'A branch can have multiple warehouses, but this is the primary one. '
             'Important: The warehouse must belong to the same company as the branch. '
             'Use Case: For retail branches, this is the stock room; for distribution centers, the main warehouse. '
             'Leave empty if this branch has no inventory operations (e.g., administrative office).'
    )
    sequence = fields.Integer(
        default=10,
        string='Sequence',
        help='Controls the display order of branches in lists and drop-down menus. '
             'Lower numbers appear first. Default is 10. '
             'Example: Set 1 for headquarters, 5 for regional offices, 10 for standard branches. '
             'Use Cases: Prioritize frequently-used branches, group by region, order by importance. '
             'Tip: Use increments of 5 or 10 to allow easy reordering later.'
    )
    color = fields.Integer(
        string='Color Index',
        default=0,
        help='Color coding for visual identification in kanban and calendar views. '
             'Values 0-11 map to predefined colors in the Odoo interface. '
             'Use Cases: Color code by region (Red=West, Blue=East), by type (Green=Retail, Yellow=Warehouse). '
             'Example: All branches in North region use color 2 (blue), South region uses color 1 (red). '
             'Tip: Keep color scheme consistent across your organization for easy recognition.'
    )

    # ---------------------------------------------------------
    # Analytic Integration
    # ---------------------------------------------------------
    analytic_account_id = fields.Many2one(
        'account.analytic.account',
        string='Analytic Account',
        copy=False,
        readonly=True,
        help='Auto-generated analytic account for financial tracking and cost/profit analysis by branch. '
             'Automatically created when the branch is saved. '
             'Used to: Track revenue and expenses by branch, generate P&L reports, allocate costs. '
             'Format: Code and name match the branch (e.g., "BR-001 - Seattle Store"). '
             'This field is READ-ONLY and managed automatically by the system. '
             'Related: All financial transactions for this branch are tagged with this analytic account.'
    )

    # ---------------------------------------------------------
    # Computed Fields
    # ---------------------------------------------------------
    business_unit_count = fields.Integer(
        compute='_compute_business_unit_count',
        string='Business Units Count',
        help='Number of business units (BUs) operating in this branch. '
             'A branch can host multiple BUs (e.g., Retail, Wholesale, Services). '
             'Computed automatically - counts BUs that list this branch in their operating branches. '
             'Click the smart button to view the list of BUs. '
             'Example: "Downtown Store" might have 3 BUs: Retail Electronics, Retail Appliances, Repair Services. '
             'Use Cases: Understanding branch complexity, resource allocation, reporting structure.'
    )

    # ---------------------------------------------------------
    # SQL Constraints
    # ---------------------------------------------------------
    _sql_constraints = [
        ('code_company_unique',
         'UNIQUE(code, company_id)',
         'Branch Code must be unique per company!')
    ]

    # ---------------------------------------------------------
    # Computed Methods
    # ---------------------------------------------------------
    def _compute_business_unit_count(self) -> None:
        """Count business units operating in this branch."""
        for branch in self:
            branch.business_unit_count = self.env['ops.business.unit'].search_count([
                ('branch_ids', 'in', branch.id)
            ])

    # ---------------------------------------------------------
    # Constraints & Validation
    # ---------------------------------------------------------
    @api.constrains('parent_id')
    def _check_parent_recursion(self) -> None:
        """Prevent circular parent relationships."""
        if not self._check_recursion():
            raise ValidationError(_('Error! You cannot create recursive branch hierarchies.'))

    def unlink(self) -> bool:
        """Prevent deletion if branch has active transactions."""
        for branch in self:
            # Check for related transactions
            transaction_models = [
                'sale.order',
                'purchase.order',
                'account.move',
                'stock.picking',
            ]
            
            for model_name in transaction_models:
                if self.env[model_name].search_count([('ops_branch_id', '=', branch.id)], limit=1) > 0:
                    raise UserError(_(
                        "Cannot delete branch '%s' because it has related transactions. "
                        "Please deactivate it instead."
                    ) % branch.name)
        
        return super().unlink()

    # ---------------------------------------------------------
    # CRUD & Analytic Sync
    # ---------------------------------------------------------
    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsBranch':
        """Create branch with auto-generated code and analytic account."""
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.branch') or 'New'
        
        records = super().create(vals_list)
        records._create_analytic_accounts()
        return records

    def write(self, vals: Dict[str, Any]) -> bool:
        """Update branch and sync analytic account if name/code changed."""
        result = super().write(vals)
        if 'name' in vals or 'code' in vals:
            self._sync_analytic_account_name()
        return result

    # ---------------------------------------------------------
    # Analytic Account Management
    # ---------------------------------------------------------
    def _create_analytic_accounts(self) -> None:
        """Auto-create analytic account for each branch."""
        for branch in self:
            if not branch.analytic_account_id:
                analytic_plan = self._get_or_create_analytic_plan('Branch')
                analytic_account = self.env['account.analytic.account'].create({
                    'name': f"{branch.code} - {branch.name}",
                    'code': branch.code,
                    'plan_id': analytic_plan.id,
                    'company_id': branch.company_id.id,
                })
                branch.analytic_account_id = analytic_account.id

    def _sync_analytic_account_name(self) -> None:
        """Sync analytic account name when branch name/code changes."""
        for branch in self:
            if branch.analytic_account_id:
                branch.analytic_account_id.write({
                    'name': f"{branch.code} - {branch.name}",
                    'code': branch.code,
                })

    def _get_or_create_analytic_plan(self, plan_type: str) -> 'account.analytic.plan':
        """Get or create analytic plan for Branch dimension."""
        plan_name = f"Matrix {plan_type}"
        plan = self.env['account.analytic.plan'].search([('name', '=', plan_name)], limit=1)
        if not plan:
            plan = self.env['account.analytic.plan'].create({
                'name': plan_name,
                # Note: company_id removed - not available in Odoo 19
                'description': f'{plan_type} dimension for Matrix reporting',
            })
        return plan

    # ---------------------------------------------------------
    # Display Name
    # ---------------------------------------------------------
    def name_get(self):
        """Display as '[CODE] Name'."""
        result = []
        for branch in self:
            name = f"[{branch.code}] {branch.name}"
            result.append((branch.id, name))
        return result

>>> ops_matrix_core/models/ops_business_unit.py <<<
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from typing import List, Dict, Any

class OpsBusinessUnit(models.Model):
    _name = 'ops.business.unit'
    _description = 'Strategic Business Unit (Profit Center)'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'sequence, id'

    # ---------------------------------------------------------
    # Basic Fields
    # ---------------------------------------------------------
    name = fields.Char(
        required=True,
        tracking=True,
        string='Business Unit Name',
        help='Business Unit name representing a distinct business vertical, product line, or profit center. '
             'Examples: "Retail Division", "Wholesale Operations", "E-Commerce", "Professional Services". '
             'This name appears throughout the system in: reports, product catalogs, financial statements, access control. '
             'Best Practice: Use consistent naming that reflects your organizational structure. '
             'A BU typically has its own P&L and may operate across multiple branches.'
    )
    code = fields.Char(
        string='Code',
        required=True,
        readonly=True,
        copy=False,
        default=lambda self: _('New'),
        tracking=True,
        help='Unique identifier for this Business Unit across all companies. '
             'Auto-generated on save (format: BU-XXXX). '
             'Used in: Product codes, financial reports, analytics, security rules. '
             'Cannot be changed after creation. '
             'Examples: BU-RETAIL, BU-WHSL, BU-ONLINE, BU-SERV. '
             'Format: Alphanumeric, no spaces, typically 6-12 characters. '
             'This code becomes part of product identifiers if product silo is enabled.'
    )
    description = fields.Text(
        string='Description',
        help='Detailed description of this Business Unit\'s purpose, scope, and responsibilities. '
             'Include: Products/services offered, target market, key objectives, operational scope. '
             'Example: "Retail Division handles all consumer-facing retail sales across our store network, '
             'including electronics, appliances, and accessories. Target customers: individual consumers and small businesses." '
             'Use Cases: Onboarding new employees, documenting organizational structure, clarifying BU boundaries. '
             'Best Practice: Keep updated as the BU evolves.'
    )
    sequence = fields.Integer(
        default=10,
        string='Sequence',
        help='Controls the display order of Business Units in lists, reports, and drop-down menus. '
             'Lower numbers appear first. Default is 10. '
             'Example: Set 1 for flagship BU, 5 for major BUs, 10 for standard BUs, 20 for support BUs. '
             'Use Cases: Prioritize frequently-used BUs, group by importance, order by revenue contribution. '
             'Tip: Use increments of 5 or 10 to allow easy reordering without affecting other BUs.'
    )
    active = fields.Boolean(
        default=True,
        tracking=True,
        help='If unchecked, this Business Unit becomes invisible in most views but historical data is preserved. '
             'Use this instead of deleting BUs that have: historical transactions, products, or financial records. '
             'Inactive BUs cannot be selected for new: products, sales orders, or transactions. '
             'Existing products and transactions remain visible and reportable. '
             'To reactivate: check this box again. '
             'Use Cases: Discontinued product lines, merged BUs, seasonal operations, restructured divisions.'
    )
    color = fields.Integer(
        string='Color Index',
        default=0,
        help='Color coding for visual identification in kanban, calendar, and dashboard views. '
             'Values 0-11 map to predefined Odoo colors. '
             'Use Cases: Color code by BU type (Blue=Retail, Green=Wholesale, Yellow=Services), '
             'by performance (Green=profitable, Red=needs attention), or by market segment. '
             'Example: All B2C BUs use color 2 (blue), B2B BUs use color 3 (yellow). '
             'Tip: Maintain consistent color schemes for easy recognition across reports and views.'
    )
    target_margin_percent = fields.Float(
        string='Target Margin %',
        help='Target profit margin percentage for this Business Unit (e.g., 15.0 for 15%). '
             'Used for: Performance dashboards, variance analysis, manager KPIs, executive reports. '
             'The system compares actual margin against this target and highlights variances. '
             'Example: Retail BUs might target 25%, Wholesale 10%, Services 40%. '
             'Calculation: (Revenue - COGS - Operating Expenses) / Revenue × 100. '
             'Best Practice: Review and adjust quarterly based on market conditions and strategic goals. '
             'Leave at 0 if margin targets don\'t apply to this BU.'
    )

    # ---------------------------------------------------------
    # Hierarchy - Link to Branches (not Companies)
    # ---------------------------------------------------------
    branch_ids = fields.Many2many(
        'ops.branch',
        'business_unit_branch_rel',
        'business_unit_id',
        'branch_id',
        string='Operating Branches',
        required=True,
        help='Branches where this Business Unit operates. Required: At least one branch must be selected. '
             'A BU can operate in multiple branches (multi-location BUs) or a single branch (location-specific BUs). '
             'Examples: '
             '- "Retail Electronics" operates in all retail store branches '
             '- "Warehouse Operations" operates only in the distribution center branch '
             '- "Regional Services" operates in all branches within a region. '
             'Access Control: Users need access to BOTH a branch AND this BU to see related transactions. '
             'Reporting: BU reports can be filtered by branch to analyze performance by location.'
    )
    
    company_ids = fields.Many2many(
        'res.company',
        string='Companies',
        compute='_compute_company_ids',
        store=True,
        help='Legal entities (companies) where this BU operates. Computed automatically from operating branches. '
             'A BU spans companies if its branches belong to different legal entities. '
             'This field is READ-ONLY and automatically maintained. '
             'Used for: Multi-company filtering, legal entity reporting, compliance. '
             'Example: If BU operates in branches from Company A and Company B, both companies are listed. '
             'Important: Cannot be edited directly - change the operating branches to update companies.'
    )
    
    primary_branch_id = fields.Many2one(
        'ops.branch',
        string='Primary Branch',
        tracking=True,
        help='The main/headquarters branch for this Business Unit. '
             'This is where the BU Leader typically sits and where administrative functions are based. '
             'Must be one of the branches selected in "Operating Branches" above. '
             'Used for: Default financial reporting location, primary contact branch, cost allocations. '
             'Example: A regional BU operates in 20 stores but has headquarters in the regional office branch. '
             'Optional: Leave empty if there is no primary branch (all branches are equal). '
             'This does NOT restrict operations to only this branch.'
    )

    # ---------------------------------------------------------
    # Leadership
    # ---------------------------------------------------------
    leader_id = fields.Many2one(
        'res.users',
        string='Unit Leader',
        domain="[('share', '=', False)]",
        tracking=True,
        help='User responsible for this Business Unit\'s overall performance and operations. '
             'Typically has: P&L responsibility, strategic decision authority, resource allocation control. '
             'The leader typically receives: performance reports, approval requests, budget variance alerts. '
             'Only internal users (not portal users) can be BU leaders. '
             'Examples: "VP of Retail", "Wholesale Operations Director", "E-Commerce Manager". '
             'Related: Configure a Persona for the leader to set approval limits and delegation rules. '
             'Best Practice: Assign a leader for each active BU to ensure clear accountability.'
    )

    # ---------------------------------------------------------
    # Analytic Integration
    # ---------------------------------------------------------
    analytic_account_id = fields.Many2one(
        'account.analytic.account',
        string='Analytic Account',
        copy=False,
        readonly=True,
        help='Auto-generated analytic account for tracking this BU as a profit center. '
             'Automatically created when the BU is saved. '
             'Used to: Generate P&L by BU, track revenue and costs, analyze profitability, allocate shared expenses. '
             'Format: Code and name match the BU (e.g., "BU-RETAIL - Retail Division"). '
             'All financial transactions for this BU are tagged with this analytic account. '
             'This field is READ-ONLY and managed automatically by the system. '
             'Financial reports can filter by this account to show BU-specific performance.'
    )

    # ---------------------------------------------------------
    # Computed Fields
    # ---------------------------------------------------------
    branch_count = fields.Integer(
        compute='_compute_branch_count',
        string='Branch Count',
        help='Total number of branches where this Business Unit currently operates. '
             'Computed automatically from the "Operating Branches" list. '
             'Click the smart button to view the full list of branches. '
             'Examples: Single-branch BU shows 1, regional BU might show 10-20, nationwide BU could show 100+. '
             'Use Cases: Assessing BU scale, resource planning, understanding operational complexity. '
             'Performance Tip: BUs operating in many branches may need dedicated coordination roles.'
    )

    @api.depends('branch_ids')
    def _compute_branch_count(self) -> None:
        """Count branches for this BU."""
        for bu in self:
            bu.branch_count = len(bu.branch_ids)

    @api.depends('branch_ids', 'branch_ids.company_id')
    def _compute_company_ids(self) -> None:
        """Compute companies from branches."""
        for bu in self:
            bu.company_ids = bu.branch_ids.mapped('company_id')

    # ---------------------------------------------------------
    # Constraints & Validation
    # ---------------------------------------------------------
    @api.constrains('branch_ids')
    def _check_branch_ids(self) -> None:
        """Business Unit must operate in at least one branch."""
        for bu in self:
            if not bu.branch_ids:
                raise ValidationError(_("Business Unit must operate in at least one branch."))

    @api.constrains('primary_branch_id', 'branch_ids')
    def _check_primary_branch(self) -> None:
        """Primary branch must be in operating branches."""
        for bu in self:
            if bu.primary_branch_id and bu.primary_branch_id not in bu.branch_ids:
                raise ValidationError(_(
                    "Primary branch '%s' must be in the list of operating branches."
                ) % bu.primary_branch_id.name)

    _sql_constraints = [
        ('code_unique',
         'UNIQUE(code)',
         'Business Unit Code must be unique!')
    ]

    # ---------------------------------------------------------
    # CRUD & Analytic Sync
    # ---------------------------------------------------------
    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsBusinessUnit':
        """Create BU with auto-generated code and analytic account."""
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.business.unit') or 'New'
        
        records = super().create(vals_list)
        records._create_analytic_accounts()
        return records

    def write(self, vals: Dict[str, Any]) -> bool:
        """Update BU and sync analytic account if name/code changed."""
        result = super().write(vals)
        if 'name' in vals or 'code' in vals:
            self._sync_analytic_account_name()
        return result

    # ---------------------------------------------------------
    # Analytic Account Management
    # ---------------------------------------------------------
    def _create_analytic_accounts(self) -> None:
        """Create one analytic account per BU (not per branch)."""
        for bu in self:
            if not bu.analytic_account_id:
                # Use primary branch's company, or first company if no primary
                company_id = False
                if bu.primary_branch_id:
                    company_id = bu.primary_branch_id.company_id.id
                elif bu.company_ids:
                    company_id = bu.company_ids[0].id
                else:
                    company_id = self.env.company.id
                
                analytic_plan = self._get_or_create_analytic_plan('Business Unit')
                analytic_account = self.env['account.analytic.account'].create({
                    'name': f"{bu.code} - {bu.name}",
                    'code': bu.code,
                    'plan_id': analytic_plan.id,
                    'company_id': company_id,
                })
                bu.analytic_account_id = analytic_account.id

    def _sync_analytic_account_name(self) -> None:
        """Sync analytic account name when BU name/code changes."""
        for bu in self:
            if bu.analytic_account_id:
                bu.analytic_account_id.write({
                    'name': f"{bu.code} - {bu.name}",
                    'code': bu.code,
                })

    def _get_or_create_analytic_plan(self, plan_type: str) -> 'account.analytic.plan':
        """Get or create analytic plan for Business Unit dimension."""
        plan_name = f"Matrix {plan_type}"
        plan = self.env['account.analytic.plan'].search([('name', '=', plan_name)], limit=1)
        if not plan:
            plan = self.env['account.analytic.plan'].create({
                'name': plan_name,
                # Note: company_id removed - not available in Odoo 19
                'description': f'{plan_type} dimension for Matrix reporting',
            })
        return plan

    # ---------------------------------------------------------
    # Display Name
    # ---------------------------------------------------------
    def name_get(self):
        """Display as '[CODE] Name'."""
        result = []
        for bu in self:
            name = f"[{bu.code}] {bu.name}"
            result.append((bu.id, name))
        return result

>>> ops_matrix_core/models/ops_governance_rule.py <<<
# -*- coding: utf-8 -*-

from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from odoo.tools.safe_eval import safe_eval
import logging

_logger = logging.getLogger(__name__)

TRIGGER_TYPES = [
    ('on_create', 'On Create'),
    ('on_write', 'On Write'),
    ('on_unlink', 'On Delete'),
]

ACTION_TYPES = [
    ('warning', 'Warning'),
    ('block', 'Block'),
    ('require_approval', 'Require Approval'),
]


class OpsGovernanceRule(models.Model):
    _name = 'ops.governance.rule'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _description = 'OPS Governance Rule - Dynamic Rule Engine with Matrix & Pricing Controls'
    _order = 'sequence, name'

    # --- CORE FIELDS ---
    name = fields.Char(
        string='Rule Name',
        required=True,
        tracking=True,
        help='Descriptive name for this governance rule. '
             'Use clear, action-oriented names that explain what the rule enforces. '
             'Examples: "Sales Order Discount Limit", "Margin Protection - Electronics", '
             '"Branch Selection Required", "High-Value Purchase Approval". '
             'Best Practice: Include the rule type and scope in the name for easy identification. '
             'This name appears in: approval requests, violation logs, compliance reports.'
    )
    code = fields.Char(string='Rule Code', required=True, copy=False, readonly=True,
                      default=lambda self: self.env['ir.sequence'].next_by_code('ops.governance.rule') or 'New')
    active = fields.Boolean(string='Active', default=True, tracking=True)
    sequence = fields.Integer(
        string='Sequence',
        default=10,
        help='Order in which rules are evaluated. Lower numbers = higher priority (evaluated first). '
             'Default is 10. Important: Rule evaluation stops at first blocking rule. '
             'Use Cases: '
             '- Critical validations (branch selection): sequence = 1 '
             '- Discount limits: sequence = 5 '
             '- Margin protection: sequence = 10 '
             '- Notifications: sequence = 20. '
             'Tip: Use increments of 5 to allow inserting rules between existing ones.'
    )
    description = fields.Text(string='Description', compute='_compute_description', store=True)
    
    # --- SCOPE & TARGETING ---
    model_id = fields.Many2one(
        'ir.model',
        string='Applies To Model',
        required=True,
        ondelete='cascade',
        help='The Odoo model (object type) this rule applies to. Required. '
             'Common models: '
             '- sale.order (Sales Orders) '
             '- sale.order.line (Sales Order Lines) '
             '- purchase.order (Purchase Orders) '
             '- account.move (Invoices/Bills) '
             '- stock.picking (Transfers). '
             'Scope: Rule only evaluates records of this model type. '
             'Example: Discount rule on "sale.order.line" validates each line item discount.'
    )
    company_id = fields.Many2one('res.company', string='Company', required=True,
                                default=lambda self: self.env.company)
    
    rule_type = fields.Selection([
        ('matrix_validation', 'Matrix Validation'),
        ('discount_limit', 'Discount Limit'),
        ('margin_protection', 'Margin Protection'),
        ('price_override', 'Price Override'),
        ('approval_workflow', 'Approval Workflow'),
        ('notification', 'Notification'),
        ('legacy', 'Legacy (Backward Compatibility)'),
    ], string='Rule Type',
       required=True,
       tracking=True,
       default='legacy',
       help='Category of governance control this rule enforces. '
            'Matrix Validation: Ensures branch/BU are selected and valid. '
            'Discount Limit: Controls maximum discounts by role/category. '
            'Margin Protection: Enforces minimum profit margins. '
            'Price Override: Limits price changes from list price. '
            'Approval Workflow: Routes transactions for approval. '
            'Notification: Sends alerts without blocking. '
            'Legacy: Custom rules using domain/code conditions. '
            'Each type has specific configuration fields that appear when selected.')
    
    # New unified trigger field
    trigger_event = fields.Selection([
        ('always', 'Always'),
        ('on_create', 'On Create'),
        ('on_write', 'On Write'),
        ('on_state_change', 'On State Change'),
    ], string='Trigger Event',
       default='always',
       tracking=True,
       help='When this rule should be evaluated. '
            'Always: Checks on every create and update operation. '
            'On Create: Only when record is first created. '
            'On Write: Only when record is modified (not on creation). '
            'On State Change: Only when status field changes (draft→confirmed). '
            'Performance Tip: Use specific triggers instead of "Always" for better performance. '
            'Example: Discount validation on "On Write" since discounts can change after creation.')
    
    # New unified condition logic field - Changed to Char for domain widget
    condition_logic = fields.Char(
        string='Condition Logic',
        help='Optional filter to limit when this rule applies. Use the visual domain builder. '
             'Click "Add a filter" to build conditions without coding. '
             'Examples: '
             '- Apply only to orders > $10,000: [("amount_total", ">", 10000)] '
             '- Apply only to specific partner: [("partner_id", "=", 123)] '
             '- Apply to confirmed orders: [("state", "=", "sale")]. '
             'Leave empty to apply to all records of the selected model. '
             'Advanced: Supports Python domain syntax for complex conditions.'
    )
    
    # Computed field for domain widget anchor
    model_name = fields.Char(
        string='Model Name',
        related='model_id.model',
        store=True,
        readonly=True,
        help='Technical model name for domain widget'
    )
    
    # Legacy fields for backward compatibility
    trigger_condition = fields.Selection([
        ('always', 'Always'),
        ('on_create', 'On Create'),
        ('on_update', 'On Update'),
        ('on_state_change', 'On State Change'),
    ], string='Trigger Condition (Legacy)', default='always')
    
    state_condition = fields.Char(string='State Condition',
                                 help='Python expression for state evaluation. Example: state in ["draft", "sent"]')
    
    # --- MATRIX DIMENSION VALIDATION ---
    enforce_branch_bu = fields.Boolean(
        string='Enforce Branch/BU Selection',
        help='When enabled, validates that Branch and Business Unit are properly selected on transactions. '
             'Checks performed: '
             '- Branch field is filled (if "Branch Required" checked) '
             '- Business Unit field is filled (if "Business Unit Required" checked) '
             '- Selected BU operates in selected Branch (compatibility check). '
             'Use for: Ensuring matrix organization compliance, preventing unallocated transactions. '
             'Applies to: sale.order, purchase.order, account.move, stock.picking models. '
             'Related fields: "Allowed Branches", "Allowed Business Units" for additional restrictions.'
    )
    
    allowed_branch_ids = fields.Many2many('ops.branch', 'rule_branch_rel',
                                         string='Allowed Branches',
                                         help='Restrict to specific branches. Empty = all branches.')
    
    allowed_business_unit_ids = fields.Many2many('ops.business.unit', 'rule_bu_rel',
                                                string='Allowed Business Units',
                                                help='Restrict to specific BUs. Empty = all BUs.')
    
    branch_required = fields.Boolean(
        string='Branch Required',
        default=True,
        help='If enabled, transactions must have a branch selected. '
             'When to enable: Always (for matrix organizations). '
             'When to disable: For global/unallocated transactions, centralized purchasing. '
             'Validation: Blocks save if branch is empty. '
             'Default: Enabled (recommended for matrix compliance).'
    )
    bu_required = fields.Boolean(
        string='Business Unit Required',
        default=True,
        help='If enabled, transactions must have a business unit selected. '
             'When to enable: Always (for profit center tracking). '
             'When to disable: For corporate overhead, shared services, R&D. '
             'Validation: Blocks save if BU is empty. '
             'Default: Enabled (recommended for P&L tracking).'
    )
    
    # --- DISCOUNT CONTROL ---
    enforce_discount_limit = fields.Boolean(
        string='Enforce Discount Limit',
        help='When enabled, validates that discounts do not exceed authorized limits. '
             'How it works: '
             '1. System checks user\'s persona/role '
             '2. Looks up their discount authority (in Discount Limits section below) '
             '3. Compares transaction discount to their limit '
             '4. Blocks or requires approval if exceeded. '
             'Use for: Protecting margins, preventing unauthorized discounting. '
             'Configure: Add role-based limits in "Role-Based Discount Limits" tab. '
             'Related: Set "Global Discount Limit %" for default maximum.'
    )
    global_discount_limit = fields.Float(
        string='Global Discount Limit %',
        default=0.0,
        help='Default maximum discount percentage if no role-specific limit is defined. '
             'Applies to: All users who don\'t have a higher limit in Role-Based Discount Limits. '
             'Range: 0-100 (0 = no discounts allowed, 100 = any discount allowed). '
             'Examples: '
             '- Sales rep default = 5% '
             '- Manager can override up to 15% in discount limits '
             '- Executive can override up to 30% in discount limits. '
             'Leave at 0 if all users must have explicitly defined limits.'
    )
    
    discount_validation_level = fields.Selection([
        ('line', 'Per Line'),
        ('order', 'Per Order'),
        ('both', 'Both Line and Order'),
    ], string='Discount Validation Level', default='line')
    
    # --- MARGIN PROTECTION ---
    enforce_margin_protection = fields.Boolean(
        string='Enforce Margin Protection',
        help='When enabled, ensures profit margins meet minimum thresholds. '
             'How it works: '
             '1. Calculates margin: (Revenue - Cost) / Revenue × 100 '
             '2. Compares to minimum margin rules (by product category, BU, branch) '
             '3. Blocks or requires approval if margin too low. '
             'Use for: Preventing unprofitable sales, protecting company margins. '
             'Configure: Set "Global Minimum Margin %" and add category-specific rules below. '
             'Calculation: Uses product standard cost vs. sale price.'
    )
    global_minimum_margin = fields.Float(
        string='Global Minimum Margin %',
        default=0.0,
        help='Default minimum profit margin percentage for all products. '
             'Applies unless category-specific rule exists (see Category-Specific Margin Rules). '
             'Range: 0-100 (e.g., 15.0 = 15% margin required). '
             'Examples: '
             '- Retail: 25% minimum '
             '- Wholesale: 10% minimum '
             '- Services: 40% minimum. '
             'Calculation: ((Sale Price - Cost) / Sale Price) × 100 must be ≥ this value.'
    )
    warning_margin_threshold = fields.Float(string='Warning Margin Threshold %', default=5.0,
                                           help='Margin percentage that triggers warning')
    
    # --- PRICE OVERRIDE CONTROL ---
    enforce_price_override = fields.Boolean(string='Enforce Price Override Control')
    global_max_price_variance = fields.Float(string='Global Max Price Variance %', default=0.0)
    
    # --- APPROVAL CONFIGURATION ---
    require_approval = fields.Boolean(
        string='Require Approval',
        help='When enabled, violations trigger approval workflow instead of blocking. '
             'Behavior: '
             '- Unchecked: Violations block the transaction (hard stop) '
             '- Checked: Transaction allowed but approval request created. '
             'Use Cases: '
             '- Exceptions allowed with management approval '
             '- High-value transactions need review '
             '- Unusual discount requests. '
             'Workflow: System finds approvers based on branch/BU and routes request. '
             'Approvers: Configure in "Approval Users/Personas" or notification groups.'
    )
    approval_workflow_id = fields.Many2one('ops.approval.workflow', string='Approval Workflow')
    auto_create_approval = fields.Boolean(string='Auto-Create Approval Request', default=True)
    
    # --- NOTIFICATION ---
    notify_users = fields.Boolean(string='Notify Users')
    notify_template_id = fields.Many2one('mail.template', string='Notification Template')
    notify_groups = fields.Many2many('res.groups', string='Notify Groups')
    
    # --- RELATED RECORDS ---
    discount_limit_ids = fields.One2many('ops.governance.discount.limit', 'rule_id',
                                        string='Role-Based Discount Limits')
    
    margin_rule_ids = fields.One2many('ops.governance.margin.rule', 'rule_id',
                                     string='Category-Specific Margin Rules')
    
    price_authority_ids = fields.One2many('ops.governance.price.authority', 'rule_id',
                                         string='Role-Based Price Authority')
    
    # --- COMPUTED FIELDS ---
    violation_count = fields.Integer(string='Violation Count', compute='_compute_violation_count')
    active_approval_count = fields.Integer(string='Active Approvals', compute='_compute_approval_count')
    
    # --- LEGACY FIELDS (Backward Compatibility) ---
    trigger_type = fields.Selection(TRIGGER_TYPES, string='Trigger Event', default='on_write')
    condition_domain = fields.Text(string='Condition Domain')
    condition_code = fields.Text(string='Condition Code (Python)')
    action_type = fields.Selection(ACTION_TYPES, string='Action Type', default='warning')
    error_message = fields.Char(string='Error/Warning Message')
    approval_user_ids = fields.Many2many('res.users', 'rule_user_rel', string='Approval Users')
    approval_persona_ids = fields.Many2many('ops.persona', 'rule_approval_persona_rel',
                                           'rule_id', 'persona_id', string='Approval Personas')
    lock_on_approval_request = fields.Boolean(string='Lock During Approval', default=True)
    min_margin_percent = fields.Float(string='Minimum Margin %')
    max_discount_percent = fields.Float(string='Maximum Discount %')
    business_unit_id = fields.Many2one('ops.business.unit', string='Business Unit')
    
    # --- VALIDATION METHODS ---
    
    @api.constrains('allowed_branch_ids', 'company_id')
    def _check_branch_company(self):
        """Ensure allowed branches belong to rule's company."""
        for rule in self:
            invalid_branches = rule.allowed_branch_ids.filtered(
                lambda b: b.company_id != rule.company_id
            )
            if invalid_branches:
                raise ValidationError(
                    _("Branches %s do not belong to company %s") % (
                        ', '.join(invalid_branches.mapped('name')),
                        rule.company_id.name
                    )
                )
    
    @api.constrains('min_margin_percent', 'max_discount_percent')
    def _check_percentages(self):
        """Validate margin and discount percentages."""
        for record in self:
            if record.min_margin_percent and (record.min_margin_percent < 0 or record.min_margin_percent > 100):
                raise ValidationError(_('Minimum margin percentage must be between 0 and 100.'))
            if record.max_discount_percent and (record.max_discount_percent < 0 or record.max_discount_percent > 100):
                raise ValidationError(_('Maximum discount percentage must be between 0 and 100.'))
    
    # --- BUSINESS METHODS ---
    
    def validate_record(self, record, trigger_type='always'):
        """Validate record against this rule."""
        self.ensure_one()
        
        # ADMIN BYPASS: Skip validation for Administrator and System Managers
        if self.env.su or self.env.user.has_group('base.group_system'):
            return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
        
        # Check if rule applies to this trigger (use trigger_event if set, fallback to trigger_condition)
        active_trigger = self.trigger_event or self.trigger_condition
        if active_trigger != 'always' and active_trigger != trigger_type:
            return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
        
        # Evaluate new condition_logic field if specified
        if self.condition_logic:
            try:
                eval_context = {
                    'record': record,
                    'self': record,
                    'user': self.env.user,
                    'env': self.env,
                }
                # Add common fields to context
                for field in ['state', 'amount_total', 'amount_untaxed', 'partner_id', 'company_id']:
                    if hasattr(record, field):
                        eval_context[field] = getattr(record, field)
                
                condition_result = safe_eval(self.condition_logic, eval_context)
                if not condition_result:
                    return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
            except Exception as e:
                _logger.warning(f"Could not evaluate condition_logic for rule {self.name}: {e}")
                return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
        
        # Check legacy state condition if specified
        if self.state_condition:
            try:
                if not safe_eval(self.state_condition, {'record': record, 'state': record.state if hasattr(record, 'state') else None}):
                    return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
            except Exception as e:
                _logger.warning(f"Could not evaluate state condition for rule {self.name}: {e}")
        
        errors = []
        warnings = []
        requires_approval = False
        
        # 1. MATRIX DIMENSION VALIDATION
        if self.enforce_branch_bu:
            matrix_result = self._validate_matrix_dimensions(record)
            errors.extend(matrix_result['errors'])
            warnings.extend(matrix_result['warnings'])
            requires_approval = requires_approval or matrix_result['requires_approval']
        
        # 2. DISCOUNT LIMIT VALIDATION
        if self.enforce_discount_limit:
            discount_result = self._validate_discount(record)
            errors.extend(discount_result['errors'])
            warnings.extend(discount_result['warnings'])
            requires_approval = requires_approval or discount_result['requires_approval']
        
        # 3. MARGIN PROTECTION VALIDATION
        if self.enforce_margin_protection:
            margin_result = self._validate_margin(record)
            errors.extend(margin_result['errors'])
            warnings.extend(margin_result['warnings'])
            requires_approval = requires_approval or margin_result['requires_approval']
        
        # 4. PRICE OVERRIDE VALIDATION
        if self.enforce_price_override:
            price_result = self._validate_price_override(record)
            errors.extend(price_result['errors'])
            warnings.extend(price_result['warnings'])
            requires_approval = requires_approval or price_result['requires_approval']
        
        # 5. LEGACY CONDITION VALIDATION
        if self.rule_type == 'legacy' and (self.condition_domain or self.condition_code):
            legacy_result = self._evaluate_legacy_condition(record)
            if not legacy_result:
                errors.extend([self.error_message or 'Legacy rule condition not met'])
        
        return {
            'valid': len(errors) == 0,
            'warnings': warnings,
            'errors': errors,
            'requires_approval': requires_approval,
        }
    
    def _validate_matrix_dimensions(self, record):
        """Validate matrix dimensions (Branch/BU)."""
        errors = []
        warnings = []
        requires_approval = False
        
        # Check if record has matrix fields
        has_branch = hasattr(record, 'ops_branch_id')
        has_bu = hasattr(record, 'ops_business_unit_id')
        
        # Branch validation
        if self.branch_required and has_branch:
            if not record.ops_branch_id:
                errors.append(_("Branch selection is required by governance rule '%s'") % self.name)
            elif self.allowed_branch_ids and record.ops_branch_id not in self.allowed_branch_ids:
                errors.append(
                    _("Branch '%s' is not allowed. Allowed branches: %s") % (
                        record.ops_branch_id.name,
                        ', '.join(self.allowed_branch_ids.mapped('name'))
                    )
                )
        
        # BU validation
        if self.bu_required and has_bu:
            if not record.ops_business_unit_id:
                errors.append(_("Business Unit selection is required by governance rule '%s'") % self.name)
            elif self.allowed_business_unit_ids and record.ops_business_unit_id not in self.allowed_business_unit_ids:
                errors.append(
                    _("Business Unit '%s' is not allowed. Allowed BUs: %s") % (
                        record.ops_business_unit_id.name,
                        ', '.join(self.allowed_business_unit_ids.mapped('name'))
                    )
                )
        
        # Cross-validation: Ensure BU operates in selected branch
        if has_branch and has_bu and record.ops_branch_id and record.ops_business_unit_id:
            if record.ops_branch_id not in record.ops_business_unit_id.branch_ids:
                errors.append(
                    _("Business Unit '%s' does not operate in branch '%s'") % (
                        record.ops_business_unit_id.name,
                        record.ops_branch_id.name
                    )
                )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _validate_discount(self, record):
        """Validate discount against limits."""
        errors = []
        warnings = []
        requires_approval = False
        
        # Get current user and their persona
        user = self.env.user
        user_personas = user.persona_ids if hasattr(user, 'persona_ids') else self.env['ops.persona']
        
        if record._name == 'sale.order.line':
            # Line-level discount validation
            discount = record.discount
            
            # Get user's discount limit from persona
            max_discount = self._get_user_discount_limit(user, user_personas, record)
            
            if discount > max_discount:
                # Check if approval is configured
                if self.require_approval:
                    requires_approval = True
                    warnings.append(
                        _("Discount %.2f%% exceeds your limit of %.2f%%. Approval will be requested.") % (
                            discount, max_discount
                        )
                    )
                else:
                    errors.append(
                        _("Discount %.2f%% exceeds maximum allowed %.2f%%.") % (discount, max_discount)
                    )
        
        elif record._name == 'sale.order':
            # Order-level discount validation
            if self.discount_validation_level in ['order', 'both']:
                order_discount = getattr(record, 'global_discount', 0.0) or 0.0
                max_discount = self._get_user_discount_limit(user, user_personas, record)
                
                if order_discount > max_discount:
                    if self.require_approval:
                        requires_approval = True
                        warnings.append(
                            _("Order discount %.2f%% exceeds your limit of %.2f%%. Approval will be requested.") % (
                                order_discount, max_discount
                            )
                        )
                    else:
                        errors.append(
                            _("Order discount %.2f%% exceeds maximum allowed %.2f%%.") % (order_discount, max_discount)
                        )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _validate_margin(self, record):
        """Validate margin against thresholds."""
        errors = []
        warnings = []
        requires_approval = False
        
        if record._name == 'sale.order.line':
            margin_percent = self._calculate_line_margin(record)
            min_margin = self._get_minimum_margin(
                record.product_id.categ_id,
                getattr(record, 'ops_business_unit_id', False),
                getattr(record, 'ops_branch_id', False)
            )
            
            if margin_percent < min_margin:
                if self.require_approval:
                    requires_approval = True
                    warnings.append(
                        _("Margin %.2f%% is below minimum %.2f%%. Approval will be requested.") % (
                            margin_percent, min_margin
                        )
                    )
                else:
                    errors.append(
                        _("Margin %.2f%% is below minimum required %.2f%%.") % (margin_percent, min_margin)
                    )
            elif margin_percent < (min_margin + self.warning_margin_threshold):
                warnings.append(
                    _("Margin %.2f%% is close to minimum threshold %.2f%%.") % (margin_percent, min_margin)
                )
        
        elif record._name == 'sale.order':
            # Calculate order-level margin
            order_margin = self._calculate_order_margin(record)
            # Use lowest margin requirement from order lines
            min_margins = [
                self._get_minimum_margin(
                    line.product_id.categ_id,
                    getattr(line, 'ops_business_unit_id', False),
                    getattr(line, 'ops_branch_id', False)
                )
                for line in record.order_line if line.product_id
            ]
            min_margin = min(min_margins) if min_margins else self.global_minimum_margin
            
            if order_margin < min_margin:
                if self.require_approval:
                    requires_approval = True
                    warnings.append(
                        _("Order margin %.2f%% is below minimum %.2f%%. Approval will be requested.") % (
                            order_margin, min_margin
                        )
                    )
                else:
                    errors.append(
                        _("Order margin %.2f%% is below minimum required %.2f%%.") % (order_margin, min_margin)
                    )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _validate_price_override(self, record):
        """Validate price override against authorized limits."""
        errors = []
        warnings = []
        requires_approval = False
        
        if record._name == 'sale.order.line':
            # Get product list price
            list_price = record.product_id.list_price
            current_price = record.price_unit
            
            if list_price > 0:
                variance_percent = abs((current_price - list_price) / list_price * 100)
                max_variance = self._get_user_price_variance_limit(self.env.user, record)
                
                if variance_percent > max_variance:
                    if self.require_approval:
                        requires_approval = True
                        warnings.append(
                            _("Price variance %.2f%% exceeds your limit of %.2f%%. Approval will be requested.") % (
                                variance_percent, max_variance
                            )
                        )
                    else:
                        errors.append(
                            _("Price variance %.2f%% exceeds maximum allowed %.2f%%.") % (variance_percent, max_variance)
                        )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _evaluate_legacy_condition(self, record):
        """Evaluate legacy condition (backward compatibility)."""
        try:
            # Try domain first if available
            if self.condition_domain:
                domain = self._parse_domain_string(self.condition_domain)
                matches = record.filtered_domain(domain)
                if not matches:
                    return False
            
            # Try Python code if available
            if self.condition_code:
                safe_locals = {
                    'self': record,
                    'record': record,
                    'user': record.env.user,
                    'env': record.env,
                }
                result = safe_eval(self.condition_code, safe_locals)
                return bool(result)
            
            return True
        except Exception as e:
            _logger.error(f'Error evaluating legacy rule condition: {e}')
            return False
    
    def _parse_domain_string(self, domain_str):
        """Parse a domain string into a list."""
        try:
            import ast
            return ast.literal_eval(domain_str)
        except (ValueError, SyntaxError) as e:
            raise ValidationError(_('Invalid domain syntax: %s') % str(e))
    
    def _get_user_discount_limit(self, user, personas, record=None):
        """Get maximum discount percentage for user based on role/persona."""
        max_discount = self.global_discount_limit
        
        # Get context for scope restrictions
        branch_id = getattr(record, 'ops_branch_id', False)
        bu_id = getattr(record, 'ops_business_unit_id', False)
        category_id = False
        if record._name == 'sale.order.line' and hasattr(record, 'product_id'):
            category_id = record.product_id.categ_id.id
        
        # Check persona-based limits
        for persona in personas:
            limit_rules = self.discount_limit_ids.filtered(lambda r: r.persona_id == persona)
            for limit_rule in limit_rules:
                applicable_limit = limit_rule.get_applicable_limit(
                    user,
                    branch_id.id if branch_id else False,
                    bu_id.id if bu_id else False,
                    category_id
                )
                if applicable_limit > 0:
                    max_discount = max(max_discount, applicable_limit)
        
        # Check group-based limits
        for limit_rule in self.discount_limit_ids.filtered(lambda r: r.user_group_id):
            try:
                if user.has_group(limit_rule.user_group_id.xml_id or 'base.group_user'):
                    applicable_limit = limit_rule.get_applicable_limit(
                        user,
                        branch_id.id if branch_id else False,
                        bu_id.id if bu_id else False,
                        category_id
                    )
                    if applicable_limit > 0:
                        max_discount = max(max_discount, applicable_limit)
            except Exception:
                pass
        
        return max_discount
    
    def _calculate_line_margin(self, order_line):
        """Calculate margin percentage for a sale order line."""
        if order_line.price_subtotal == 0:
            return 0.0
        
        # Get product cost
        cost = order_line.product_id.standard_price * order_line.product_uom_qty
        revenue = order_line.price_subtotal
        margin = revenue - cost
        margin_percent = (margin / revenue) * 100 if revenue else 0.0
        
        return margin_percent
    
    def _calculate_order_margin(self, order):
        """Calculate margin percentage for entire order."""
        total_revenue = order.amount_untaxed
        if total_revenue == 0:
            return 0.0
        
        total_cost = sum(
            line.product_id.standard_price * line.product_uom_qty
            for line in order.order_line if line.product_id
        )
        total_margin = total_revenue - total_cost
        margin_percent = (total_margin / total_revenue) * 100
        
        return margin_percent
    
    def _get_minimum_margin(self, category, business_unit, branch):
        """Get minimum margin for product category, BU, and branch."""
        if not category:
            return self.global_minimum_margin
        
        # First try specific rule (category + BU + branch)
        if business_unit and branch:
            margin_rule = self.margin_rule_ids.filtered(
                lambda r: r.product_category_id == category and
                         r.business_unit_id == business_unit and
                         r.branch_id == branch
            )
            if margin_rule:
                return margin_rule[0].minimum_margin_percent
        
        # Try category + BU
        if business_unit:
            margin_rule = self.margin_rule_ids.filtered(
                lambda r: r.product_category_id == category and
                         r.business_unit_id == business_unit and
                         not r.branch_id
            )
            if margin_rule:
                return margin_rule[0].minimum_margin_percent
        
        # Try category + branch
        if branch:
            margin_rule = self.margin_rule_ids.filtered(
                lambda r: r.product_category_id == category and
                         not r.business_unit_id and
                         r.branch_id == branch
            )
            if margin_rule:
                return margin_rule[0].minimum_margin_percent
        
        # Try category only
        margin_rule = self.margin_rule_ids.filtered(
            lambda r: r.product_category_id == category and
                     not r.business_unit_id and
                     not r.branch_id
        )
        if margin_rule:
            return margin_rule[0].minimum_margin_percent
        
        # Fallback to global minimum
        return self.global_minimum_margin
    
    def _get_user_price_variance_limit(self, user, record=None):
        """Get user's price variance authority."""
        max_variance = self.global_max_price_variance
        personas = user.persona_ids if hasattr(user, 'persona_ids') else self.env['ops.persona']
        
        # Get context for scope restrictions
        branch_id = getattr(record, 'ops_branch_id', False)
        bu_id = getattr(record, 'ops_business_unit_id', False)
        category_id = False
        if record and record._name == 'sale.order.line' and hasattr(record, 'product_id'):
            category_id = record.product_id.categ_id.id
        
        # Check persona-based limits
        for persona in personas:
            auth_rules = self.price_authority_ids.filtered(lambda r: r.persona_id == persona)
            for auth_rule in auth_rules:
                authority = auth_rule.get_applicable_authority(
                    user,
                    branch_id.id if branch_id else False,
                    bu_id.id if bu_id else False,
                    category_id
                )
                if authority['max_variance'] > 0:
                    max_variance = max(max_variance, authority['max_variance'])
        
        return max_variance
    
    def action_create_approval_request(self, record, violation_type, violation_details):
        """Create approval request for governance violation."""
        self.ensure_one()
        
        if not self.require_approval:
            return False
        
        # Find approvers based on matrix dimensions
        approvers = self._find_approvers(record, violation_type)
        
        if not approvers:
            _logger.warning(f"No approvers found for rule {self.name}")
            return False
        
        # Create approval request
        approval = self.env['ops.approval.request'].create({
            'name': _("Governance Approval: %s - %s") % (violation_type, record.name or record._name),
            'rule_id': self.id,
            'model_name': record._name,
            'res_id': record.id,
            'notes': violation_details,
            'approver_ids': [(6, 0, approvers.ids)],
            'requested_by': self.env.user.id,
        })
        
        # Send notifications
        if self.notify_users:
            try:
                approval.message_post(
                    body=_("Governance approval requested: %s") % violation_details,
                    partner_ids=approvers.mapped('partner_id').ids,
                )
            except Exception as e:
                _logger.warning(f"Could not send notification: {e}")
        
        return approval
    
    def _find_approvers(self, record, violation_type):
        """Find approvers based on matrix dimensions and violation type."""
        approvers = self.env['res.users']
        
        # Get personas that can approve for this branch/BU
        Persona = self.env['ops.persona']
        domain = [
            ('company_id', '=', record.company_id.id if hasattr(record, 'company_id') else self.env.company.id),
            ('active', '=', True),
        ]
        
        # Add matrix dimension filters
        if hasattr(record, 'ops_branch_id') and record.ops_branch_id:
            domain.append(('branch_ids', 'in', record.ops_branch_id.id))
        
        if hasattr(record, 'ops_business_unit_id') and record.ops_business_unit_id:
            domain.append(('business_unit_ids', 'in', record.ops_business_unit_id.id))
        
        # Add approval authority filters based on violation type
        if violation_type == 'discount':
            domain.append(('can_approve_discounts', '=', True))
        elif violation_type == 'margin':
            domain.append(('can_approve_margin_exceptions', '=', True))
        elif violation_type == 'price':
            domain.append(('can_approve_price_overrides', '=', True))
        elif violation_type == 'matrix':
            domain.append(('can_approve_matrix_exceptions', '=', True))
        
        # Get personas and extract users
        try:
            personas = Persona.search(domain)
            approvers |= personas.mapped('user_id')
        except Exception as e:
            _logger.warning(f"Error finding persona approvers: {e}")
        
        # Also check group-based approvers
        if self.notify_groups:
            group_users = self.env['res.users'].search([
                ('groups_id', 'in', self.notify_groups.ids),
                ('company_id', 'in', [self.company_id.id, False]),
            ])
            approvers |= group_users
        
        # Fallback to approval_user_ids if no approvers found
        if not approvers and self.approval_user_ids:
            approvers = self.approval_user_ids
        
        return approvers
    
    # --- LEGACY METHODS (Backward Compatibility) ---
    
    def _trigger_approval_if_needed(self, record):
        """Check if record matches this rule and trigger approval workflow if needed."""
        self.ensure_one()
        
        # Only process if rule is active
        if not self.active:
            return False
        
        # For new rule types, use validate_record
        if self.rule_type != 'legacy':
            result = self.validate_record(record)
            if not result['valid'] or result['requires_approval']:
                violation_details = '\n'.join(result['errors'] + result['warnings'])
                return self.action_create_approval_request(record, self.rule_type, violation_details)
            return False
        
        # Legacy logic
        if not self._evaluate_legacy_condition(record):
            return False
        
        # Action: Warning (log and continue)
        if self.action_type == 'warning':
            try:
                record.message_post(
                    body=_('<strong>Governance Alert:</strong> %s') % self.error_message,
                    message_type='notification'
                )
            except Exception:
                pass
            return False
        
        # Action: Block (prevent operation)
        if self.action_type == 'block':
            raise ValidationError(_('Governance Rule Blocked: %s') % self.error_message)
        
        # Action: Require Approval
        if self.action_type == 'require_approval':
            approvers = self.approval_user_ids | self.env['res.users'].search([
                ('persona_ids', 'in', self.approval_persona_ids.ids)
            ])
            
            try:
                approval = self.env['ops.approval.request'].create({
                    'name': _('Approval Required: %s') % self.name,
                    'rule_id': self.id,
                    'model_name': record._name,
                    'res_id': record.id,
                    'notes': self.error_message,
                    'approver_ids': [(6, 0, approvers.ids)],
                })
                
                # Lock record if configured
                if self.lock_on_approval_request and hasattr(record, 'active'):
                    try:
                        record.write({'active': False})
                    except Exception:
                        pass
                
                return True
            except Exception as e:
                _logger.error(f"Error creating approval request: {e}")
                return False
        
        return False
    
    @api.model
    def evaluate_rules_for_record(self, record, trigger_type='on_write'):
        """Evaluate all applicable rules for a record."""
        # ADMIN BYPASS: Skip all rule evaluation for Administrator and System Managers
        if self.env.su or self.env.user.has_group('base.group_system'):
            return
        
        rules = self.search([
            ('active', '=', True),
            ('model_id.model', '=', record._name),
            '|',
            ('trigger_type', '=', trigger_type),
            ('trigger_condition', '=', 'always')
        ], order='sequence ASC')
        
        for rule in rules:
            rule._trigger_approval_if_needed(record)
    
    # --- COMPUTED METHODS ---
    
    @api.depends('rule_type', 'enforce_branch_bu', 'enforce_discount_limit', 
                 'enforce_margin_protection', 'enforce_price_override')
    def _compute_description(self):
        """Generate rule description based on configuration."""
        for rule in self:
            parts = []
            
            if rule.enforce_branch_bu:
                parts.append(_("Enforces Branch/BU selection"))
            
            if rule.enforce_discount_limit:
                parts.append(_("Discount limit: %.2f%%") % rule.global_discount_limit)
            
            if rule.enforce_margin_protection:
                parts.append(_("Minimum margin: %.2f%%") % rule.global_minimum_margin)
            
            if rule.enforce_price_override:
                parts.append(_("Max price variance: %.2f%%") % rule.global_max_price_variance)
            
            if rule.require_approval:
                parts.append(_("Requires approval"))
            
            rule.description = " | ".join(parts) if parts else _("No validations configured")
    
    def _compute_violation_count(self):
        """Count violations for this rule."""
        for rule in self:
            rule.violation_count = self.env['ops.approval.request'].search_count([
                ('rule_id', '=', rule.id),
                ('state', 'in', ['pending', 'approved', 'rejected']),
            ])
    
    def _compute_approval_count(self):
        """Count active approval requests."""
        for rule in self:
            rule.active_approval_count = self.env['ops.approval.request'].search_count([
                ('rule_id', '=', rule.id),
                ('state', '=', 'pending'),
            ])
    
    def action_check_compliance(self):
        """Manual compliance check action - shows statistics for this rule."""
        self.ensure_one()
        
        # Refresh computed fields
        self._compute_violation_count()
        self._compute_approval_count()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Compliance Check'),
                'message': _(
                    'Rule: %s\n'
                    'Active: %s\n'
                    'Total Violations: %d\n'
                    'Pending Approvals: %d'
                ) % (
                    self.name,
                    _('Yes') if self.active else _('No'),
                    self.violation_count,
                    self.active_approval_count
                ),
                'type': 'info',
                'sticky': False,
            }
        }
    
    @api.model_create_multi
    def create(self, vals_list):
        """Generate code if not provided."""
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.governance.rule') or 'GR0001'
        return super().create(vals_list)

>>> ops_matrix_core/models/ops_approval_request.py <<<
from odoo import models, fields, api, Command, _
from typing import List, Dict, Any
import logging

_logger = logging.getLogger(__name__)


class OpsApprovalRequest(models.Model):
    _name = 'ops.approval.request'
    _description = 'Approval Request with Matrix Dimensions'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'create_date desc'

    name = fields.Char(
        string='Reference',
        required=True,
        readonly=True,
        default='New',
        tracking=True,
        help='Unique reference number for this approval request. '
             'Auto-generated on save (format: APP/XXXX). '
             'Used for: Tracking approvals, audit trails, communication with approvers. '
             'Example: APP/0001, APP/0025. '
             'Cannot be changed after creation.'
    )
    rule_id = fields.Many2one(
        'ops.governance.rule',
        string='Rule',
        required=True,
        tracking=True,
        help='The governance rule that triggered this approval request. '
             'The rule defines: validation criteria, approvers, severity, actions. '
             'Click to view rule configuration and understand why approval is needed. '
             'Examples: "Discount Limit Rule", "Margin Protection - Electronics", "High Value Approval". '
             'Related: View rule details to see thresholds and authorized approvers.'
    )
    model_name = fields.Char(string='Model Name', required=True)
    res_id = fields.Integer(string='Record ID', required=True)
    record_ref = fields.Char(string='Record Reference', compute='_compute_record_ref', store=True)
    res_name = fields.Char(string='Record Name', compute='_compute_res_name', store=True)
    notes = fields.Text(
        string='Notes',
        help='Explanation of why this approval is needed and context for approvers. '
             'Include: Reason for exception, business justification, customer context, urgency. '
             'Examples: '
             '- "Customer is major account, discount requested to secure $500K annual contract" '
             '- "Market pricing requires 20% discount to match competitors" '
             '- "Low margin justified by high volume order (1000 units)". '
             'Best Practice: Provide enough detail for approvers to make informed decisions. '
             'Visible to: All approvers and requestor.'
    )
    response_notes = fields.Text(
        string='Response Notes',
        help='Approver\'s explanation of their decision (approval or rejection). '
             'Required when rejecting, optional when approving. '
             'Include: Reason for decision, conditions if any, guidance for future. '
             'Examples: '
             '- "Approved - customer is strategic account" '
             '- "Rejected - margin too low, no business justification provided" '
             '- "Approved conditionally - monitor for repeat requests". '
             'Visible to: Requestor and all users with approval access.'
    )
    
    # Tracking fields
    requested_by = fields.Many2one('res.users', string='Requested By', default=lambda self: self.env.user, required=True, tracking=True)
    requested_date = fields.Datetime(string='Requested Date', default=fields.Datetime.now, required=True)
    approved_by = fields.Many2one('res.users', string='Approved By', readonly=True, tracking=True)
    approved_date = fields.Datetime(string='Approved Date', readonly=True)

    @api.depends('model_name', 'res_id')
    def _compute_record_ref(self):
        """Compute record reference string."""
        for request in self:
            if request.model_name and request.res_id:
                request.record_ref = f"{request.model_name},{request.res_id}"
            else:
                request.record_ref = False

    @api.depends('model_name', 'res_id')
    def _compute_res_name(self):
        """Compute display name of the related record."""
        for request in self:
            if request.model_name and request.res_id:
                try:
                    record = request.env[request.model_name].browse(request.res_id)
                    if record.exists():
                        request.res_name = record.display_name
                    else:
                        request.res_name = f"{request.model_name}#{request.res_id} (Deleted)"
                except Exception:
                    request.res_name = f"{request.model_name}#{request.res_id}"
            else:
                request.res_name = False
    
    # Matrix Dimensions (inherited from source record)
    branch_id = fields.Many2one('ops.branch', string='Branch', tracking=True)
    business_unit_id = fields.Many2one('ops.business.unit', string='Business Unit', tracking=True)
    
    # --- MATRIX DIMENSION FIELDS (ENHANCED) ---
    ops_company_id = fields.Many2one('res.company', string='Company',
                                     compute='_compute_matrix_dimensions', store=True)
    
    ops_branch_id = fields.Many2one('ops.branch', string='OPS Branch',
                                    compute='_compute_matrix_dimensions', store=True)
    
    ops_business_unit_id = fields.Many2one('ops.business.unit', string='OPS Business Unit',
                                           compute='_compute_matrix_dimensions', store=True)
    
    # --- GOVERNANCE VIOLATION DETAILS ---
    violation_type = fields.Selection([
        ('matrix', 'Matrix Validation'),
        ('discount', 'Discount Limit'),
        ('margin', 'Margin Protection'),
        ('price', 'Price Override'),
        ('other', 'Other'),
    ], string='Violation Type',
       tracking=True,
       help='Category of governance rule violation that triggered this approval. '
            'Matrix Validation: Missing or invalid branch/BU selection. '
            'Discount Limit: Discount exceeds authorized limit. '
            'Margin Protection: Profit margin below minimum threshold. '
            'Price Override: Price change exceeds authorized variance. '
            'Other: Custom rule violations. '
            'This determines which approvers are notified and what data is displayed.')
    
    violation_details = fields.Text(
        string='Violation Details',
        help='Detailed explanation of what governance rule was violated and how. '
             'Auto-generated by the system based on the violation type. '
             'Examples: '
             '- "Discount 15% exceeds your limit of 10%" '
             '- "Margin 8% below minimum 12% for Electronics category" '
             '- "Branch selection required but not provided". '
             'Provides context for approvers to understand the issue. '
             'Read-only, populated automatically by governance engine.'
    )
    
    # --- QUANTITATIVE VIOLATION DATA ---
    discount_percent = fields.Float(string='Discount %', digits=(5, 2))
    margin_percent = fields.Float(string='Margin %', digits=(5, 2))
    price_variance_percent = fields.Float(string='Price Variance %', digits=(5, 2))
    
    allowed_limit = fields.Float(string='Allowed Limit', digits=(5, 2),
                                help='What was the allowed limit')
    
    actual_value = fields.Float(string='Actual Value', digits=(5, 2),
                               help='What was the actual value')
    
    # --- APPROVAL CONTEXT ---
    is_governance_violation = fields.Boolean(string='Governance Violation',
                                            compute='_compute_is_governance_violation', store=True)
    
    violation_severity = fields.Selection([
        ('low', 'Low - Informational'),
        ('medium', 'Medium - Requires Attention'),
        ('high', 'High - Requires Approval'),
        ('critical', 'Critical - Blocking'),
    ], string='Violation Severity',
       default='medium',
       tracking=True,
       help='Severity level of this governance violation. '
            'Low: Informational only, no action blocked. '
            'Medium: Requires review but transaction can proceed. '
            'High: Requires approval before transaction can complete. '
            'Critical: Transaction completely blocked until approved. '
            'Severity affects: Notification urgency, approver priority, system behavior. '
            'Default: Medium (requires attention but not blocking).')
    
    # --- COMPUTED FIELDS ---
    matrix_summary = fields.Char(string='Matrix Summary',
                                compute='_compute_matrix_summary', store=True)
    
    violation_summary = fields.Char(string='Violation Summary',
                                   compute='_compute_violation_summary', store=True)
    
    # --- COMPUTED METHODS ---
    
    @api.depends('record_ref')
    def _compute_matrix_dimensions(self):
        """Extract matrix dimensions from referenced record."""
        for approval in self:
            if approval.record_ref:
                try:
                    model_name, record_id = approval.record_ref.split(',')
                    record = self.env[model_name].browse(int(record_id))
                    
                    if record.exists():
                        if hasattr(record, 'company_id'):
                            approval.ops_company_id = record.company_id
                        
                        if hasattr(record, 'ops_branch_id'):
                            approval.ops_branch_id = record.ops_branch_id
                        elif hasattr(record, 'branch_id'):
                            approval.ops_branch_id = record.branch_id
                        
                        if hasattr(record, 'ops_business_unit_id'):
                            approval.ops_business_unit_id = record.ops_business_unit_id
                        elif hasattr(record, 'business_unit_id'):
                            approval.ops_business_unit_id = record.business_unit_id
                except Exception as e:
                    _logger.debug(f"Error computing matrix dimensions: {e}")
                    approval.ops_company_id = False
                    approval.ops_branch_id = False
                    approval.ops_business_unit_id = False
            else:
                approval.ops_company_id = False
                approval.ops_branch_id = False
                approval.ops_business_unit_id = False
    
    @api.depends('rule_id', 'violation_type')
    def _compute_is_governance_violation(self):
        for approval in self:
            approval.is_governance_violation = bool(approval.rule_id or approval.violation_type)
    
    @api.depends('ops_branch_id', 'ops_business_unit_id')
    def _compute_matrix_summary(self):
        for approval in self:
            parts = []
            if approval.ops_branch_id:
                parts.append(f"Branch: {approval.ops_branch_id.code or approval.ops_branch_id.name}")
            if approval.ops_business_unit_id:
                parts.append(f"BU: {approval.ops_business_unit_id.code or approval.ops_business_unit_id.name}")
            approval.matrix_summary = " | ".join(parts) if parts else "No matrix"
    
    @api.depends('violation_type', 'discount_percent', 'margin_percent', 'price_variance_percent', 'allowed_limit', 'actual_value')
    def _compute_violation_summary(self):
        for approval in self:
            if approval.violation_type == 'discount' and approval.discount_percent:
                approval.violation_summary = f"Discount: {approval.discount_percent:.2f}% (Limit: {approval.allowed_limit:.2f}%)"
            elif approval.violation_type == 'margin' and approval.margin_percent:
                approval.violation_summary = f"Margin: {approval.margin_percent:.2f}% (Min: {approval.allowed_limit:.2f}%)"
            elif approval.violation_type == 'price' and approval.price_variance_percent:
                approval.violation_summary = f"Price Variance: {approval.price_variance_percent:.2f}% (Max: {approval.allowed_limit:.2f}%)"
            elif approval.violation_type == 'matrix':
                approval.violation_summary = f"Matrix Validation: {approval.violation_details or 'Missing dimension'}"
            else:
                approval.violation_summary = approval.violation_details or "No violation details"
    
    state = fields.Selection([
        ('pending', 'Pending'),
        ('approved', 'Approved'),
        ('rejected', 'Rejected'),
        ('cancelled', 'Cancelled')
    ], string='Status',
       default='pending',
       tracking=True,
       help='Current status of this approval request. '
            'Pending: Waiting for approver action. '
            'Approved: Request granted, transaction can proceed. '
            'Rejected: Request denied, transaction blocked or cancelled. '
            'Cancelled: Request withdrawn by requestor or system. '
            'State Changes: Pending → Approved/Rejected/Cancelled. '
            'Email notifications sent to requestor on status change.')

    approver_ids = fields.Many2many(
        'res.users',
        'ops_approval_request_user_rel',
        'request_id',
        'user_id',
        string='Approvers',
        tracking=True,
        help='Users authorized to approve or reject this request. '
             'Automatically determined based on: Governance rule configuration, matrix dimensions (branch/BU), violation type. '
             'Selection logic: '
             '- System finds personas with approval authority for the branch/BU '
             '- Filters by violation type (discount/margin/price approvers) '
             '- Falls back to rule-defined approvers if no matches. '
             'Any listed approver can approve/reject. '
             'Notification: All approvers are notified when request is created.'
    )
    
    # Workflow fields
    workflow_id = fields.Many2one('ops.approval.workflow', string='Workflow', related='rule_id.approval_workflow_id', store=True)
    priority = fields.Selection([
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('urgent', 'Urgent'),
    ], string='Priority',
       default='medium',
       tracking=True,
       help='Urgency level for this approval request. '
            'Low: Review within 5 business days. '
            'Medium: Review within 2 business days (default). '
            'High: Review within 1 business day. '
            'Urgent: Review immediately (same day). '
            'Affects: Notification frequency, dashboard placement, SLA tracking. '
            'Set urgency based on: Customer waiting, order deadline, business impact. '
            'Urgent requests appear at top of approver dashboard.')
    
    # --- BUSINESS METHODS ---
    
    def action_view_source_record(self):
        """Open the source record that triggered this approval."""
        self.ensure_one()
        if not self.record_ref:
            return None
        
        try:
            model_name, record_id = self.record_ref.split(',')
            return {
                'type': 'ir.actions.act_window',
                'name': self.name,
                'res_model': model_name,
                'res_id': int(record_id),
                'view_mode': 'form',
                'target': 'current',
            }
        except Exception as e:
            _logger.error(f"Error opening source record: {e}")
            return None
    
    def action_view_rule(self):
        """Open the governance rule that triggered this approval."""
        self.ensure_one()
        if not self.rule_id:
            return None
        
        return {
            'type': 'ir.actions.act_window',
            'name': self.rule_id.name,
            'res_model': 'ops.governance.rule',
            'res_id': self.rule_id.id,
            'view_mode': 'form',
            'target': 'current',
        }
    
    def _find_governance_approvers(self):
        """Find approvers for governance violations based on matrix dimensions."""
        self.ensure_one()
        
        if not self.rule_id:
            return self.env['res.users']
        
        # Use rule's approver finding logic
        if self.record_ref:
            try:
                model_name, record_id = self.record_ref.split(',')
                record = self.env[model_name].browse(int(record_id))
                if record.exists():
                    return self.rule_id._find_approvers(record, self.violation_type or 'other')
            except Exception as e:
                _logger.error(f"Error finding governance approvers: {e}")
        
        return self.env['res.users']

    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsApprovalRequest':
        """Auto-set governance approvers and inherit matrix dimensions from source record."""
        for vals in vals_list:
            # Generate sequence if needed
            if vals.get('name', 'New') == 'New':
                vals['name'] = self.env['ir.sequence'].next_by_code('ops.approval.request') or 'APP/0001'
            
            # Inherit matrix dimensions from source record
            if vals.get('model_name') and vals.get('res_id'):
                try:
                    record = self.env[vals['model_name']].browse(vals['res_id'])
                    if record.exists():
                        # Legacy fields (backward compatibility)
                        if hasattr(record, 'branch_id') and 'branch_id' not in vals:
                            vals['branch_id'] = record.branch_id.id if record.branch_id else False
                        if hasattr(record, 'business_unit_id') and 'business_unit_id' not in vals:
                            vals['business_unit_id'] = record.business_unit_id.id if record.business_unit_id else False
                except Exception as e:
                    _logger.debug(f"Could not inherit matrix dimensions: {e}")
        
        records = super().create(vals_list)
        
        # Set approvers for governance violations
        for record in records:
            if record.is_governance_violation and not record.approver_ids:
                # Find governance-specific approvers
                approvers = record._find_governance_approvers()
                if approvers:
                    record.approver_ids = [(6, 0, approvers.ids)]
        
        return records
    
    def write(self, vals):
        """Track approval/rejection of governance violations."""
        result = super().write(vals)
        
        # If approved/rejected, update source record if it's a governance violation
        if 'state' in vals and vals['state'] in ['approved', 'rejected']:
            for record in self:
                if record.is_governance_violation:
                    record._update_source_record_approval(vals['state'])
        
        return result
    
    def _update_source_record_approval(self, approval_state):
        """Update source record with approval status."""
        for approval in self:
            if not approval.record_ref:
                continue
            
            try:
                model_name, record_id = approval.record_ref.split(',')
                record = self.env[model_name].browse(int(record_id))
                
                if record.exists():
                    # Add approval note to record
                    approval_note = _("Governance approval %s: %s") % (approval_state, approval.name)
                    
                    if hasattr(record, 'message_post'):
                        record.message_post(body=approval_note)
                    
                    # Set approval status field if it exists
                    if hasattr(record, 'governance_approval_status'):
                        record.governance_approval_status = approval_state
                    if hasattr(record, 'governance_approval_id'):
                        record.governance_approval_id = approval.id
            
            except Exception as e:
                _logger.error(f"Error updating source record: {e}")

    def action_approve(self) -> bool:
        """Approve the request."""
        self.ensure_one()
        if self.state != 'pending':
            return False
            
        self.write({
            'state': 'approved',
            'approved_by': self.env.user.id,
            'approved_date': fields.Datetime.now(),
        })
        
        # Unlock the record if it was locked
        if self.model_name and self.res_id:
            try:
                record = self.env[self.model_name].browse(self.res_id)
                if record.exists() and hasattr(record, 'approval_locked'):
                    record.write({'approval_locked': False})
            except Exception as e:
                _logger.debug(f"Could not unlock record: {e}")
        
        # Send notification
        try:
            self.message_post(
                body=_("Approval granted by %s") % self.env.user.name,
                message_type='notification'
            )
        except Exception:
            pass
        
        return True

    def action_reject(self) -> bool:
        """Reject the request."""
        self.ensure_one()
        if self.state != 'pending':
            return False
            
        self.write({
            'state': 'rejected',
            'approved_by': self.env.user.id,
            'approved_date': fields.Datetime.now(),
        })
        
        # Unlock the record if it was locked
        if self.model_name and self.res_id:
            try:
                record = self.env[self.model_name].browse(self.res_id)
                if record.exists() and hasattr(record, 'approval_locked'):
                    record.write({'approval_locked': False})
            except Exception as e:
                _logger.debug(f"Could not unlock record: {e}")
        
        # Send notification
        try:
            self.message_post(
                body=_("Approval rejected by %s. Reason: %s") % (self.env.user.name, self.response_notes or 'No reason given'),
                message_type='notification'
            )
        except Exception:
            pass
        
        return True

    def action_cancel(self) -> bool:
        """Cancel the request."""
        self.ensure_one()
        if self.state != 'pending':
            return False
            
        self.write({'state': 'cancelled'})
        
        # Unlock the record if it was locked
        if self.model_name and self.res_id:
            try:
                record = self.env[self.model_name].browse(self.res_id)
                if record.exists() and hasattr(record, 'approval_locked'):
                    record.write({'approval_locked': False})
            except Exception as e:
                _logger.debug(f"Could not unlock record: {e}")
        
        return True

>>> ops_matrix_core/models/ops_audit_log.py <<<
# -*- coding: utf-8 -*-

"""
OPS Matrix API Audit Log
Comprehensive audit logging for all API requests
"""

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)


class OpsAuditLog(models.Model):
    """
    API Audit Log Model for OPS Matrix Framework
    
    Records all API requests for security auditing, compliance, and debugging.
    This is a read-only model from the UI perspective - logs are created by
    the API controller automatically.
    """
    _name = 'ops.audit.log'
    _description = 'OPS Matrix API Audit Log'
    _order = 'timestamp desc'
    _rec_name = 'endpoint'
    
    # Disable standard tracking
    _log_access = True
    
    # ========================================================================
    # FIELDS
    # ========================================================================
    
    timestamp = fields.Datetime(
        string='Timestamp',
        required=True,
        default=fields.Datetime.now,
        index=True,  # Index for performance on time-based queries
        readonly=True,
        help='When the API request was made'
    )
    
    api_key_id = fields.Many2one(
        'ops.api.key',
        string='API Key',
        ondelete='set null',
        index=True,
        readonly=True,
        help='The API key used for this request'
    )
    
    persona_id = fields.Many2one(
        'ops.persona',
        string='Persona',
        ondelete='set null',
        index=True,
        readonly=True,
        help='The persona associated with the API key'
    )
    
    endpoint = fields.Char(
        string='API Endpoint',
        required=True,
        index=True,
        readonly=True,
        help='The API endpoint URL that was called'
    )
    
    http_method = fields.Selection(
        [
            ('GET', 'GET'),
            ('POST', 'POST'),
            ('PUT', 'PUT'),
            ('DELETE', 'DELETE'),
            ('PATCH', 'PATCH'),
            ('OPTIONS', 'OPTIONS'),
            ('HEAD', 'HEAD')
        ],
        string='HTTP Method',
        required=True,
        readonly=True,
        index=True,
        help='HTTP method used for the request'
    )
    
    ip_address = fields.Char(
        string='IP Address',
        readonly=True,
        index=True,
        help='Client IP address that made the request'
    )
    
    user_agent = fields.Text(
        string='User Agent',
        readonly=True,
        help='Client user agent string'
    )
    
    status_code = fields.Integer(
        string='HTTP Status Code',
        readonly=True,
        index=True,
        help='HTTP response status code (200, 401, 500, etc.)'
    )
    
    response_time = fields.Float(
        string='Response Time (seconds)',
        readonly=True,
        digits=(10, 4),
        help='Time taken to process the request in seconds'
    )
    
    error_message = fields.Text(
        string='Error Message',
        readonly=True,
        help='Error message if the request failed'
    )
    
    # Additional context
    request_params = fields.Text(
        string='Request Parameters',
        readonly=True,
        help='Query parameters or request body (sanitized)'
    )
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        readonly=True,
        index=True,
        help='Company context at time of request'
    )
    
    # Computed fields for analytics
    success = fields.Boolean(
        string='Success',
        compute='_compute_success',
        store=True,
        readonly=True,
        help='Whether the request was successful (status code 200-299)'
    )
    
    date = fields.Date(
        string='Date',
        compute='_compute_date',
        store=True,
        index=True,
        readonly=True,
        help='Date of the request (for daily analytics)'
    )
    
    # ========================================================================
    # COMPUTE METHODS
    # ========================================================================
    
    @api.depends('status_code')
    def _compute_success(self):
        """
        Determine if request was successful based on status code
        2xx status codes are considered successful
        """
        for record in self:
            record.success = 200 <= (record.status_code or 0) < 300
    
    @api.depends('timestamp')
    def _compute_date(self):
        """
        Extract date from timestamp for easier daily analytics
        """
        for record in self:
            record.date = record.timestamp.date() if record.timestamp else False
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    
    _sql_constraints = [
        ('check_status_code', 'CHECK(status_code >= 100 AND status_code < 600)', 
         'Invalid HTTP status code!'),
        ('check_response_time', 'CHECK(response_time >= 0)', 
         'Response time cannot be negative!')
    ]
    
    # ========================================================================
    # ORM METHODS
    # ========================================================================
    
    @api.model
    def create(self, vals):
        """
        Override create to ensure audit log integrity
        """
        # Always mark as readonly after creation
        record = super(OpsAuditLog, self).create(vals)
        
        _logger.debug(
            f"Audit log created: {record.endpoint} [{record.http_method}] "
            f"Status: {record.status_code} IP: {record.ip_address}"
        )
        
        return record
    
    def write(self, vals):
        """
        Prevent modification of audit logs (integrity requirement)
        """
        if self.env.user.has_group('base.group_system'):
            # Only allow system admin to modify (for data correction if needed)
            _logger.warning(
                f"Audit log modified by system admin {self.env.user.name}: "
                f"IDs {self.ids}"
            )
            return super(OpsAuditLog, self).write(vals)
        else:
            raise UserError(_('Audit logs cannot be modified to maintain integrity.'))
    
    def unlink(self):
        """
        Prevent deletion of audit logs (except by system admin)
        """
        if self.env.user.has_group('base.group_system'):
            _logger.warning(
                f"Audit logs deleted by system admin {self.env.user.name}: "
                f"IDs {self.ids}"
            )
            return super(OpsAuditLog, self).unlink()
        else:
            raise UserError(_('Audit logs cannot be deleted to maintain integrity.'))
    
    # ========================================================================
    # BUSINESS METHODS
    # ========================================================================
    
    @api.model
    def log_api_request(self, api_key_id=None, endpoint=None, http_method=None,
                       ip_address=None, user_agent=None, status_code=None,
                       response_time=None, error_message=None, request_params=None):
        """
        Create an audit log entry for an API request
        
        This is the main method called by the API controller to log requests.
        
        Args:
            api_key_id (int): ID of the API key used
            endpoint (str): API endpoint URL
            http_method (str): HTTP method (GET, POST, etc.)
            ip_address (str): Client IP address
            user_agent (str): Client user agent
            status_code (int): HTTP response status code
            response_time (float): Request processing time in seconds
            error_message (str): Error message if any
            request_params (str): Request parameters (sanitized)
            
        Returns:
            ops.audit.log: Created audit log record
        """
        vals = {
            'timestamp': fields.Datetime.now(),
            'endpoint': endpoint,
            'http_method': http_method,
            'ip_address': ip_address,
            'user_agent': user_agent,
            'status_code': status_code,
            'response_time': response_time,
            'error_message': error_message,
            'request_params': request_params,
        }
        
        # Add API key and persona if provided
        if api_key_id:
            vals['api_key_id'] = api_key_id
            api_key = self.env['ops.api.key'].sudo().browse(api_key_id)
            if api_key.exists():
                vals['persona_id'] = api_key.persona_id.id
                vals['company_id'] = api_key.company_id.id
        
        # Create log entry using sudo to bypass permissions
        return self.sudo().create(vals)
    
    @api.model
    def cleanup_old_logs(self, days=90):
        """
        Clean up audit logs older than specified days
        
        This should be called by a scheduled action (cron job)
        
        Args:
            days (int): Number of days to retain logs (default 90)
            
        Returns:
            int: Number of logs deleted
        """
        cutoff_date = fields.Datetime.now() - fields.Datetime.to_datetime(f'{days} days')
        
        old_logs = self.sudo().search([('timestamp', '<', cutoff_date)])
        count = len(old_logs)
        
        if count > 0:
            _logger.info(f"Cleaning up {count} audit logs older than {days} days")
            old_logs.unlink()
        
        return count
    
    # ========================================================================
    # ANALYTICS METHODS
    # ========================================================================
    
    @api.model
    def get_api_usage_stats(self, date_from=None, date_to=None):
        """
        Get API usage statistics for a date range
        
        Args:
            date_from (date): Start date
            date_to (date): End date
            
        Returns:
            dict: Usage statistics
        """
        domain = []
        
        if date_from:
            domain.append(('date', '>=', date_from))
        if date_to:
            domain.append(('date', '<=', date_to))
        
        logs = self.search(domain)
        
        if not logs:
            return {
                'total_requests': 0,
                'successful_requests': 0,
                'failed_requests': 0,
                'avg_response_time': 0.0,
                'unique_api_keys': 0,
                'by_endpoint': {},
                'by_status_code': {}
            }
        
        # Calculate statistics
        total = len(logs)
        successful = len(logs.filtered(lambda l: l.success))
        failed = total - successful
        
        # Average response time
        response_times = logs.filtered(lambda l: l.response_time).mapped('response_time')
        avg_response_time = sum(response_times) / len(response_times) if response_times else 0.0
        
        # Unique API keys
        unique_keys = len(logs.mapped('api_key_id'))
        
        # Group by endpoint
        by_endpoint = {}
        for log in logs:
            endpoint = log.endpoint or 'Unknown'
            if endpoint not in by_endpoint:
                by_endpoint[endpoint] = 0
            by_endpoint[endpoint] += 1
        
        # Group by status code
        by_status_code = {}
        for log in logs:
            status = log.status_code or 0
            if status not in by_status_code:
                by_status_code[status] = 0
            by_status_code[status] += 1
        
        return {
            'total_requests': total,
            'successful_requests': successful,
            'failed_requests': failed,
            'success_rate': (successful / total * 100) if total > 0 else 0,
            'avg_response_time': round(avg_response_time, 4),
            'unique_api_keys': unique_keys,
            'by_endpoint': by_endpoint,
            'by_status_code': by_status_code
        }
    
    def action_view_api_key(self):
        """
        Navigate to the API key record
        """
        self.ensure_one()
        
        if not self.api_key_id:
            raise UserError(_('No API key associated with this log entry.'))
        
        return {
            'name': _('API Key'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.api.key',
            'res_id': self.api_key_id.id,
            'view_mode': 'form',
            'target': 'current'
        }

>>> ops_matrix_core/models/account_move.py (if exists) <<<
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
import logging

_logger = logging.getLogger(__name__)

class AccountMove(models.Model):
    _inherit = ['account.move', 'ops.matrix.mixin']
    _name = 'account.move'
    
    # The following fields are inherited from ops.matrix.mixin:
    # - ops_branch_id (Many2one to res.company - will be ops.branch)
    # - ops_business_unit_id (Many2one to ops.business.unit)
    # - ops_company_id (computed Many2one to res.company)
    # - ops_analytic_distribution (computed Json field)
    
    # ========================================================================
    # ADDITIONAL FIELDS
    # ========================================================================
    
    ops_source_order_id = fields.Reference(
        [('sale.order', 'Sale Order'), ('purchase.order', 'Purchase Order')],
        string='Source Order',
        help='Original order that generated this invoice/bill',
        readonly=True
    )
    
    ops_analytic_summary = fields.Char(
        compute='_compute_analytic_summary',
        string='Analytic Summary',
        store=True,
        help='Summary of Branch and Business Unit dimensions'
    )
    
    # Anti-Fraud Security: Button-level authority for invoice posting
    can_user_validate_invoices = fields.Boolean(
        compute='_compute_can_user_validate_invoices',
        string='Can Validate Invoices',
        help='Technical field: User has authority to post/validate invoices'
    )
    
    # ========================================================================
    # COMPUTE METHODS
    # ========================================================================
    
    @api.depends_context('uid')
    def _compute_can_user_validate_invoices(self):
        """
        Check if current user has authority to validate invoices.
        
        ADMIN BYPASS: System administrators always have access.
        PERSONA LOGIC: Uses additive authority - if ANY persona grants the right, access is granted.
        """
        for record in self:
            # Admin bypass
            if self.env.su or self.env.user.has_group('base.group_system'):
                record.can_user_validate_invoices = True
            else:
                # Check persona authority using the helper method
                record.can_user_validate_invoices = self.env.user.has_ops_authority('can_validate_invoices')
    
    @api.depends('ops_branch_id', 'ops_business_unit_id')
    def _compute_analytic_summary(self):
        """Compute human-readable summary of matrix dimensions."""
        for move in self:
            parts = []
            if move.ops_branch_id:
                branch_code = move.ops_branch_id.code if hasattr(move.ops_branch_id, 'code') else move.ops_branch_id.name
                parts.append(_("Branch: %s") % branch_code)
            if move.ops_business_unit_id:
                bu_code = move.ops_business_unit_id.code if hasattr(move.ops_business_unit_id, 'code') else move.ops_business_unit_id.name
                parts.append(_("BU: %s") % bu_code)
            
            move.ops_analytic_summary = " | ".join(parts) if parts else _("No dimensions")
    
    # ========================================================================
    # CRUD METHODS
    # ========================================================================
    
    @api.model_create_multi
    def create(self, vals_list):
        """Auto-assign analytic distribution from matrix dimensions when creating moves."""
        # First, propagate dimensions from source orders
        for vals in vals_list:
            self._propagate_matrix_dimensions(vals)
        
        # Create the records
        moves = super().create(vals_list)
        
        # Then update analytic distribution for each move
        for move in moves:
            # Only update if we have branch or BU (may have been set via defaults)
            if move.ops_branch_id or move.ops_business_unit_id:
                # Compute distribution based on current values
                distribution = move._compute_analytic_distribution_values()
                
                # Apply to all move lines
                if distribution and move.line_ids:
                    for line in move.line_ids:
                        # Only update if line doesn't already have analytic distribution
                        if not line.analytic_distribution:
                            line.analytic_distribution = distribution
        
        return moves
    
    def write(self, vals):
        """Update analytic distribution when matrix dimensions change."""
        # Capture old values for branch and BU before write
        old_branch_values = {move.id: move.ops_branch_id for move in self}
        old_bu_values = {move.id: move.ops_business_unit_id for move in self}
        
        # Perform the write
        result = super().write(vals)
        
        # Check if we need to update analytic distribution
        update_moves = self.filtered(lambda m: (
            (m.id in old_branch_values and m.ops_branch_id != old_branch_values[m.id]) or
            (m.id in old_bu_values and m.ops_business_unit_id != old_bu_values[m.id])
        ))
        
        if update_moves:
            for move in update_moves:
                # Only update draft or posted moves (based on business rules)
                if move.state in ('draft', 'posted'):
                    distribution = move._compute_analytic_distribution_values()
                    
                    if distribution:
                        # Update lines that don't have manual analytic assignments
                        for line in move.line_ids.filtered(lambda l: not l.analytic_distribution):
                            line.analytic_distribution = distribution
                    
                    # Log the change for audit trail
                    move.message_post(
                        body=_('Matrix dimensions updated: Branch=%s, BU=%s') % (
                            move.ops_branch_id.name if move.ops_branch_id else 'None',
                            move.ops_business_unit_id.name if move.ops_business_unit_id else 'None'
                        )
                    )
        
        return result
    
    # ========================================================================
    # ONCHANGE METHODS
    # ========================================================================
    
    @api.onchange('ops_branch_id')
    def _onchange_ops_branch_id(self):
        """Filter available BUs when branch changes and update analytic distribution."""
        if self.ops_branch_id:
            # Filter available BUs
            available_bus = self.env['ops.business.unit'].search([
                ('branch_ids', 'in', self.ops_branch_id.id),
                ('active', '=', True)
            ])
            
            # Reset BU if incompatible
            if self.ops_business_unit_id and self.ops_business_unit_id not in available_bus:
                self.ops_business_unit_id = False
            
            # Update analytic distribution on lines
            if self.line_ids:
                distribution = self._compute_analytic_distribution_values()
                for line in self.line_ids.filtered(lambda l: not l.analytic_distribution):
                    line.analytic_distribution = distribution
            
            return {
                'domain': {
                    'ops_business_unit_id': [('id', 'in', available_bus.ids)]
                }
            }
        return {}
    
    @api.onchange('ops_business_unit_id')
    def _onchange_ops_business_unit_id(self):
        """Update analytic distribution when BU changes."""
        if self.line_ids:
            distribution = self._compute_analytic_distribution_values()
            for line in self.line_ids.filtered(lambda l: not l.analytic_distribution):
                line.analytic_distribution = distribution
    
    # ========================================================================
    # VALIDATION CONSTRAINTS
    # ========================================================================
    
    @api.constrains('ops_branch_id', 'ops_business_unit_id')
    def _check_matrix_dimensions(self):
        """Ensure required dimensions are present for invoices."""
        for move in self:
            # Only validate for invoice types
            if move.move_type in ('out_invoice', 'in_invoice', 'out_refund', 'in_refund'):
                if not move.ops_branch_id:
                    raise ValidationError(_(
                        "Branch is required for %s '%s'. Please select a branch before confirming."
                    ) % (move.move_type, move.name))
                
                if not move.ops_business_unit_id:
                    raise ValidationError(_(
                        "Business Unit is required for %s '%s'. Please select a business unit before confirming."
                    ) % (move.move_type, move.name))
                
                # Also validate that BU operates in the selected branch
                if (move.ops_branch_id and move.ops_business_unit_id and 
                    move.ops_branch_id not in move.ops_business_unit_id.branch_ids):
                    raise ValidationError(_(
                        "Business Unit '%(bu_name)s' does not operate in Branch '%(branch_name)s'. "
                        "Please select a compatible combination."
                    ) % {
                        'bu_name': move.ops_business_unit_id.name,
                        'branch_name': move.ops_branch_id.name
                    })
    
    # ========================================================================
    # ACTION METHODS
    # ========================================================================
    
    def action_post(self):
        """Override post action to validate matrix dimensions before posting."""
        # Validate dimensions for invoices
        invoice_moves = self.filtered(lambda m: m.is_invoice(include_receipts=True))
        for move in invoice_moves:
            if not move.ops_branch_id:
                raise ValidationError(_(
                    "Cannot post invoice %s without a Branch. Please select a branch."
                ) % move.name)
            
            if not move.ops_business_unit_id:
                raise ValidationError(_(
                    "Cannot post invoice %s without a Business Unit. Please select a business unit."
                ) % move.name)
        
        # Ensure analytic distribution is set on lines
        for move in self:
            if move.ops_branch_id or move.ops_business_unit_id:
                distribution = move._compute_analytic_distribution_values()
                if distribution:
                    for line in move.line_ids.filtered(lambda l: not l.analytic_distribution):
                        line.analytic_distribution = distribution
        
        return super().action_post()
    
    def action_recompute_analytic_distribution(self):
        """Manual action to recompute analytic distribution for selected moves."""
        for move in self:
            distribution = move._compute_analytic_distribution_values()
            if distribution:
                for line in move.line_ids:
                    line.analytic_distribution = distribution
                
                move.message_post(
                    body=_('Analytic distribution recomputed for all lines.')
                )
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Analytic Distribution Updated'),
                'message': _('Analytic distribution has been recomputed for %d moves.') % len(self),
                'type': 'success',
                'sticky': False,
            }
        }
    
    # ========================================================================
    # HELPER METHODS
    # ========================================================================
    
    def _compute_analytic_distribution_values(self):
        """
        Compute analytic distribution values for this move using dynamic configuration.
        Weights are retrieved from ops.matrix.config instead of hardcoded values.
        """
        self.ensure_one()
        
        # Get configuration
        config = self.env['ops.matrix.config'].get_config(
            company_id=self.company_id.id if self.company_id else None
        )
        
        # Extract analytic account IDs
        branch_account_id = None
        bu_account_id = None
        
        if self.ops_branch_id:
            if hasattr(self.ops_branch_id, 'analytic_account_id') and self.ops_branch_id.analytic_account_id:
                branch_account_id = self.ops_branch_id.analytic_account_id.id
            elif hasattr(self.ops_branch_id, 'ops_analytic_account_id') and self.ops_branch_id.ops_analytic_account_id:
                branch_account_id = self.ops_branch_id.ops_analytic_account_id.id
        
        if self.ops_business_unit_id and self.ops_business_unit_id.analytic_account_id:
            bu_account_id = self.ops_business_unit_id.analytic_account_id.id
        
        # Use config to calculate distribution
        return config.get_analytic_distribution(
            branch_id=branch_account_id,
            bu_id=bu_account_id
        )
    
    def _propagate_matrix_dimensions(self, vals):
        """
        Propagate matrix dimensions from source order to invoice/bill.
        
        This method examines the context or related orders to extract
        ops_branch_id and ops_business_unit_id and populate them in vals.
        
        :param vals: Dictionary of values being created
        """
        # Check if dimensions already explicitly set
        if vals.get('ops_branch_id') or vals.get('ops_business_unit_id'):
            return
        
        # Try to find source order from invoice_origin or context
        invoice_origin = vals.get('invoice_origin')
        source_order = None
        
        if invoice_origin:
            # Parse invoice_origin (e.g., "SO0001234" or "PO0001234")
            source_order = self._find_source_order(invoice_origin)
        
        # If source order found, extract dimensions
        if source_order:
            if hasattr(source_order, 'ops_branch_id') and source_order.ops_branch_id:
                vals['ops_branch_id'] = source_order.ops_branch_id.id
            if hasattr(source_order, 'ops_business_unit_id') and source_order.ops_business_unit_id:
                vals['ops_business_unit_id'] = source_order.ops_business_unit_id.id
            vals['ops_source_order_id'] = f"{source_order._name},{source_order.id}"
    
    def _find_source_order(self, origin_reference):
        """
        Find the source order (SaleOrder or PurchaseOrder) by origin reference.
        
        :param origin_reference: String like "SO0001234" or "PO0001234"
        :return: RecordSet of order or None
        """
        if not origin_reference:
            return None
        
        # Try to find sale order
        sale_order = self.env['sale.order'].search([
            '|',
            ('name', '=', origin_reference),
            ('name', '=', origin_reference.replace('SO', '').lstrip('0') or origin_reference)
        ], limit=1)
        
        if sale_order:
            return sale_order
        
        # Try to find purchase order
        purchase_order = self.env['purchase.order'].search([
            '|',
            ('name', '=', origin_reference),
            ('name', '=', origin_reference.replace('PO', '').lstrip('0') or origin_reference)
        ], limit=1)
        
        return purchase_order if purchase_order else None
    
    def action_invoice_sent(self):
        """
        Override email sending to enforce governance rules.
        
        This prevents users from sending invoices by email
        if they violate governance rules or have pending approvals.
        """
        # ADMIN BYPASS: Allow administrators to send anything
        if self.env.su or self.env.user.has_group('base.group_system'):
            # Log admin override for audit trail
            try:
                for move in self:
                    if move.is_invoice(include_receipts=True):
                        self.env['ops.security.audit'].sudo().log_security_override(
                            model_name=move._name,
                            record_id=move.id,
                            reason='Admin bypass used to send Invoice/Bill without governance checks'
                        )
            except Exception as e:
                _logger.warning("Failed to log admin override: %s", str(e))
            return super().action_invoice_sent()
        
        for move in self:
            # Only enforce for invoices and bills
            if move.is_invoice(include_receipts=True):
                _logger.info("OPS Governance: Checking invoice %s for email commitment", move.name)
                
                # Check for pending approvals (if governance mixin is applied)
                if hasattr(move, 'approval_request_ids'):
                    pending_approvals = move.approval_request_ids.filtered(
                        lambda a: a.state == 'pending'
                    )
                    
                    if pending_approvals:
                        rule_names = ', '.join(pending_approvals.mapped('rule_id.name'))
                        raise UserError(_(
                            "🚫 COMMITMENT BLOCKED: You cannot Email document '%s' "
                            "until it satisfies company Governance Rules.\n\n"
                            "⏳ Pending Approval: %s\n\n"
                            "This document is locked for external commitment (email or print) "
                            "until the required approvals are granted."
                        ) % (move.display_name, rule_names))
                
                # Enforce governance rules (if mixin is applied)
                if hasattr(move, '_enforce_governance_rules'):
                    try:
                        move._enforce_governance_rules(move, trigger_type='on_write')
                        _logger.info("OPS Governance: Invoice %s passed all governance checks for email", move.name)
                    except UserError as e:
                        # Re-raise with enhanced message for email context
                        error_message = str(e)
                        if 'requires approval' in error_message.lower():
                            raise UserError(_(
                                "🚫 COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n"
                                "%s\n\n"
                                "External commitment (email/print) is blocked until approval is granted."
                            ) % (move.display_name, error_message))
                        else:
                            raise UserError(_(
                                "🚫 COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n%s"
                            ) % (move.display_name, error_message))
        
        # If all checks pass, proceed with email wizard
        return super().action_invoice_sent()


class AccountMoveLine(models.Model):
    _inherit = ['account.move.line', 'ops.matrix.mixin']
    _name = 'account.move.line'
    
    # These fields are inherited from ops.matrix.mixin:
    # - ops_branch_id
    # - ops_business_unit_id
    # - ops_company_id
    # - ops_analytic_distribution
    
    # ========================================================================
    # DEFAULT METHODS
    # ========================================================================
    
    def _get_default_ops_branch(self):
        """Get default branch from parent move if available."""
        if self._context.get('default_move_id'):
            move = self.env['account.move'].browse(self._context['default_move_id'])
            if move.ops_branch_id:
                return move.ops_branch_id.id
        return super()._get_default_ops_branch()
    
    def _get_default_ops_business_unit(self):
        """Get default BU from parent move if available."""
        if self._context.get('default_move_id'):
            move = self.env['account.move'].browse(self._context['default_move_id'])
            if move.ops_business_unit_id:
                return move.ops_business_unit_id.id
        return super()._get_default_ops_business_unit()
    
    # ========================================================================
    # ONCHANGE METHODS
    # ========================================================================
    
    @api.onchange('ops_branch_id', 'ops_business_unit_id')
    def _onchange_matrix_dimensions(self):
        """Update analytic distribution when matrix dimensions change on line."""
        distribution = self._compute_analytic_distribution_values()
        if distribution:
            self.analytic_distribution = distribution
        elif self.analytic_distribution:
            # Clear if no dimensions
            self.analytic_distribution = False
    
    @api.onchange('move_id')
    def _onchange_move_id_propagate_dimensions(self):
        """
        When move_id changes or is set, inherit the move's matrix dimensions.
        
        This ensures that when a line is added to a move with specific dimensions,
        it automatically gets the correct dimensions.
        """
        if self.move_id:
            # Inherit dimensions from parent move if not already set
            if not self.ops_branch_id and self.move_id.ops_branch_id:
                self.ops_branch_id = self.move_id.ops_branch_id
            if not self.ops_business_unit_id and self.move_id.ops_business_unit_id:
                self.ops_business_unit_id = self.move_id.ops_business_unit_id
            
            # Update analytic distribution
            distribution = self._compute_analytic_distribution_values()
            if distribution:
                self.analytic_distribution = distribution
    
    # ========================================================================
    # HELPER METHODS
    # ========================================================================
    
    def _compute_analytic_distribution_values(self):
        """
        Compute analytic distribution for this line using dynamic configuration.
        Weights are retrieved from ops.matrix.config instead of hardcoded values.
        """
        self.ensure_one()
        
        # Get configuration
        company_id = self.company_id.id if self.company_id else (
            self.move_id.company_id.id if self.move_id and self.move_id.company_id else None
        )
        config = self.env['ops.matrix.config'].get_config(company_id=company_id)
        
        # Check if line has its own dimensions, otherwise use move's dimensions
        branch = self.ops_branch_id or (self.move_id.ops_branch_id if self.move_id else False)
        bu = self.ops_business_unit_id or (self.move_id.ops_business_unit_id if self.move_id else False)
        
        # Extract analytic account IDs
        branch_account_id = None
        bu_account_id = None
        
        if branch:
            if hasattr(branch, 'analytic_account_id') and branch.analytic_account_id:
                branch_account_id = branch.analytic_account_id.id
            elif hasattr(branch, 'ops_analytic_account_id') and branch.ops_analytic_account_id:
                branch_account_id = branch.ops_analytic_account_id.id
        
        if bu and bu.analytic_account_id:
            bu_account_id = bu.analytic_account_id.id
        
        # Use config to calculate distribution
        return config.get_analytic_distribution(
            branch_id=branch_account_id,
            bu_id=bu_account_id
        )

>>> ops_matrix_core/security/ir.model.access.csv <<<
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ops_branch_user,ops.branch.user,model_ops_branch,group_ops_user,1,0,0,0
access_ops_branch_manager,ops.branch.manager,model_ops_branch,group_ops_manager,1,1,1,0
access_ops_branch_admin,ops.branch.admin,model_ops_branch,group_ops_admin,1,1,1,1
access_ops_branch_purchase_user,ops.branch.purchase.user,model_ops_branch,purchase.group_purchase_user,1,0,0,0
access_ops_branch_stock_user,ops.branch.stock.user,model_ops_branch,stock.group_stock_user,1,0,0,0
access_ops_branch_sale_user,ops.branch.sale.user,model_ops_branch,sales_team.group_sale_salesman,1,0,0,0
access_ops_bu_user,ops.business.unit.user,model_ops_business_unit,group_ops_user,1,0,0,0
access_ops_bu_manager,ops.business.unit.manager,model_ops_business_unit,group_ops_manager,1,1,1,0
access_ops_bu_admin,ops.business.unit.admin,model_ops_business_unit,group_ops_admin,1,1,1,1
access_ops_bu_purchase_user,ops.business.unit.purchase.user,model_ops_business_unit,purchase.group_purchase_user,1,0,0,0
access_ops_bu_stock_user,ops.business.unit.stock.user,model_ops_business_unit,stock.group_stock_user,1,0,0,0
access_ops_bu_sale_user,ops.business.unit.sale.user,model_ops_business_unit,sales_team.group_sale_salesman,1,0,0,0
access_ops_persona_user,ops.persona.user,model_ops_persona,group_ops_user,1,0,0,0
access_ops_persona_manager,ops.persona.manager,model_ops_persona,group_ops_manager,1,1,1,1
access_ops_persona_delegation_user,ops.persona.delegation.user,model_ops_persona_delegation,group_ops_user,1,1,1,0
access_ops_inter_branch_transfer_user,ops.inter.branch.transfer.user,model_ops_inter_branch_transfer,group_ops_user,1,1,1,0
access_ops_inter_branch_transfer_manager,ops.inter.branch.transfer.manager,model_ops_inter_branch_transfer,group_ops_manager,1,1,1,1
access_ops_gov_rule_user,ops.governance.rule.user,model_ops_governance_rule,group_ops_user,1,0,0,0
access_ops_gov_rule_manager,ops.governance.rule.manager,model_ops_governance_rule,group_ops_manager,1,1,1,1
access_ops_gov_discount_limit_user,ops.governance.discount.limit.user,model_ops_governance_discount_limit,group_ops_user,1,0,0,0
access_ops_gov_discount_limit_manager,ops.governance.discount.limit.manager,model_ops_governance_discount_limit,group_ops_manager,1,1,1,1
access_ops_gov_margin_rule_user,ops.governance.margin.rule.user,model_ops_governance_margin_rule,group_ops_user,1,0,0,0
access_ops_gov_margin_rule_manager,ops.governance.margin.rule.manager,model_ops_governance_margin_rule,group_ops_manager,1,1,1,1
access_ops_gov_price_authority_user,ops.governance.price.authority.user,model_ops_governance_price_authority,group_ops_user,1,0,0,0
access_ops_gov_price_authority_manager,ops.governance.price.authority.manager,model_ops_governance_price_authority,group_ops_manager,1,1,1,1
access_ops_approval_workflow_user,ops.approval.workflow.user,model_ops_approval_workflow,group_ops_user,1,0,0,0
access_ops_approval_workflow_manager,ops.approval.workflow.manager,model_ops_approval_workflow,group_ops_manager,1,1,1,1
access_ops_approval_workflow_step_user,ops.approval.workflow.step.user,model_ops_approval_workflow_step,group_ops_user,1,0,0,0
access_ops_approval_workflow_step_manager,ops.approval.workflow.step.manager,model_ops_approval_workflow_step,group_ops_manager,1,1,1,1
access_ops_gov_violation_report_user,ops.governance.violation.report.user,model_ops_governance_violation_report,group_ops_user,1,1,1,1
access_ops_gov_violation_report_manager,ops.governance.violation.report.manager,model_ops_governance_violation_report,group_ops_manager,1,1,1,1
access_ops_approval_req_user,ops.approval.request.user,model_ops_approval_request,group_ops_user,1,1,1,0
access_ops_approval_req_manager,ops.approval.request.manager,model_ops_approval_request,group_ops_manager,1,1,1,1
access_ops_approval_req_sale_user,ops.approval.request.sale.user,model_ops_approval_request,sales_team.group_sale_salesman,1,1,1,0
access_ops_approval_req_purchase_user,ops.approval.request.purchase.user,model_ops_approval_request,purchase.group_purchase_user,1,1,1,0
access_ops_approval_dash_user,ops.approval.dashboard.user,model_ops_approval_dashboard,group_ops_user,1,0,0,0
access_ops_sla_template_user,ops.sla.template.user,model_ops_sla_template,group_ops_user,1,0,0,0
access_ops_sla_template_manager,ops.sla.template.manager,model_ops_sla_template,group_ops_manager,1,1,1,1
access_ops_sla_instance_user,ops.sla.instance.user,model_ops_sla_instance,group_ops_user,1,1,1,0
access_ops_archive_policy_admin,ops.archive.policy.admin,model_ops_archive_policy,group_ops_admin,1,1,1,1
access_ops_product_request_user,ops.product.request.user,model_ops_product_request,group_ops_user,1,1,1,0
access_ops_product_request_manager,ops.product.request.manager,model_ops_product_request,group_ops_manager,1,1,1,1
access_ops_product_request_approver,ops.product.request.approver,model_ops_product_request,group_ops_product_approver,1,1,1,1
access_ops_product_request_admin,ops.product.request.admin,model_ops_product_request,group_ops_admin,1,1,1,1
access_ops_security_audit_user,ops.security.audit.user,model_ops_security_audit,group_ops_user,1,0,0,0
access_ops_security_audit_manager,ops.security.audit.manager,model_ops_security_audit,group_ops_manager,1,0,0,0
access_ops_security_audit_admin,ops.security.audit.admin,model_ops_security_audit,group_ops_admin,1,0,0,0
access_ops_security_audit_system,ops.security.audit.system,model_ops_security_audit,base.group_system,1,0,0,0
access_ops_dashboard_config_user,ops.dashboard.config.user,model_ops_dashboard_config,base.group_user,1,1,1,1
access_ops_dashboard_widget_user,ops.dashboard.widget.user,model_ops_dashboard_widget,group_ops_user,1,0,0,0
access_ops_dashboard_widget_manager,ops.dashboard.widget.manager,model_ops_dashboard_widget,group_ops_manager,1,1,0,0
access_ops_dashboard_widget_admin,ops.dashboard.widget.admin,model_ops_dashboard_widget,group_ops_admin,1,1,1,1
access_ops_api_key_admin,ops.api.key.admin,model_ops_api_key,group_ops_admin,1,1,1,1
access_ops_api_key_system,ops.api.key.system,model_ops_api_key,base.group_system,1,1,1,1
access_ops_audit_log_admin,ops.audit.log.admin,model_ops_audit_log,group_ops_admin,1,0,0,0
access_ops_audit_log_system,ops.audit.log.system,model_ops_audit_log,base.group_system,1,0,0,0
>>> ops_matrix_core/security/ops_security.xml <<<
File not found


###############################################
### MODULE: ops_matrix_accounting (Target)
###############################################

>>> ops_matrix_accounting/__manifest__.py <<<
# -*- coding: utf-8 -*-
{
    'name': "OPS Matrix Accounting",
    'summary': "Advanced Financial Management & Reporting for Matrix Operations",
    'description': """
        Version 1.0 - Accounting Extension
        
        Transforms the standard Invoicing app into a full Accounting suite:
        1. PDC (Post-Dated Checks) Management
        2. Budget Control & Analytic Enforcement
        3. Professional Financial Reports (GL, TB, PL, BS)
        4. Excel Export Engine
        
        Requires: ops_matrix_core
    """,
    'author': "Gemini-3.0-Pro",
    'website': "http://www.yourcompany.com",
    'category': 'Accounting/Accounting',
    'version': '19.0.1.0.0',
    'depends': ['ops_matrix_core', 'account'],
    'external_dependencies': {
        'python': ['xlsxwriter'],
    },
    'data': [
        'security/ir.model.access.csv',
        'views/ops_accounting_menus.xml',
        'views/ops_pdc_views.xml',
        'views/ops_budget_views.xml',
        'views/ops_general_ledger_wizard_views.xml',
        'views/ops_general_ledger_wizard_enhanced_views.xml',
        'views/ops_financial_report_wizard_views.xml',
        'views/ops_reporting_views.xml',
        'reports/ops_general_ledger_template.xml',
        'reports/ops_financial_report_template.xml',
        'reports/ops_consolidated_report_templates.xml',
        
        # Template Data Files
        'data/templates/ops_budget_templates.xml',
    ],
    'post_init_hook': 'post_init_hook',
    'installable': True,
    'application': True,
    'license': 'LGPL-3',
}

>>> ops_matrix_accounting/models/__init__.py <<<
from . import ops_pdc
from . import ops_budget
from . import ops_product_category_defaults
from . import ops_matrix_standard_extensions
from . import ops_consolidated_reporting

>>> ops_matrix_accounting/models/__init__.py <<<
from . import ops_pdc
from . import ops_budget
from . import ops_product_category_defaults
from . import ops_matrix_standard_extensions
from . import ops_consolidated_reporting

>>> ops_matrix_accounting/models/ops_budget.py <<<
from odoo import models, fields, api
from odoo.exceptions import ValidationError
from psycopg2 import sql

class OpsBudget(models.Model):
    _name = 'ops.budget'
    _description = 'Matrix Budget Control'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'date_from desc, id desc'

    name = fields.Char(string='Budget Name', required=True, tracking=True)
    active = fields.Boolean(default=True)
    
    # Matrix Dimensions (Required)
    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=True,
        tracking=True,
        help="Branch this budget applies to"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=True,
        tracking=True,
        help="Business unit this budget applies to"
    )
    
    # Date Range
    date_from = fields.Date(string='Start Date', required=True, tracking=True)
    date_to = fields.Date(string='End Date', required=True, tracking=True)
    
    # Budget Status
    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirmed', 'Confirmed'),
        ('done', 'Closed'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', tracking=True)
    
    # Budget Lines
    line_ids = fields.One2many('ops.budget.line', 'budget_id', string='Budget Lines')
    
    # Totals
    total_planned = fields.Monetary(
        string='Total Planned',
        compute='_compute_totals',
        store=True
    )
    total_practical = fields.Monetary(
        string='Total Actual',
        compute='_compute_totals',
        store=True
    )
    total_committed = fields.Monetary(
        string='Total Committed',
        compute='_compute_totals',
        store=True
    )
    available_balance = fields.Monetary(
        string='Available Balance',
        compute='_compute_totals',
        store=True
    )
    currency_id = fields.Many2one(
        'res.currency',
        string='Currency',
        required=True,
        default=lambda self: self.env.company.currency_id
    )

    _unique_matrix_budget = models.Constraint(
        'unique(ops_branch_id, ops_business_unit_id, date_from, date_to)',
        'A budget already exists for this Branch/Business Unit combination in the specified date range!'
    )

    @api.constrains('date_from', 'date_to')
    def _check_dates(self):
        for budget in self:
            if budget.date_to < budget.date_from:
                raise ValidationError('End Date must be after Start Date')

            # Check for overlapping date ranges
            overlapping = self.search([
                ('id', '!=', budget.id),
                ('ops_branch_id', '=', budget.ops_branch_id.id),
                ('ops_business_unit_id', '=', budget.ops_business_unit_id.id),
                ('date_from', '<=', budget.date_to),
                ('date_to', '>=', budget.date_from)
            ])
            if overlapping:
                raise ValidationError(
                    'Budget dates overlap with existing budget(s) for the same Branch/Business Unit!'
                )

    @api.depends('line_ids.planned_amount', 'line_ids.practical_amount', 'line_ids.committed_amount')
    def _compute_totals(self):
        for budget in self:
            budget.total_planned = sum(budget.line_ids.mapped('planned_amount'))
            budget.total_practical = sum(budget.line_ids.mapped('practical_amount'))
            budget.total_committed = sum(budget.line_ids.mapped('committed_amount'))
            budget.available_balance = budget.total_planned - budget.total_practical - budget.total_committed

    def action_confirm(self):
        self.write({'state': 'confirmed'})

    def action_done(self):
        self.write({'state': 'done'})

    def action_cancel(self):
        self.write({'state': 'cancelled'})

    def action_draft(self):
        self.write({'state': 'draft'})

    @api.model
    def check_budget_availability(self, account_id, ops_branch_id, ops_business_unit_id, amount):
        """Check if sufficient budget is available for a planned expense.
        
        Args:
            account_id: The expense account to check
            ops_branch_id: The branch requesting the expense
            ops_business_unit_id: The business unit requesting the expense
            amount: The amount to check
            
        Returns:
            bool: True if sufficient budget exists, False otherwise
        """
        domain = [
            ('state', '=', 'confirmed'),
            ('ops_branch_id', '=', ops_branch_id),
            ('ops_business_unit_id', '=', ops_business_unit_id),
            ('date_from', '<=', fields.Date.today()),
            ('date_to', '>=', fields.Date.today())
        ]
        
        active_budget = self.search(domain, limit=1)
        if not active_budget:
            return False
            
        budget_line = active_budget.line_ids.filtered(
            lambda l: l.general_account_id.id == account_id
        )
        if not budget_line:
            return False
            
        available = budget_line.planned_amount - budget_line.practical_amount - budget_line.committed_amount
        return available >= amount


class OpsBudgetLine(models.Model):
    _name = 'ops.budget.line'
    _description = 'Matrix Budget Line'
    _order = 'general_account_id'

    budget_id = fields.Many2one('ops.budget', string='Budget', required=True, ondelete='cascade')
    general_account_id = fields.Many2one(
        'account.account',
        string='Expense Account',
        required=True,
        domain=[('account_type', '=', 'expense')]
    )
    
    planned_amount = fields.Monetary(string='Planned Amount', required=True)
    practical_amount = fields.Monetary(string='Actual Amount', compute='_compute_practical_amount', store=True)
    committed_amount = fields.Monetary(string='Committed Amount', compute='_compute_committed_amount', store=True)
    available_amount = fields.Monetary(string='Available Amount', compute='_compute_available_amount', store=True)
    
    currency_id = fields.Many2one(related='budget_id.currency_id')
    company_id = fields.Many2one(related='budget_id.ops_branch_id')

    _unique_account_per_budget = models.Constraint(
        'unique(budget_id, general_account_id)',
        'You can only have one budget line per account!'
    )

    @api.depends('planned_amount', 'practical_amount', 'committed_amount')
    def _compute_available_amount(self):
        for line in self:
            line.available_amount = line.planned_amount - line.practical_amount - line.committed_amount

    def _compute_practical_amount(self):
        """Compute actual spend from account moves."""
        for line in self:
            domain = [
                ('account_id', '=', line.general_account_id.id),
                ('ops_branch_id', '=', line.budget_id.ops_branch_id.id),
                ('ops_business_unit_id', '=', line.budget_id.ops_business_unit_id.id),
                ('date', '>=', line.budget_id.date_from),
                ('date', '<=', line.budget_id.date_to),
                ('move_id.state', '=', 'posted'),
                ('move_id.move_type', 'in', ['in_invoice', 'in_refund'])
            ]
            
            amount = sum(self.env['account.move.line'].search(domain).mapped('debit'))
            line.practical_amount = amount

    def _compute_committed_amount(self):
        """Compute committed amount from purchase orders."""
        for line in self:
            domain = [
                ('account_id', '=', line.general_account_id.id),
                ('order_id.ops_branch_id', '=', line.budget_id.ops_branch_id.id),
                ('order_id.ops_business_unit_id', '=', line.budget_id.ops_business_unit_id.id),
                ('order_id.date_order', '>=', line.budget_id.date_from),
                ('order_id.date_order', '<=', line.budget_id.date_to),
                ('order_id.state', 'in', ['purchase', 'done']),
                ('invoice_status', '!=', 'invoiced')
            ]
            
            amount = sum(self.env['purchase.order.line'].search(domain).mapped('price_total'))
            line.committed_amount = amount

>>> ops_matrix_accounting/models/ops_consolidated_reporting.py <<<
# -*- coding: utf-8 -*-
"""
OPS Matrix Accounting - Consolidated Financial Reporting
=========================================================

This module provides comprehensive financial reporting engines for hierarchical
consolidated reports across Company, Branch, and Business Unit dimensions.

Author: OPS Matrix Framework
"""

from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
from odoo.tools import date_utils, float_round
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)


class OpsCompanyConsolidation(models.TransientModel):
    """Company-Level Consolidated P&L Report"""
    _name = 'ops.company.consolidation'
    _description = 'Company-Level Consolidated P&L Report'
    
    # Filter Fields
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # Comparison Period
    compare_with_previous = fields.Boolean(
        string='Compare with Previous Period',
        default=True
    )
    previous_date_from = fields.Date(
        string='Previous From Date',
        compute='_compute_previous_dates',
        store=False
    )
    previous_date_to = fields.Date(
        string='Previous To Date',
        compute='_compute_previous_dates',
        store=False
    )
    
    # Branch Filtering
    branch_ids = fields.Many2many(
        'ops.branch',
        string='Filter Branches',
        help='Leave empty for all branches in company'
    )
    
    # Level of Detail
    report_detail_level = fields.Selection([
        ('summary', 'Summary Only'),
        ('by_branch', 'By Branch'),
        ('by_bu', 'By Business Unit'),
        ('by_account', 'By Account Group')
    ], string='Detail Level', default='summary', required=True)
    
    # Report Data (stored)
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    # Computed Methods
    @api.depends('date_from', 'date_to')
    def _compute_previous_dates(self):
        """Compute previous period dates for comparison."""
        for wizard in self:
            if wizard.date_from and wizard.date_to:
                period_days = (wizard.date_to - wizard.date_from).days
                wizard.previous_date_from = wizard.date_from - timedelta(days=period_days + 1)
                wizard.previous_date_to = wizard.date_from - timedelta(days=1)
            else:
                wizard.previous_date_from = False
                wizard.previous_date_to = False
    
    @api.depends('company_id', 'date_from', 'date_to', 'branch_ids', 'report_detail_level')
    def _compute_report_data(self):
        """Main method to compute consolidated company P&L."""
        for wizard in self:
            if not wizard.date_from or not wizard.date_to:
                wizard.report_data = {}
                continue
            
            # Get company branches (filtered if selected)
            domain = [('company_id', '=', wizard.company_id.id)]
            if wizard.branch_ids:
                domain.append(('id', 'in', wizard.branch_ids.ids))
            
            branches = self.env['ops.branch'].search(domain)
            
            # Get account move lines for the period
            base_domain = [
                ('date', '>=', wizard.date_from),
                ('date', '<=', wizard.date_to),
                ('company_id', '=', wizard.company_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            # Apply branch filter if specified
            if wizard.branch_ids:
                base_domain.append(('ops_branch_id', 'in', wizard.branch_ids.ids))
            
            # Get data based on detail level
            if wizard.report_detail_level == 'summary':
                data = wizard._get_summary_data(base_domain, branches)
            elif wizard.report_detail_level == 'by_branch':
                data = wizard._get_branch_detail_data(base_domain, branches)
            elif wizard.report_detail_level == 'by_bu':
                data = wizard._get_bu_detail_data(base_domain, branches)
            elif wizard.report_detail_level == 'by_account':
                data = wizard._get_account_detail_data(base_domain, branches)
            else:
                data = {}
            
            # Add comparison data if requested
            if wizard.compare_with_previous:
                comparison_data = wizard._get_comparison_data()
                data['comparison'] = comparison_data
            
            wizard.report_data = data
    
    def _get_summary_data(self, domain, branches):
        """Get high-level summary P&L data."""
        MoveLine = self.env['account.move.line']
        
        # Get total income
        income_domain = domain + [
            ('account_id.account_type', 'in', ['income', 'income_other'])
        ]
        MoveLine._read_group(
            domain=income_domain,
            groupby=[],
            aggregates=['credit:sum', 'debit:sum']
        )
        total_income = income_data[0]['credit'] - income_data[0]['debit'] if income_data else 0
        
        # Get total expense
        expense_domain = domain + [
            ('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])
        ]
        MoveLine._read_group(
            domain=expense_domain,
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        total_expense = expense_data[0]['debit'] - expense_data[0]['credit'] if expense_data else 0
        
        # Get gross profit (income - COGS)
        cogs_domain = domain + [
            ('account_id.account_type', '=', 'expense_direct_cost')
        ]
        MoveLine._read_group(
            domain=cogs_domain,
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        total_cogs = cogs_data[0]['debit'] - cogs_data[0]['credit'] if cogs_data else 0
        gross_profit = total_income - total_cogs
        
        # Get operating expenses
        operating_domain = domain + [
            ('account_id.account_type', 'in', ['expense', 'expense_depreciation'])
        ]
        MoveLine._read_group(
            domain=operating_domain,
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        total_operating = operating_data[0]['debit'] - operating_data[0]['credit'] if operating_data else 0
        
        net_profit = total_income - total_expense
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'branches': len(branches),
            'totals': {
                'total_income': total_income,
                'total_cogs': total_cogs,
                'gross_profit': gross_profit,
                'gross_margin': (gross_profit / total_income * 100) if total_income else 0,
                'total_operating': total_operating,
                'total_expense': total_expense,
                'net_profit': net_profit,
                'net_margin': (net_profit / total_income * 100) if total_income else 0,
            },
            'branch_performance': self._get_branch_performance_summary(branches, domain),
        }
    
    def _get_branch_detail_data(self, domain, branches):
        """Get P&L data broken down by branch."""
        MoveLine = self.env['account.move.line']
        
        branch_data = []
        for branch in branches:
            branch_domain = domain + [('ops_branch_id', '=', branch.id)]
            
            # Get income for branch
            income_domain = branch_domain + [
                ('account_id.account_type', 'in', ['income', 'income_other'])
            ]
            MoveLine._read_group(
                domain=income_domain,
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            branch_income = income_result[0].get('credit', 0) - income_result[0].get('debit', 0) if income_result else 0
            
            # Get expense for branch
            expense_domain = branch_domain + [
                ('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])
            ]
            MoveLine._read_group(
                domain=expense_domain,
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            branch_expense = expense_result[0].get('debit', 0) - expense_result[0].get('credit', 0) if expense_result else 0
            
            branch_data.append({
                'branch_id': branch.id,
                'branch_code': branch.code,
                'branch_name': branch.name,
                'income': branch_income,
                'expense': branch_expense,
                'net_profit': branch_income - branch_expense,
                'bu_count': len(branch.business_unit_ids),
                'transactions': MoveLine.search_count(branch_domain),
            })
        
        # Sort by net profit (descending)
        branch_data.sort(key=lambda x: x['net_profit'], reverse=True)
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'branch_data': branch_data,
            'summary': {
                'total_income': sum(b['income'] for b in branch_data),
                'total_expense': sum(b['expense'] for b in branch_data),
                'total_net_profit': sum(b['net_profit'] for b in branch_data),
                'best_performing': branch_data[0] if branch_data else None,
                'worst_performing': branch_data[-1] if branch_data else None,
            }
        }
    
    def _get_bu_detail_data(self, domain, branches):
        """Get P&L data broken down by business unit."""
        MoveLine = self.env['account.move.line']
        
        # Get all BUs in selected branches
        branch_ids = branches.ids if branches else []
        bus = self.env['ops.business.unit'].search([
            ('branch_ids', 'in', branch_ids)
        ]) if branch_ids else self.env['ops.business.unit'].search([
            ('company_ids', 'in', [self.company_id.id])
        ])
        
        bu_data = []
        for bu in bus:
            bu_domain = domain + [('ops_business_unit_id', '=', bu.id)]
            
            # Get income for BU
            income_domain = bu_domain + [
                ('account_id.account_type', 'in', ['income', 'income_other'])
            ]
            MoveLine._read_group(
                domain=income_domain,
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            bu_income = income_result[0].get('credit', 0) - income_result[0].get('debit', 0) if income_result else 0
            
            # Get expense for BU
            expense_domain = bu_domain + [
                ('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])
            ]
            MoveLine._read_group(
                domain=expense_domain,
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            bu_expense = expense_result[0].get('debit', 0) - expense_result[0].get('credit', 0) if expense_result else 0
            
            # Get branches where this BU operates
            bu_branches = bu.branch_ids.filtered(lambda b: b.id in branch_ids) if branch_ids else bu.branch_ids
            
            bu_data.append({
                'bu_id': bu.id,
                'bu_code': bu.code,
                'bu_name': bu.name,
                'income': bu_income,
                'expense': bu_expense,
                'net_profit': bu_income - bu_expense,
                'branch_count': len(bu_branches),
                'branch_names': ', '.join(bu_branches.mapped('code')),
                'profitability_ratio': (bu_income - bu_expense) / bu_income * 100 if bu_income else 0,
            })
        
        # Sort by profitability ratio (descending)
        bu_data.sort(key=lambda x: x['profitability_ratio'], reverse=True)
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'bu_data': bu_data,
            'summary': {
                'total_income': sum(b['income'] for b in bu_data),
                'total_expense': sum(b['expense'] for b in bu_data),
                'total_net_profit': sum(b['net_profit'] for b in bu_data),
                'most_profitable': bu_data[0] if bu_data else None,
                'least_profitable': bu_data[-1] if bu_data else None,
            }
        }
    
    def _get_account_detail_data(self, domain, branches):
        """Get detailed P&L data by account group."""
        MoveLine = self.env['account.move.line']
        
        # Define account types for P&L
        account_types = [
            ('income', 'Revenue'),
            ('income_other', 'Other Income'),
            ('expense_direct_cost', 'Cost of Goods Sold'),
            ('expense', 'Operating Expenses'),
            ('expense_depreciation', 'Depreciation'),
        ]
        
        account_data = []
        for acc_type, acc_name in account_types:
            type_domain = domain + [('account_id.account_type', '=', acc_type)]
            
            # Get sum for this account type
            MoveLine._read_group(
                domain=type_domain,
                groupby=['account_id'],
                aggregates=['debit:sum', 'credit:sum', 'balance:sum']
            )
            
            total_debit = sum(item['debit'] for item in result)
            total_credit = sum(item['credit'] for item in result)
            
            if acc_type.startswith('income'):
                amount = total_credit - total_debit
            else:
                amount = total_debit - total_credit
            
            # Get top 5 accounts in this type
            top_accounts = []
            for item in result:
                if item.get('account_id'):
                    account = self.env['account.account'].browse(item['account_id'][0])
                    top_accounts.append({
                        'account_code': account.code,
                        'account_name': account.name,
                        'amount': item['credit'] - item['debit'] if acc_type.startswith('income') else item['debit'] - item['credit'],
                    })
            
            # Sort top accounts
            top_accounts.sort(key=lambda x: abs(x['amount']), reverse=True)
            
            account_data.append({
                'account_type': acc_type,
                'account_type_name': acc_name,
                'total_amount': amount,
                'top_accounts': top_accounts[:5],
                'account_count': len(result),
            })
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'account_data': account_data,
            'branches': len(branches),
        }
    
    def _get_comparison_data(self):
        """Get comparison data with previous period."""
        MoveLine = self.env['account.move.line']
        
        previous_domain = [
            ('date', '>=', self.previous_date_from),
            ('date', '<=', self.previous_date_to),
            ('company_id', '=', self.company_id.id),
            ('move_id.state', '=', 'posted'),
        ]
        
        if self.branch_ids:
            previous_domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
        
        # Get previous period totals
        MoveLine._read_group(
            domain=previous_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
            groupby=[],
            aggregates=['credit:sum', 'debit:sum']
        )
        previous_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
        
        MoveLine._read_group(
            domain=previous_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        previous_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
        
        previous_net = previous_income - previous_expense
        
        return {
            'previous_income': previous_income,
            'previous_expense': previous_expense,
            'previous_net_profit': previous_net,
            'period': f"{self.previous_date_from} to {self.previous_date_to}",
        }
    
    def _get_branch_performance_summary(self, branches, domain):
        """Get high-level branch performance summary."""
        MoveLine = self.env['account.move.line']
        
        performance = []
        for branch in branches[:10]:  # Limit to top 10 for summary
            branch_domain = domain + [('ops_branch_id', '=', branch.id)]
            
            MoveLine._read_group(
                domain=branch_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            branch_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            performance.append({
                'branch_code': branch.code,
                'branch_name': branch.name,
                'income': branch_income,
                'bu_count': len(branch.business_unit_ids),
            })
        
        return performance
    
    # Action Methods
    def action_generate_pdf(self):
        """Generate PDF report."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_company_consolidation_pdf').report_action(self)
    
    def action_generate_xlsx(self):
        """Generate Excel report."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_company_consolidation_xlsx').report_action(self)
    
    def action_view_branch_details(self, branch_id):
        """Drill down to branch report."""
        self.ensure_one()
        return {
            'name': _('Branch Report'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.branch.report',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_branch_id': branch_id,
                'default_date_from': self.date_from,
                'default_date_to': self.date_to,
            }
        }
    
    def action_view_bu_details(self, bu_id):
        """Drill down to BU report."""
        self.ensure_one()
        return {
            'name': _('Business Unit Report'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.business.unit.report',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_business_unit_id': bu_id,
                'default_date_from': self.date_from,
                'default_date_to': self.date_to,
            }
        }


class OpsBranchReport(models.TransientModel):
    """Branch-Level Profit & Loss Report"""
    _name = 'ops.branch.report'
    _description = 'Branch-Level Profit & Loss Report'
    
    # Filter Fields
    branch_id = fields.Many2one(
        'ops.branch',
        string='Branch',
        required=True
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # BU Filtering
    business_unit_ids = fields.Many2many(
        'ops.business.unit',
        string='Filter Business Units'
    )
    
    # Report Data
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    @api.depends('branch_id', 'date_from', 'date_to', 'business_unit_ids')
    def _compute_report_data(self):
        """Compute branch-level P&L report."""
        for wizard in self:
            if not wizard.branch_id or not wizard.date_from or not wizard.date_to:
                wizard.report_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            base_domain = [
                ('date', '>=', wizard.date_from),
                ('date', '<=', wizard.date_to),
                ('ops_branch_id', '=', wizard.branch_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            # Apply BU filter if specified
            if wizard.business_unit_ids:
                base_domain.append(('ops_business_unit_id', 'in', wizard.business_unit_ids.ids))
            
            # Get BU performance data
            bu_performance = {}
            # Get business units that operate in this branch
            if wizard.business_unit_ids:
                bus = wizard.business_unit_ids
            else:
                bus = self.env['ops.business.unit'].search([
                    ('branch_ids', 'in', [wizard.branch_id.id])
                ])
            
            for bu in bus:
                bu_domain = base_domain + [('ops_business_unit_id', '=', bu.id)]
                
                # Income for this BU
                MoveLine._read_group(
                    domain=bu_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                    groupby=[],
                    aggregates=['credit:sum', 'debit:sum']
                )
                bu_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
                
                # Expense for this BU
                MoveLine._read_group(
                    domain=bu_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                    groupby=[],
                    aggregates=['debit:sum', 'credit:sum']
                )
                bu_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
                
                bu_performance[bu.id] = {
                    'bu_id': bu.id,
                    'bu_code': bu.code,
                    'bu_name': bu.name,
                    'income': bu_income,
                    'expense': bu_expense,
                    'net_profit': bu_income - bu_expense,
                    'margin': ((bu_income - bu_expense) / bu_income * 100) if bu_income else 0,
                    'transaction_count': MoveLine.search_count(bu_domain),
                }
            
            # Get branch totals
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            total_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            total_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
            
            # Get top products/services (if sale/purchase modules installed)
            top_products = []
            if 'sale.order.line' in self.env:
                try:
                    sale_lines = self.env['sale.order.line'].search([
                        ('order_id.ops_branch_id', '=', wizard.branch_id.id),
                        ('order_id.date_order', '>=', wizard.date_from),
                        ('order_id.date_order', '<=', wizard.date_to),
                        ('order_id.state', 'in', ['sale', 'done']),
                    ], limit=10)
                    
                    for line in sale_lines:
                        top_products.append({
                            'product': line.product_id.name if line.product_id else 'N/A',
                            'quantity': line.product_uom_qty,
                            'revenue': line.price_subtotal,
                        })
                except Exception as e:
                    _logger.warning(f"Could not fetch sale order lines: {e}")
            
            wizard.report_data = {
                'branch': wizard.branch_id.name,
                'branch_code': wizard.branch_id.code,
                'company': wizard.branch_id.company_id.name,
                'period': f"{wizard.date_from} to {wizard.date_to}",
                'bu_performance': list(bu_performance.values()),
                'totals': {
                    'total_income': total_income,
                    'total_expense': total_expense,
                    'net_profit': total_income - total_expense,
                    'bu_count': len(bus),
                    'transaction_count': MoveLine.search_count(base_domain),
                },
                'top_products': top_products[:5],
            }
    
    def action_generate_pdf(self):
        """Generate PDF report for branch."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_branch_pl_pdf').report_action(self)


class OpsBusinessUnitReport(models.TransientModel):
    """Business Unit Profitability Report"""
    _name = 'ops.business.unit.report'
    _description = 'Business Unit Profitability Report'
    
    # Filter Fields
    business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=True
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # Branch Filtering
    branch_ids = fields.Many2many(
        'ops.branch',
        string='Filter Branches'
    )
    
    business_unit_branch_ids = fields.Many2many(
        'ops.branch',
        compute='_compute_business_unit_branch_ids',
        store=False
    )
    
    # Include branch consolidation
    consolidate_by_branch = fields.Boolean(
        string='Show Branch Breakdown',
        default=True
    )
    
    # Report Data
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    @api.depends('business_unit_id')
    def _compute_business_unit_branch_ids(self):
        """Compute available branches for the selected business unit."""
        for wizard in self:
            if wizard.business_unit_id:
                wizard.business_unit_branch_ids = wizard.business_unit_id.branch_ids
            else:
                wizard.business_unit_branch_ids = False
    
    @api.depends('business_unit_id', 'date_from', 'date_to', 'branch_ids', 'consolidate_by_branch')
    def _compute_report_data(self):
        """Compute BU performance across branches."""
        for wizard in self:
            if not wizard.business_unit_id or not wizard.date_from or not wizard.date_to:
                wizard.report_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            base_domain = [
                ('date', '>=', wizard.date_from),
                ('date', '<=', wizard.date_to),
                ('ops_business_unit_id', '=', wizard.business_unit_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            # Apply branch filter if specified
            branches = wizard.branch_ids if wizard.branch_ids else wizard.business_unit_id.branch_ids
            if wizard.branch_ids:
                base_domain.append(('ops_branch_id', 'in', wizard.branch_ids.ids))
            
            # Branch performance breakdown
            branch_performance = {}
            if wizard.consolidate_by_branch:
                for branch in branches:
                    branch_domain = base_domain + [('ops_branch_id', '=', branch.id)]
                    
                    # Income for this branch
                    MoveLine._read_group(
                        domain=branch_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                        groupby=[],
                        aggregates=['credit:sum', 'debit:sum']
                    )
                    branch_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
                    
                    # Expense for this branch
                    MoveLine._read_group(
                        domain=branch_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                        groupby=[],
                        aggregates=['debit:sum', 'credit:sum']
                    )
                    branch_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
                    
                    branch_performance[branch.id] = {
                        'branch_id': branch.id,
                        'branch_code': branch.code,
                        'branch_name': branch.name,
                        'income': branch_income,
                        'expense': branch_expense,
                        'net_profit': branch_income - branch_expense,
                        'contribution_percentage': 0,  # Will calculate after totals
                        'transaction_count': MoveLine.search_count(branch_domain),
                    }
            
            # Get BU totals
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            total_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            total_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
            
            total_net = total_income - total_expense
            
            # Calculate contribution percentages
            for branch_id, data in branch_performance.items():
                if total_income > 0:
                    data['contribution_percentage'] = (data['income'] / total_income * 100)
                else:
                    data['contribution_percentage'] = 0
            
            # Sort branches by contribution (descending)
            sorted_branches = sorted(
                branch_performance.values(),
                key=lambda x: x['contribution_percentage'],
                reverse=True
            )
            
            wizard.report_data = {
                'business_unit': wizard.business_unit_id.name,
                'business_unit_code': wizard.business_unit_id.code,
                'primary_branch': wizard.business_unit_id.primary_branch_id.name if wizard.business_unit_id.primary_branch_id else 'None',
                'period': f"{wizard.date_from} to {wizard.date_to}",
                'branch_performance': sorted_branches,
                'totals': {
                    'total_income': total_income,
                    'total_expense': total_expense,
                    'net_profit': total_net,
                    'profit_margin': (total_net / total_income * 100) if total_income else 0,
                    'branch_count': len(branches),
                    'active_branches': len([b for b in branch_performance.values() if b['transaction_count'] > 0]),
                    'total_transactions': MoveLine.search_count(base_domain),
                },
                'trend_data': wizard._get_trend_data(),
            }
    
    def _get_trend_data(self):
        """Get monthly trend data for the past 6 months."""
        MoveLine = self.env['account.move.line']
        trend_data = []
        
        for i in range(6, -1, -1):  # Last 6 months plus current
            month_start = date_utils.start_of(datetime.now() - timedelta(days=30*i), 'month')
            month_end = date_utils.end_of(month_start, 'month')
            
            domain = [
                ('date', '>=', month_start),
                ('date', '<=', month_end),
                ('ops_business_unit_id', '=', self.business_unit_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            if self.branch_ids:
                domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
            
            MoveLine._read_group(
                domain=domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            month_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            MoveLine._read_group(
                domain=domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            month_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
            
            trend_data.append({
                'month': month_start.strftime('%b %Y'),
                'income': month_income,
                'expense': month_expense,
                'net_profit': month_income - month_expense,
                'transaction_count': MoveLine.search_count(domain),
            })
        
        return trend_data
    
    def action_generate_pdf(self):
        """Generate PDF report for business unit."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_business_unit_pdf').report_action(self)


class OpsConsolidatedBalanceSheet(models.TransientModel):
    """Group-Level Balance Sheet Consolidation"""
    _name = 'ops.consolidated.balance.sheet'
    _description = 'Group-Level Balance Sheet Consolidation'
    
    # Company Selection
    company_ids = fields.Many2many(
        'res.company',
        string='Companies',
        required=True,
        default=lambda self: self.env.company
    )
    
    # Date for balance sheet
    date = fields.Date(
        string='As of Date',
        required=True,
        default=fields.Date.today
    )
    
    # Consolidation Options
    include_intercompany = fields.Boolean(
        string='Include Intercompany Eliminations',
        default=True
    )
    
    currency_id = fields.Many2one(
        'res.currency',
        string='Reporting Currency',
        default=lambda self: self.env.company.currency_id
    )
    
    # Report Data
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    @api.depends('company_ids', 'date', 'include_intercompany', 'currency_id')
    def _compute_report_data(self):
        """Compute consolidated balance sheet for multiple companies."""
        for wizard in self:
            if not wizard.company_ids or not wizard.date:
                wizard.report_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            
            # Get balance sheet data for each company
            company_data = []
            total_assets = total_liabilities = total_equity = 0
            
            for company in wizard.company_ids:
                domain = [
                    ('date', '<=', wizard.date),
                    ('company_id', '=', company.id),
                    ('move_id.state', '=', 'posted'),
                    ('account_id.include_initial_balance', '=', True),
                ]
                
                # Group by account type
                MoveLine._read_group(
                    domain=domain,
                    groupby=['account_id'],
                    aggregates=['balance:sum']
                )
                
                # Initialize totals
                assets = liabilities = equity = income = expense = 0
                
                for group in grouped_data:
                    if group.get('account_id'):
                        account = self.env['account.account'].browse(group['account_id'][0])
                        balance = group.get('balance', 0)
                        
                        if account.account_type and account.account_type.startswith('asset'):
                            assets += balance
                        elif account.account_type and account.account_type.startswith('liability'):
                            liabilities += balance
                        elif account.account_type == 'equity':
                            equity += balance
                        elif account.account_type in ['income', 'income_other']:
                            income += balance
                        elif account.account_type in ['expense', 'expense_depreciation', 'expense_direct_cost']:
                            expense += balance
                
                # Calculate net income/loss for period
                net_income = income + expense  # Expense is negative in accounting
                
                company_data.append({
                    'company_id': company.id,
                    'company_name': company.name,
                    'company_code': company.ops_code if hasattr(company, 'ops_code') else company.name,
                    'assets': assets,
                    'liabilities': liabilities,
                    'equity': equity + net_income,  # Include current year profit/loss
                    'net_income': net_income,
                    'currency': company.currency_id.name,
                })
                
                # Accumulate totals
                total_assets += assets
                total_liabilities += liabilities
                total_equity += equity + net_income
            
            # Apply intercompany eliminations if requested
            eliminations = {'asset_eliminations': 0, 'liability_eliminations': 0}
            if wizard.include_intercompany and len(wizard.company_ids) > 1:
                eliminations = wizard._calculate_intercompany_eliminations(wizard.company_ids.ids, wizard.date)
                total_assets -= eliminations.get('asset_eliminations', 0)
                total_liabilities -= eliminations.get('liability_eliminations', 0)
            
            wizard.report_data = {
                'report_date': str(wizard.date),
                'companies': company_data,
                'consolidated': {
                    'total_assets': total_assets,
                    'total_liabilities': total_liabilities,
                    'total_equity': total_equity,
                    'balance_check': total_assets - (total_liabilities + total_equity),
                },
                'eliminations': eliminations,
                'reporting_currency': wizard.currency_id.name,
                'company_count': len(wizard.company_ids),
            }
    
    def _calculate_intercompany_eliminations(self, company_ids, date):
        """Calculate intercompany eliminations for consolidation."""
        MoveLine = self.env['account.move.line']
        
        # Find intercompany accounts (accounts marked as intercompany)
        intercompany_accounts = self.env['account.account'].search([
            ('company_id', 'in', company_ids),
            ('reconcile', '=', True),  # Use reconcile flag as proxy for intercompany
        ])
        
        asset_eliminations = 0
        liability_eliminations = 0
        
        for account in intercompany_accounts:
            if 'intercompany' not in account.name.lower():
                continue
                
            domain = [
                ('date', '<=', date),
                ('account_id', '=', account.id),
                ('company_id', 'in', company_ids),
                ('move_id.state', '=', 'posted'),
            ]
            
            MoveLine._read_group(
                domain=domain,
                groupby=['company_id'],
                aggregates=['balance:sum']
            )
            
            # Sum balances across companies
            total_balance = sum(item.get('balance', 0) for item in result)
            
            # If total balance across companies is not zero, there's an elimination
            if abs(total_balance) > 0.01:  # Tolerance for floating point
                if account.account_type and account.account_type.startswith('asset'):
                    asset_eliminations += total_balance
                elif account.account_type and account.account_type.startswith('liability'):
                    liability_eliminations += total_balance
        
        return {
            'asset_eliminations': asset_eliminations,
            'liability_eliminations': liability_eliminations,
        }
    
    def action_generate_pdf(self):
        """Generate PDF consolidated balance sheet."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_consolidated_balance_sheet_pdf').report_action(self)


class OpsMatrixProfitabilityAnalysis(models.TransientModel):
    """Matrix Profitability Analysis (Branch x BU)"""
    _name = 'ops.matrix.profitability.analysis'
    _description = 'Matrix Profitability Analysis (Branch x BU)'
    
    # Filter Fields
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # Report Data
    matrix_data = fields.Json(
        string='Matrix Data',
        compute='_compute_matrix_data',
        store=False
    )
    
    @api.depends('company_id', 'date_from', 'date_to')
    def _compute_matrix_data(self):
        """Compute profitability matrix across branches and BUs."""
        for wizard in self:
            if not wizard.company_id or not wizard.date_from or not wizard.date_to:
                wizard.matrix_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            
            # Get all branches and BUs for the company
            branches = self.env['ops.branch'].search([
                ('company_id', '=', wizard.company_id.id),
                ('active', '=', True)
            ])
            
            bus = self.env['ops.business.unit'].search([
                ('company_ids', 'in', [wizard.company_id.id]),
                ('active', '=', True)
            ])
            
            # Initialize matrix
            matrix = {}
            branch_totals = {branch.id: {'income': 0, 'expense': 0} for branch in branches}
            bu_totals = {bu.id: {'income': 0, 'expense': 0} for bu in bus}
            
            # Populate matrix with data
            for branch in branches:
                for bu in bus:
                    key = f"{branch.id}-{bu.id}"
                    
                    # Check if BU operates in this branch
                    if branch in bu.branch_ids:
                        domain = [
                            ('date', '>=', wizard.date_from),
                            ('date', '<=', wizard.date_to),
                            ('ops_branch_id', '=', branch.id),
                            ('ops_business_unit_id', '=', bu.id),
                            ('move_id.state', '=', 'posted'),
                        ]
                        
                        # Get income
                        MoveLine._read_group(
                            domain=domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                            groupby=[],
                            aggregates=['credit:sum', 'debit:sum']
                        )
                        income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
                        
                        # Get expense
                        MoveLine._read_group(
                            domain=domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                            groupby=[],
                            aggregates=['debit:sum', 'credit:sum']
                        )
                        expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
                        
                        net_profit = income - expense
                        
                        matrix[key] = {
                            'branch_id': branch.id,
                            'branch_code': branch.code,
                            'branch_name': branch.name,
                            'bu_id': bu.id,
                            'bu_code': bu.code,
                            'bu_name': bu.name,
                            'income': income,
                            'expense': expense,
                            'net_profit': net_profit,
                            'profitability': (net_profit / income * 100) if income else 0,
                            'transaction_count': MoveLine.search_count(domain),
                        }
                        
                        # Update totals
                        branch_totals[branch.id]['income'] += income
                        branch_totals[branch.id]['expense'] += expense
                        bu_totals[bu.id]['income'] += income
                        bu_totals[bu.id]['expense'] += expense
            
            # Calculate overall totals
            total_income = sum(data['income'] for data in matrix.values())
            total_expense = sum(data['expense'] for data in matrix.values())
            total_net = total_income - total_expense
            
            # Find top performing combinations
            matrix_values = list(matrix.values())
            matrix_values.sort(key=lambda x: x['net_profit'], reverse=True)
            top_performers = matrix_values[:5]
            bottom_performers = matrix_values[-5:] if len(matrix_values) >= 5 else []
            
            wizard.matrix_data = {
                'company': wizard.company_id.name,
                'period': f"{wizard.date_from} to {wizard.date_to}",
                'matrix': matrix_values,
                'branch_totals': branch_totals,
                'bu_totals': bu_totals,
                'summary': {
                    'total_income': total_income,
                    'total_expense': total_expense,
                    'total_net_profit': total_net,
                    'total_combinations': len(matrix),
                    'active_combinations': len([m for m in matrix_values if m['transaction_count'] > 0]),
                    'top_performers': top_performers,
                    'bottom_performers': bottom_performers,
                    'average_profitability': sum(m['profitability'] for m in matrix_values) / len(matrix_values) if matrix_values else 0,
                },
            }
    
    def action_generate_heatmap(self):
        """Generate heatmap visualization data (displays as notification for now)."""
        self.ensure_one()
        
        # Get matrix data summary
        matrix_data = self.matrix_data or {}
        summary = matrix_data.get('summary', {})
        
        # Create user-friendly message
        message = _(
            "Matrix Profitability Analysis Results:\n\n"
            "Total Income: %(income).2f\n"
            "Total Expense: %(expense).2f\n"
            "Total Net Profit: %(profit).2f\n"
            "Active Combinations: %(combinations)d\n"
            "Average Profitability: %(avg_profit).2f%%\n\n"
            "View the detailed data in the wizard form below."
        ) % {
            'income': summary.get('total_income', 0),
            'expense': summary.get('total_expense', 0),
            'profit': summary.get('total_net_profit', 0),
            'combinations': summary.get('active_combinations', 0),
            'avg_profit': summary.get('average_profitability', 0),
        }
        
        # Return action to show notification and keep wizard open
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Matrix Analysis Complete'),
                'message': message,
                'type': 'info',
                'sticky': False,
                'next': {
                    'type': 'ir.actions.act_window_close'
                }
            }
        }

>>> ops_matrix_accounting/models/ops_matrix_standard_extensions.py <<<
from odoo import models, fields, api

class SaleOrder(models.Model):
    _inherit = 'sale.order'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this sale"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this sale belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    def _prepare_invoice(self):
        """Propagate matrix dimensions to created invoice."""
        invoice_vals = super()._prepare_invoice()
        invoice_vals.update({
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
        })
        return invoice_vals


class PurchaseOrder(models.Model):
    _inherit = 'purchase.order'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this purchase"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this purchase belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    def _prepare_invoice(self):
        """Propagate matrix dimensions to created bill."""
        invoice_vals = super()._prepare_invoice()
        invoice_vals.update({
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
        })
        return invoice_vals


class StockPicking(models.Model):
    _inherit = 'stock.picking'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this transfer"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this transfer belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    @api.model_create_multi
    def create(self, vals_list):
        """Inherit matrix dimensions from source document."""
        for vals in vals_list:
            if vals.get('origin'):
                # Try to find source document
                sale_order = self.env['sale.order'].search([('name', '=', vals['origin'])], limit=1)
                if sale_order:
                    vals.update({
                        'ops_branch_id': sale_order.ops_branch_id.id,
                        'ops_business_unit_id': sale_order.ops_business_unit_id.id,
                    })
                    continue

                purchase_order = self.env['purchase.order'].search([('name', '=', vals['origin'])], limit=1)
                if purchase_order:
                    vals.update({
                        'ops_branch_id': purchase_order.ops_branch_id.id,
                        'ops_business_unit_id': purchase_order.ops_business_unit_id.id,
                    })
        
        return super().create(vals_list)


class AccountMove(models.Model):
    _inherit = 'account.move'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this entry"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this entry belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    @api.model_create_multi
    def create(self, vals_list):
        """Ensure matrix dimensions are properly set."""
        moves = super().create(vals_list)
        for move in moves:
            # Propagate dimensions to lines if not already set
            for line in move.line_ids:
                if not line.ops_branch_id:
                    line.ops_branch_id = move.ops_branch_id
                if not line.ops_business_unit_id:
                    line.ops_business_unit_id = move.ops_business_unit_id
        return moves


class AccountMoveLine(models.Model):
    _inherit = 'account.move.line'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch for this journal item"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit for this journal item"
    )
    
    def _get_default_branch(self):
        """Get default branch from move or user or first available"""
        if self.move_id and self.move_id.ops_branch_id:
            return self.move_id.ops_branch_id
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit from move or first available"""
        if self.move_id and self.move_id.ops_business_unit_id:
            return self.move_id.ops_business_unit_id
        return self.env['ops.business.unit'].search([], limit=1)

    @api.model_create_multi
    def create(self, vals_list):
        """Ensure matrix dimensions are inherited from parent move."""
        for vals in vals_list:
            if vals.get('move_id'):
                move = self.env['account.move'].browse(vals['move_id'])
                if not vals.get('ops_branch_id'):
                    vals['ops_branch_id'] = move.ops_branch_id.id
                if not vals.get('ops_business_unit_id'):
                    vals['ops_business_unit_id'] = move.ops_business_unit_id.id
        
        return super().create(vals_list)

>>> ops_matrix_accounting/models/ops_pdc.py <<<
from odoo import models, fields, api
from odoo.exceptions import ValidationError

class OpsPostDatedCheck(models.Model):
    _name = 'ops.pdc'
    _description = 'Post-Dated Check'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'maturity_date desc, id desc'

    name = fields.Char(string='Reference', required=True, readonly=True, default='New')
    partner_id = fields.Many2one('res.partner', string='Partner', required=True)
    date = fields.Date(string='Issue Date', required=True, tracking=True)
    maturity_date = fields.Date(string='Maturity Date', required=True, tracking=True)
    amount = fields.Monetary(string='Amount', required=True)
    currency_id = fields.Many2one('res.currency', string='Currency', required=True, default=lambda self: self.env.company.currency_id)
    
    payment_type = fields.Selection([
        ('inbound', 'Customer'),
        ('outbound', 'Vendor')
    ], string='Payment Type', required=True)
    
    bank_id = fields.Many2one('res.bank', string='Bank', required=True)
    check_number = fields.Char(string='Check Number', required=True)
    
    state = fields.Selection([
        ('draft', 'Draft'),
        ('registered', 'Registered'),
        ('deposited', 'Deposited'),
        ('cleared', 'Cleared'),
        ('bounced', 'Bounced'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', tracking=True)

    # Matrix Dimensions
    ops_branch_id = fields.Many2one('res.company', string='Branch', required=True)
    ops_business_unit_id = fields.Many2one('ops.business.unit', string='Business Unit', required=True)
    
    # Accounting Fields
    journal_id = fields.Many2one('account.journal', string='PDC Journal', required=True, domain=[('type', '=', 'bank')])
    holding_account_id = fields.Many2one('account.account', string='PDC Holding Account', required=True)
    move_id = fields.Many2one('account.move', string='Registration Entry', readonly=True)
    deposit_move_id = fields.Many2one('account.move', string='Deposit Entry', readonly=True)
    
    # Anti-Fraud Security: Button-level authority for PDC management
    can_user_manage_pdc = fields.Boolean(
        compute='_compute_can_user_manage_pdc',
        string='Can Manage PDC',
        help='Technical field: User has authority to manage PDC operations (register, deposit, clear)'
    )
    
    @api.depends_context('uid')
    def _compute_can_user_manage_pdc(self):
        """
        Check if current user has authority to manage PDC operations.
        
        ADMIN BYPASS: System administrators always have access.
        PERSONA LOGIC: Uses additive authority - if ANY persona grants the right, access is granted.
        """
        for record in self:
            # Admin bypass
            if self.env.su or self.env.user.has_group('base.group_system'):
                record.can_user_manage_pdc = True
            else:
                # Check persona authority using the helper method
                record.can_user_manage_pdc = self.env.user.has_ops_authority('can_manage_pdc')

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            if vals.get('name', 'New') == 'New':
                vals['name'] = self.env['ir.sequence'].next_by_code('ops.pdc') or 'PDC/0001'
        return super().create(vals_list)

    @api.constrains('date', 'maturity_date')
    def _check_dates(self):
        for pdc in self:
            if pdc.maturity_date < pdc.date:
                raise ValidationError('Maturity Date cannot be earlier than Issue Date.')

    def _prepare_move_line_vals(self, account_id, debit, credit, name_suffix=''):
        """Helper to prepare consistent move line values with matrix dimensions."""
        return {
            'account_id': account_id,
            'partner_id': self.partner_id.id,
            'name': f'{name_suffix} - {self.check_number}',
            'debit': debit,
            'credit': credit,
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
        }

    def action_register(self):
        """Register the PDC and create initial journal entry."""
        self.ensure_one()
        if self.state != 'draft':
            raise ValidationError('Only draft PDCs can be registered.')

        # Determine accounts based on payment type
        if self.payment_type == 'inbound':
            partner_account = self.partner_id.property_account_receivable_id
            debit_account = self.holding_account_id
            credit_account = partner_account
        else:  # outbound
            partner_account = self.partner_id.property_account_payable_id
            debit_account = partner_account
            credit_account = self.holding_account_id

        move_vals = {
            'journal_id': self.journal_id.id,
            'date': self.date,
            'ref': f'PDC Registration - {self.name}',
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
            'line_ids': [
                (0, 0, self._prepare_move_line_vals(
                    debit_account.id, self.amount, 0.0, 'PDC Holding'
                )),
                (0, 0, self._prepare_move_line_vals(
                    credit_account.id, 0.0, self.amount, 'PDC Registration'
                ))
            ]
        }
        
        move = self.env['account.move'].create(move_vals)
        move.action_post()
        
        self.write({
            'state': 'registered',
            'move_id': move.id
        })

    def action_deposit(self):
        """Deposit the PDC and create bank entry."""
        self.ensure_one()
        if self.state != 'registered':
            raise ValidationError('Only registered PDCs can be deposited.')

        # Get bank account from journal
        if not self.journal_id.default_account_id:
            raise ValidationError('Bank journal must have a default account configured.')

        # Determine accounts based on payment type
        if self.payment_type == 'inbound':
            debit_account = self.journal_id.default_account_id
            credit_account = self.holding_account_id
        else:  # outbound
            debit_account = self.holding_account_id
            credit_account = self.journal_id.default_account_id

        move_vals = {
            'journal_id': self.journal_id.id,
            'date': fields.Date.today(),
            'ref': f'PDC Deposit - {self.name}',
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
            'line_ids': [
                (0, 0, self._prepare_move_line_vals(
                    debit_account.id, self.amount, 0.0, 'PDC Bank Deposit'
                )),
                (0, 0, self._prepare_move_line_vals(
                    credit_account.id, 0.0, self.amount, 'PDC Holding Clearance'
                ))
            ]
        }
        
        move = self.env['account.move'].create(move_vals)
        move.action_post()
        
        self.write({
            'state': 'deposited',
            'deposit_move_id': move.id
        })

>>> ops_matrix_accounting/models/ops_product_category_defaults.py <<<
from odoo import models, fields, api

class OpsProductCategory(models.Model):
    _inherit = 'product.category'

    # Override inventory valuation fields to enforce defaults
    property_cost_method = fields.Selection(
        default='fifo',
        readonly=True,
        help="FIFO costing method enforced by Matrix Operations"
    )
    
    property_valuation = fields.Selection(
        default='real_time',
        readonly=True,
        help="Real-time valuation enforced by Matrix Operations"
    )

    @api.constrains('property_cost_method', 'property_valuation')
    def _check_accounting_fields_not_empty(self):
        """Ensure costing and valuation methods are always set."""
        for record in self:
            if not record.property_cost_method:
                record.property_cost_method = 'fifo'
            if not record.property_valuation:
                record.property_valuation = 'real_time'

    @api.model
    def default_get(self, fields_list):
        """Override to auto-populate accounting fields with smart defaults."""
        defaults = super().default_get(fields_list)
        
        try:
            company = self.env.company
            account_obj = self.env['account.account']

            # Helper function to find accounts - simplified for Odoo 19 compatibility
            def find_account(fallback_type=None):
                if fallback_type:
                    try:
                        account = account_obj.search([
                            ('account_type', '=', fallback_type)
                        ], limit=1)
                        return account.id if account else False
                    except Exception:
                        pass
                return False

            # 1. Income Account (Sales)
            if 'property_account_income_categ_id' in fields_list:
                income_account = find_account(fallback_type='income')
                defaults['property_account_income_categ_id'] = income_account

            # 2. Expense Account (COGS)
            if 'property_account_expense_categ_id' in fields_list:
                expense_account = find_account(fallback_type='expense')
                defaults['property_account_expense_categ_id'] = expense_account

            # 3. Stock Valuation Account
            if 'property_stock_valuation_account_id' in fields_list:
                valuation_account = find_account(fallback_type='asset_current')
                defaults['property_stock_valuation_account_id'] = valuation_account

            # 4. Stock Input Account
            if 'property_stock_account_input_categ_id' in fields_list:
                input_account = find_account(fallback_type='asset_current')
                defaults['property_stock_account_input_categ_id'] = input_account

            # 5. Stock Output Account
            if 'property_stock_account_output_categ_id' in fields_list:
                output_account = find_account(fallback_type='asset_current')
                defaults['property_stock_account_output_categ_id'] = output_account

        except Exception:
            # Gracefully fall back if account lookup fails
            pass

        return defaults


class OpsProductTemplate(models.Model):
    _inherit = 'product.template'

    @api.model
    def default_get(self, fields_list):
        """Ensure products inherit category defaults properly."""
        defaults = super().default_get(fields_list)
        
        # If no category specified, find or create the default category
        if not defaults.get('categ_id'):
            default_category = self.env['product.category'].search([
                ('name', '=', 'All'),
                ('parent_id', '=', False)
            ], limit=1)
            
            if not default_category:
                default_category = self.env['product.category'].create({
                    'name': 'All'
                })
            
            defaults['categ_id'] = default_category.id
        
        return defaults

    @api.onchange('categ_id')
    def _onchange_categ_id(self):
        """Ensure accounting fields are properly inherited from category."""
        if self.categ_id:
            self.property_account_income_id = False  # Force inherit from category
            self.property_account_expense_id = False  # Force inherit from category

>>> ops_matrix_accounting/report/__init__.py <<<
File not found

>>> ops_matrix_accounting/wizard/__init__.py <<<
from . import ops_financial_report_wizard
from . import ops_general_ledger_wizard
from . import ops_general_ledger_wizard_enhanced

>>> ops_matrix_accounting/wizard/__init__.py <<<
from . import ops_financial_report_wizard
from . import ops_general_ledger_wizard
from . import ops_general_ledger_wizard_enhanced

>>> ops_matrix_accounting/wizard/ops_financial_report_wizard.py <<<
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from dateutil.relativedelta import relativedelta
import io
import base64

class OpsFinancialReportWizard(models.TransientModel):
    """
    Lightweight Financial Reporting Wizard for Zero DB Bloat.
    Uses native Odoo views for on-screen analysis and in-memory generation for exports.
    """
    _name = 'ops.financial.report.wizard'
    _description = 'Financial Report Wizard'

    report_type = fields.Selection([
        ('pl', 'P&L'),
        ('bs', 'Balance Sheet'),
        ('gl', 'General Ledger'),
        ('aged', 'Aged Partner')
    ], string='Report Type', required=True, default='gl')
    
    date_from = fields.Date(string='Date From', required=True)
    date_to = fields.Date(string='Date To', required=True)
    
    branch_id = fields.Many2one(
        'ops.branch',
        string='Branch',
        help="Filter by branch (via analytic account)"
    )
    
    target_move = fields.Selection([
        ('posted', 'Posted Only'),
        ('all', 'All')
    ], string='Target Moves', default='posted', required=True)
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    
    journal_ids = fields.Many2many(
        'account.journal',
        string='Journals',
        help='Leave empty to include all journals'
    )

    @api.model
    def default_get(self, fields_list):
        """Set default date range to current month."""
        res = super().default_get(fields_list)
        
        today = fields.Date.context_today(self)
        first_day = today.replace(day=1)
        last_day = (first_day + relativedelta(months=1, days=-1))
        
        if 'date_from' in fields_list:
            res['date_from'] = first_day
        if 'date_to' in fields_list:
            res['date_to'] = last_day
        
        return res

    def _get_domain(self):
        """Build domain for account.move.line based on wizard filters."""
        self.ensure_one()
        
        domain = [
            ('date', '>=', self.date_from),
            ('date', '<=', self.date_to),
            ('company_id', '=', self.company_id.id),
        ]
        
        # Filter by move state
        if self.target_move == 'posted':
            domain.append(('move_id.state', '=', 'posted'))
        
        # Filter by branch (via ops_branch_id field)
        # Note: In Odoo 19, analytic_account_id is not available on account.move.line
        # We use ops_branch_id field added by ops_matrix_core module
        if self.branch_id:
            domain.append(('ops_branch_id', '=', self.branch_id.id))
        
        # Filter by journals if specified
        if self.journal_ids:
            domain.append(('journal_id', 'in', self.journal_ids.ids))
        
        return domain

    def _get_context_groupings(self):
        """Return default groupings based on report type."""
        self.ensure_one()
        
        context = {}
        
        if self.report_type == 'pl':
            # P&L: Group by account type (Income/Expense)
            context.update({
                'pivot_row_groupby': ['account_id'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        elif self.report_type == 'bs':
            # Balance Sheet: Group by account type (Asset/Liability)
            context.update({
                'pivot_row_groupby': ['account_id'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        elif self.report_type == 'gl':
            # General Ledger: Group by account and date
            context.update({
                'pivot_row_groupby': ['account_id', 'date'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        elif self.report_type == 'aged':
            # Aged Partner: Group by partner
            context.update({
                'pivot_row_groupby': ['partner_id'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        
        return context

    def action_view_data(self):
        """
        Open account.move.line in pivot/tree view with filters applied.
        NO intermediate records created - Zero DB Bloat approach.
        """
        self.ensure_one()
        
        domain = self._get_domain()
        context = self._get_context_groupings()
        
        return {
            'name': _('%s - On-Screen Analysis') % dict(self._fields['report_type'].selection).get(self.report_type),
            'type': 'ir.actions.act_window',
            'res_model': 'account.move.line',
            'view_mode': 'pivot,tree',
            'views': [(False, 'pivot'), (False, 'tree')],
            'domain': domain,
            'context': context,
            'target': 'current',
        }

    def action_print_pdf(self):
        """Generate PDF report using AbstractModel parser (in-memory processing)."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.action_report_ops_financial').report_action(self)

    def action_export_xlsx(self):
        """Export to Excel using in-memory generation."""
        self.ensure_one()
        
        # Get the report parser (must match parser _name)
        report_parser = self.env['report.ops_matrix_accounting.report_ops_financial_document']
        report_data = report_parser._get_report_data(self)
        
        # Generate XLSX file
        try:
            import xlsxwriter
            output = io.BytesIO()
            workbook = xlsxwriter.Workbook(output, {'in_memory': True})
            worksheet = workbook.add_worksheet(report_data['title'])
            
            # Formats
            header_format = workbook.add_format({
                'bold': True,
                'bg_color': '#D3D3D3',
                'border': 1
            })
            
            # Write headers
            col = 0
            for header in report_data['headers']:
                worksheet.write(0, col, header, header_format)
                col += 1
            
            # Write data
            row = 1
            for line in report_data['lines']:
                col = 0
                for value in line.values():
                    worksheet.write(row, col, value)
                    col += 1
                row += 1
            
            workbook.close()
            output.seek(0)
            
            # Create attachment
            filename = f"{report_data['title']}_{self.date_from}_{self.date_to}.xlsx"
            attachment = self.env['ir.attachment'].create({
                'name': filename,
                'type': 'binary',
                'datas': base64.b64encode(output.read()),
                'mimetype': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            })
            
            return {
                'type': 'ir.actions.act_url',
                'url': f'/web/content/{attachment.id}?download=true',
                'target': 'new',
            }
            
        except ImportError:
            raise UserError(_('xlsxwriter library is not installed. Please install it to export to Excel.'))

>>> ops_matrix_accounting/wizard/ops_general_ledger_wizard.py <<<
from odoo import models, fields, api

class OpsGeneralLedgerWizard(models.TransientModel):
    _name = 'ops.general.ledger.wizard'
    _inherit = 'ops.financial.report.wizard'
    _description = 'General Ledger Report Wizard'

    account_ids = fields.Many2many('account.account', string='Accounts', 
                                     help='Leave empty to include all accounts')

    def action_print_pdf(self):
        self.ensure_one()
        data = {
            'date_from': self.date_from,
            'date_to': self.date_to,
            'target_move': self.target_move,
            'journal_ids': self.journal_ids.ids,
            'account_ids': self.account_ids.ids if self.account_ids else [],
            'company_id': self.company_id.id,
        }
        return self.env.ref('ops_matrix_accounting.action_report_general_ledger').report_action(self, data=data)

>>> ops_matrix_accounting/wizard/ops_general_ledger_wizard_enhanced.py <<<
# -*- coding: utf-8 -*-
"""
OPS Matrix Accounting - Enhanced General Ledger Wizard
======================================================

Comprehensive General Ledger wizard with matrix dimension filtering
(Branch and Business Unit) and advanced consolidation options.

Author: OPS Matrix Framework
"""

from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
from odoo.tools import date_utils, float_round
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)


class OpsGeneralLedgerWizardEnhanced(models.TransientModel):
    """Enhanced General Ledger Report Wizard with Matrix Dimensions"""
    _name = 'ops.general.ledger.wizard.enhanced'
    _description = 'General Ledger Report Wizard with Matrix Dimensions'
    
    # ============================================
    # 1. PERIOD FILTERS
    # ============================================
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'year')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # ============================================
    # 2. COMPANY & JOURNALS
    # ============================================
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    journal_ids = fields.Many2many(
        'account.journal',
        string='Journals',
        help='Leave empty for all journals'
    )
    
    # ============================================
    # 3. MATRIX DIMENSION FILTERS
    # ============================================
    
    # Branch Filter
    branch_ids = fields.Many2many(
        'ops.branch',
        'gl_wizard_branch_rel',
        'wizard_id',
        'branch_id',
        string='Branches',
        help='Filter by specific branches. Leave empty for all branches.'
    )
    
    # Business Unit Filter
    business_unit_ids = fields.Many2many(
        'ops.business.unit',
        'gl_wizard_bu_rel',
        'wizard_id',
        'bu_id',
        string='Business Units',
        help='Filter by specific business units. Leave empty for all BUs.'
    )
    
    # Matrix Combination Mode
    matrix_filter_mode = fields.Selection([
        ('any', 'Any Dimension (Branch OR BU)'),
        ('both', 'Both Dimensions (Branch AND BU)'),
        ('exact', 'Exact Combination'),
    ], string='Matrix Filter Mode', default='any', help="""
        - Any: Show transactions that match ANY selected branch/BU
        - Both: Show transactions that match BOTH selected branch AND BU
        - Exact: Show transactions with exact branch/BU combinations
    """)
    
    # ============================================
    # 4. ACCOUNT FILTERS
    # ============================================
    account_ids = fields.Many2many(
        'account.account',
        'gl_wizard_account_rel',
        'wizard_id',
        'account_id',
        string='Accounts',
        help='Filter by specific accounts. Leave empty for all accounts.'
    )
    
    account_type_ids = fields.Selection(
        selection=[
            ('asset_receivable', 'Receivable'),
            ('asset_cash', 'Bank and Cash'),
            ('asset_current', 'Current Assets'),
            ('asset_non_current', 'Non-current Assets'),
            ('asset_prepayments', 'Prepayments'),
            ('asset_fixed', 'Fixed Assets'),
            ('liability_payable', 'Payable'),
            ('liability_credit_card', 'Credit Card'),
            ('liability_current', 'Current Liabilities'),
            ('liability_non_current', 'Non-current Liabilities'),
            ('equity', 'Equity'),
            ('equity_unaffected', 'Current Year Earnings'),
            ('income', 'Income'),
            ('income_other', 'Other Income'),
            ('expense', 'Expenses'),
            ('expense_depreciation', 'Depreciation'),
            ('expense_direct_cost', 'Cost of Revenue'),
            ('off_balance', 'Off-Balance Sheet'),
        ],
        string='Account Type',
        help='Filter by specific account type'
    )
    
    display_account = fields.Selection([
        ('all', 'All Accounts'),
        ('movement', 'With Movements'),
        ('not_zero', 'With Balance Not Zero'),
    ], string='Display Accounts', default='movement', required=True)
    
    # ============================================
    # 5. TRANSACTION FILTERS
    # ============================================
    target_move = fields.Selection([
        ('posted', 'Posted Entries'),
        ('all', 'All Entries'),
    ], string='Target Moves', default='posted', required=True)
    
    reconciled = fields.Selection([
        ('all', 'All Items'),
        ('reconciled', 'Reconciled Only'),
        ('unreconciled', 'Unreconciled Only'),
    ], string='Reconciliation Status', default='all', required=True)
    
    # Partner Filter
    partner_ids = fields.Many2many(
        'res.partner',
        'gl_wizard_partner_rel',
        'wizard_id',
        'partner_id',
        string='Partners',
        help='Filter by specific partners'
    )
    
    # ============================================
    # 6. CONSOLIDATION & GROUPING OPTIONS
    # ============================================
    consolidate_by_branch = fields.Boolean(
        string='Consolidate by Branch',
        help='Show totals grouped by branch',
        default=False
    )
    
    consolidate_by_bu = fields.Boolean(
        string='Consolidate by Business Unit',
        help='Show totals grouped by business unit',
        default=False
    )
    
    consolidate_by_partner = fields.Boolean(
        string='Consolidate by Partner',
        help='Show totals grouped by partner',
        default=False
    )
    
    group_by_date = fields.Selection([
        ('none', 'No Grouping'),
        ('day', 'Daily'),
        ('week', 'Weekly'),
        ('month', 'Monthly'),
        ('quarter', 'Quarterly'),
        ('year', 'Yearly'),
    ], string='Group by Date', default='none', required=True)
    
    # ============================================
    # 7. OUTPUT OPTIONS
    # ============================================
    report_format = fields.Selection([
        ('detailed', 'Detailed Lines'),
        ('summary', 'Summary Only'),
        ('both', 'Both Detailed and Summary'),
    ], string='Report Format', default='detailed', required=True)
    
    sort_by = fields.Selection([
        ('date', 'Date'),
        ('account', 'Account'),
        ('partner', 'Partner'),
        ('branch', 'Branch'),
        ('bu', 'Business Unit'),
    ], string='Sort By', default='date', required=True)
    
    include_initial_balance = fields.Boolean(
        string='Include Initial Balance',
        default=True,
        help='Show opening balance before period'
    )
    
    # ============================================
    # 8. COMPUTED FIELDS
    # ============================================
    filter_summary = fields.Char(
        compute='_compute_filter_summary',
        string='Filter Summary',
        help='Summary of active filters'
    )
    
    record_count = fields.Integer(
        compute='_compute_record_count',
        string='Estimated Records',
        help='Estimated number of records matching filters'
    )
    
    # ============================================
    # COMPUTED METHODS
    # ============================================
    
    @api.depends('branch_ids', 'business_unit_ids', 'account_ids', 'journal_ids', 
                 'date_from', 'date_to', 'target_move', 'reconciled', 'partner_ids')
    def _compute_filter_summary(self):
        """Compute human-readable summary of active filters."""
        for wizard in self:
            parts = []
            
            # Date range
            if wizard.date_from and wizard.date_to:
                parts.append(f"Period: {wizard.date_from} to {wizard.date_to}")
            
            # Matrix dimensions
            if wizard.branch_ids:
                if len(wizard.branch_ids) <= 3:
                    branch_names = wizard.branch_ids.mapped('code')
                    parts.append(f"Branches: {', '.join(branch_names)}")
                else:
                    parts.append(f"Branches: {len(wizard.branch_ids)} selected")
            
            if wizard.business_unit_ids:
                if len(wizard.business_unit_ids) <= 3:
                    bu_names = wizard.business_unit_ids.mapped('code')
                    parts.append(f"BUs: {', '.join(bu_names)}")
                else:
                    parts.append(f"BUs: {len(wizard.business_unit_ids)} selected")
            
            # Accounts and journals
            if wizard.account_ids:
                parts.append(f"Accounts: {len(wizard.account_ids)} selected")
            
            if wizard.journal_ids:
                parts.append(f"Journals: {len(wizard.journal_ids)} selected")
            
            # Partners
            if wizard.partner_ids:
                parts.append(f"Partners: {len(wizard.partner_ids)} selected")
            
            # Transaction filters
            if wizard.target_move == 'posted':
                parts.append("Posted only")
            
            if wizard.reconciled == 'unreconciled':
                parts.append("Unreconciled")
            elif wizard.reconciled == 'reconciled':
                parts.append("Reconciled")
            
            wizard.filter_summary = " | ".join(parts) if parts else "No filters applied"
    
    @api.depends('date_from', 'date_to', 'company_id', 'branch_ids', 'business_unit_ids', 
                 'account_ids', 'target_move', 'journal_ids', 'partner_ids')
    def _compute_record_count(self):
        """Estimate number of records matching current filters."""
        for wizard in self:
            if not wizard.date_from or not wizard.date_to:
                wizard.record_count = 0
                continue
            
            try:
                # Build domain
                domain = wizard._build_domain()
                
                # Count records
                count = self.env['account.move.line'].search_count(domain)
                wizard.record_count = count
            except Exception as e:
                _logger.error(f"Error counting records: {e}")
                wizard.record_count = 0
    
    # ============================================
    # DOMAIN BUILDING METHODS
    # ============================================
    
    def _build_domain(self):
        """Build complete domain for account move line query."""
        self.ensure_one()
        
        domain = [
            ('date', '>=', self.date_from),
            ('date', '<=', self.date_to),
            ('company_id', '=', self.company_id.id),
        ]
        
        # Target moves filter
        if self.target_move == 'posted':
            domain.append(('move_id.state', '=', 'posted'))
        
        # Reconciliation filter
        if self.reconciled == 'unreconciled':
            domain.append(('reconciled', '=', False))
        elif self.reconciled == 'reconciled':
            domain.append(('reconciled', '=', True))
        
        # Account filters
        if self.account_ids:
            domain.append(('account_id', 'in', self.account_ids.ids))
        
        if self.account_type_ids:
            # Note: account.account uses 'company_ids' (Many2many) not 'company_id'
            account_ids = self.env['account.account'].search([
                ('account_type', '=', self.account_type_ids),
                ('company_ids', 'in', [self.company_id.id])
            ])
            domain.append(('account_id', 'in', account_ids.ids))
        
        # Journal filters
        if self.journal_ids:
            domain.append(('journal_id', 'in', self.journal_ids.ids))
        
        # Partner filter
        if self.partner_ids:
            domain.append(('partner_id', 'in', self.partner_ids.ids))
        
        # Matrix dimension filters
        matrix_domain = self._build_matrix_domain()
        if matrix_domain:
            domain += matrix_domain
        
        return domain
    
    def _build_matrix_domain(self):
        """Build matrix dimension domain based on filter mode."""
        matrix_domain = []
        
        # If no matrix filters, return empty
        if not self.branch_ids and not self.business_unit_ids:
            return matrix_domain
        
        # Build branch domain
        branch_domain = []
        if self.branch_ids:
            branch_domain = [('ops_branch_id', 'in', self.branch_ids.ids)]
        
        # Build BU domain
        bu_domain = []
        if self.business_unit_ids:
            bu_domain = [('ops_business_unit_id', 'in', self.business_unit_ids.ids)]
        
        # Apply filter mode
        if self.matrix_filter_mode == 'any':
            # OR condition: Branch OR BU
            if branch_domain and bu_domain:
                matrix_domain = ['|'] + branch_domain + bu_domain
            elif branch_domain:
                matrix_domain = branch_domain
            elif bu_domain:
                matrix_domain = bu_domain
        
        elif self.matrix_filter_mode == 'both':
            # AND condition: Branch AND BU
            if branch_domain and bu_domain:
                matrix_domain = branch_domain + bu_domain
            else:
                # If only one dimension selected in "both" mode, treat as "any"
                matrix_domain = branch_domain or bu_domain
        
        elif self.matrix_filter_mode == 'exact':
            # Exact combinations: apply both filters, post-filter in Python
            matrix_domain = []
            if branch_domain:
                matrix_domain += branch_domain
            if bu_domain:
                matrix_domain += bu_domain
        
        return matrix_domain
    
    def _get_exact_matrix_combinations(self):
        """Get list of exact branch-BU combinations for exact filter mode."""
        combinations = set()
        if self.branch_ids and self.business_unit_ids:
            for branch in self.branch_ids:
                for bu in self.business_unit_ids:
                    # Check if BU actually operates in this branch
                    if branch in bu.branch_ids:
                        combinations.add((branch.id, bu.id))
        return combinations
    
    # ============================================
    # VALIDATION METHODS
    # ============================================
    
    def _validate_filters(self):
        """Validate wizard filters before generating report."""
        self.ensure_one()
        
        if self.date_from > self.date_to:
            raise ValidationError(_("From date cannot be after To date."))
        
        # Check matrix filter logic
        if self.matrix_filter_mode == 'exact' and (not self.branch_ids or not self.business_unit_ids):
            raise ValidationError(_(
                "Exact combination mode requires both Branch and Business Unit filters."
            ))
        
        # Check for very large date ranges
        date_diff = (self.date_to - self.date_from).days
        if date_diff > 365 and self.report_format == 'detailed' and not self.account_ids:
            return {
                'warning': {
                    'title': _('Large Date Range'),
                    'message': _(
                        'You are generating a detailed report for more than 1 year without account filter. '
                        'This may take a long time. Consider using summary format or filtering by accounts.'
                    ),
                }
            }
        
        # Check for large result sets
        if self.record_count > 50000 and self.report_format == 'detailed':
            return {
                'warning': {
                    'title': _('Large Result Set'),
                    'message': _(
                        'This filter will return approximately %(count)d records. '
                        'Consider using summary format or applying additional filters.'
                    ) % {'count': self.record_count},
                }
            }
        
        return True
    
    # ============================================
    # REPORT GENERATION METHODS
    # ============================================
    
    def action_generate_report(self):
        """Generate the general ledger report with matrix filters."""
        self.ensure_one()
        
        # Validate filters
        validation_result = self._validate_filters()
        if isinstance(validation_result, dict) and 'warning' in validation_result:
            # Return warning but allow user to proceed
            pass
        
        # Generate report data
        report_data = self._prepare_report_data()
        
        # Return report action
        return self._return_report_action(report_data)
    
    def _prepare_report_data(self):
        """Prepare complete report data."""
        self.ensure_one()
        
        domain = self._build_domain()
        MoveLine = self.env['account.move.line']
        
        # Get initial balances if requested
        initial_balances = {}
        if self.include_initial_balance:
            initial_balances = self._get_initial_balances()
        
        # Get move lines
        order_by = self._get_sort_order()
        lines = MoveLine.search(domain, order=order_by)
        
        # Apply exact matrix filtering if needed
        if self.matrix_filter_mode == 'exact' and self.branch_ids and self.business_unit_ids:
            exact_combinations = self._get_exact_matrix_combinations()
            lines = lines.filtered(
                lambda l: (l.ops_branch_id.id, l.ops_business_unit_id.id) in exact_combinations
            )
        
        # Process lines based on report format
        if self.report_format == 'summary':
            processed_data = self._process_summary_data(lines)
        elif self.report_format == 'detailed':
            processed_data = self._process_detailed_data(lines)
        else:  # both
            processed_data = {
                'summary': self._process_summary_data(lines),
                'detailed': self._process_detailed_data(lines),
            }
        
        # Prepare final report data
        report_data = {
            'wizard_id': self.id,
            'company_name': self.company_id.name,
            'company_currency': self.company_id.currency_id.name,
            'date_from': str(self.date_from),
            'date_to': str(self.date_to),
            'filters': self._get_filter_summary_dict(),
            'initial_balances': initial_balances,
            'data': processed_data,
            'report_format': self.report_format,
            'totals': {
                'total_debit': sum(line.debit for line in lines),
                'total_credit': sum(line.credit for line in lines),
                'total_balance': sum(line.balance for line in lines),
                'line_count': len(lines),
            },
        }
        
        return report_data
    
    def _get_initial_balances(self):
        """Get initial balances for accounts before the period."""
        self.ensure_one()
        
        MoveLine = self.env['account.move.line']
        
        # Build domain for transactions before period
        domain = [
            ('date', '<', self.date_from),
            ('company_id', '=', self.company_id.id),
            ('move_id.state', '=', 'posted'),
        ]
        
        # Apply same filters as main report
        if self.account_ids:
            domain.append(('account_id', 'in', self.account_ids.ids))
        if self.journal_ids:
            domain.append(('journal_id', 'in', self.journal_ids.ids))
        if self.partner_ids:
            domain.append(('partner_id', 'in', self.partner_ids.ids))
        
        # Matrix filters
        matrix_domain = self._build_matrix_domain()
        if matrix_domain:
            domain += matrix_domain
        
        # Group by account (and other dimensions if consolidating)
        groupby_fields = ['account_id']
        if self.consolidate_by_branch and self.branch_ids:
            groupby_fields.append('ops_branch_id')
        if self.consolidate_by_bu and self.business_unit_ids:
            groupby_fields.append('ops_business_unit_id')
        if self.consolidate_by_partner and self.partner_ids:
            groupby_fields.append('partner_id')
        
        # Aggregate initial balances
        _read_group(
            domain=domain,
            groupby=groupby_fields,
            aggregates=['debit:sum', 'credit:sum', 'balance:sum']
        )
        
        # Process into dictionary
        balances = {}
        for item in initial_data:
            key = tuple(item.get(field, False) for field in groupby_fields)
            balances[key] = {
                'debit': item.get('debit', 0),
                'credit': item.get('credit', 0),
                'balance': item.get('balance', 0),
            }
        
        return balances
    
    def _process_summary_data(self, lines):
        """Process lines into summary format with grouping."""
        self.ensure_one()
        
        # Determine grouping
        groupby_fields = ['account_id']
        if self.consolidate_by_branch:
            groupby_fields.append('ops_branch_id')
        if self.consolidate_by_bu:
            groupby_fields.append('ops_business_unit_id')
        if self.consolidate_by_partner:
            groupby_fields.append('partner_id')
        
        # Group data
        grouped_data = {}
        for line in lines:
            # Create group key
            key_parts = []
            key_parts.append(line.account_id.id)
            if self.consolidate_by_branch:
                key_parts.append(line.ops_branch_id.id if line.ops_branch_id else False)
            if self.consolidate_by_bu:
                key_parts.append(line.ops_business_unit_id.id if line.ops_business_unit_id else False)
            if self.consolidate_by_partner:
                key_parts.append(line.partner_id.id if line.partner_id else False)
            
            key = tuple(key_parts)
            
            if key not in grouped_data:
                grouped_data[key] = {
                    'account_id': line.account_id.id,
                    'account_code': line.account_id.code,
                    'account_name': line.account_id.name,
                    'debit': 0,
                    'credit': 0,
                    'balance': 0,
                    'count': 0,
                }
                
                if self.consolidate_by_branch:
                    grouped_data[key]['branch_id'] = line.ops_branch_id.id if line.ops_branch_id else False
                    grouped_data[key]['branch_name'] = line.ops_branch_id.name if line.ops_branch_id else ''
                if self.consolidate_by_bu:
                    grouped_data[key]['bu_id'] = line.ops_business_unit_id.id if line.ops_business_unit_id else False
                    grouped_data[key]['bu_name'] = line.ops_business_unit_id.name if line.ops_business_unit_id else ''
                if self.consolidate_by_partner:
                    grouped_data[key]['partner_id'] = line.partner_id.id if line.partner_id else False
                    grouped_data[key]['partner_name'] = line.partner_id.name if line.partner_id else ''
            
            grouped_data[key]['debit'] += line.debit
            grouped_data[key]['credit'] += line.credit
            grouped_data[key]['balance'] += line.balance
            grouped_data[key]['count'] += 1
        
        return list(grouped_data.values())
    
    def _process_detailed_data(self, lines):
        """Process lines into detailed format."""
        self.ensure_one()
        
        detailed_data = []
        running_balance = 0
        
        for line in lines:
            running_balance += line.balance
            
            detailed_data.append({
                'id': line.id,
                'date': str(line.date),
                'move_id': line.move_id.id,
                'move_name': line.move_id.name,
                'journal_code': line.journal_id.code,
                'account_code': line.account_id.code,
                'account_name': line.account_id.name,
                'partner_name': line.partner_id.name if line.partner_id else '',
                'branch_code': line.ops_branch_id.code if line.ops_branch_id else '',
                'branch_name': line.ops_branch_id.name if line.ops_branch_id else '',
                'bu_code': line.ops_business_unit_id.code if line.ops_business_unit_id else '',
                'bu_name': line.ops_business_unit_id.name if line.ops_business_unit_id else '',
                'name': line.name,
                'ref': line.ref or '',
                'debit': line.debit,
                'credit': line.credit,
                'balance': line.balance,
                'running_balance': running_balance,
                'reconciled': line.reconciled,
                'currency_id': line.currency_id.name if line.currency_id else '',
                'amount_currency': line.amount_currency,
            })
        
        return detailed_data
    
    def _get_sort_order(self):
        """Get sort order based on wizard selection."""
        sort_mapping = {
            'date': 'date, move_id, id',
            'account': 'account_id, date, id',
            'partner': 'partner_id, date, id',
            'branch': 'ops_branch_id, date, id',
            'bu': 'ops_business_unit_id, date, id',
        }
        return sort_mapping.get(self.sort_by, 'date, move_id, id')
    
    def _get_filter_summary_dict(self):
        """Get filter summary as dictionary for report."""
        return {
            'branch_count': len(self.branch_ids),
            'branch_names': self.branch_ids.mapped('name') if self.branch_ids else [],
            'bu_count': len(self.business_unit_ids),
            'bu_names': self.business_unit_ids.mapped('name') if self.business_unit_ids else [],
            'account_count': len(self.account_ids),
            'journal_count': len(self.journal_ids),
            'partner_count': len(self.partner_ids),
            'date_range': f"{self.date_from} to {self.date_to}",
            'target_move': self.target_move,
            'reconciled': self.reconciled,
            'matrix_filter_mode': self.matrix_filter_mode,
            'consolidate_by_branch': self.consolidate_by_branch,
            'consolidate_by_bu': self.consolidate_by_bu,
            'consolidate_by_partner': self.consolidate_by_partner,
            'group_by_date': self.group_by_date,
            'display_account': self.display_account,
            'include_initial_balance': self.include_initial_balance,
        }
    
    def _return_report_action(self, data):
        """Return appropriate report action."""
        return {
            'type': 'ir.actions.report',
            'report_name': 'ops_matrix_accounting.report_general_ledger_matrix',
            'report_type': 'qweb-pdf',
            'data': data,
            'config': False,
        }
    
    # ============================================
    # ACTION METHODS
    # ============================================
    
    def action_export_to_excel(self):
        """Export report to Excel format."""
        self.ensure_one()
        
        # Prepare report data
        report_data = self._prepare_report_data()
        
        return {
            'type': 'ir.actions.report',
            'report_name': 'ops_matrix_accounting.report_general_ledger_matrix_xlsx',
            'report_type': 'xlsx',
            'data': report_data,
            'config': False,
        }
    
    def action_view_transactions(self):
        """Open filtered journal entries in tree view."""
        self.ensure_one()
        
        domain = self._build_domain()
        
        # Get move IDs
        lines = self.env['account.move.line'].search(domain)
        
        # Apply exact matrix filtering if needed
        if self.matrix_filter_mode == 'exact' and self.branch_ids and self.business_unit_ids:
            exact_combinations = self._get_exact_matrix_combinations()
            lines = lines.filtered(
                lambda l: (l.ops_branch_id.id, l.ops_business_unit_id.id) in exact_combinations
            )
        
        move_ids = lines.mapped('move_id').ids
        
        return {
            'name': _('Journal Entries'),
            'type': 'ir.actions.act_window',
            'res_model': 'account.move',
            'view_mode': 'tree,form',
            'domain': [('id', 'in', move_ids)],
            'context': {
                'search_default_group_by_date': 1 if self.group_by_date != 'none' else 0,
            },
        }
    
    def action_view_account_moves(self):
        """View moves for specific account (called from report)."""
        self.ensure_one()
        
        account_id = self.env.context.get('account_id')
        if not account_id:
            raise UserError(_("No account specified"))
        
        domain = self._build_domain()
        domain.append(('account_id', '=', account_id))
        
        return {
            'name': _('Account Moves'),
            'type': 'ir.actions.act_window',
            'res_model': 'account.move.line',
            'view_mode': 'tree,form',
            'domain': domain,
        }
    
    # ============================================
    # ONCHANGE METHODS
    # ============================================
    
    @api.onchange('company_id')
    def _onchange_company_id(self):
        """Reset filters when company changes."""
        if self.company_id:
            self.branch_ids = False
            self.business_unit_ids = False
            self.account_ids = False
            self.journal_ids = False
            self.partner_ids = False
    
    @api.onchange('branch_ids')
    def _onchange_branch_ids(self):
        """Update BU domain when branches change."""
        if self.branch_ids:
            return {
                'domain': {
                    'business_unit_ids': [('branch_ids', 'in', self.branch_ids.ids)]
                }
            }
        return {}
    
    @api.onchange('business_unit_ids')
    def _onchange_business_unit_ids(self):
        """Update branch domain when BUs change."""
        if self.business_unit_ids:
            branch_ids = self.business_unit_ids.mapped('branch_ids').ids
            return {
                'domain': {
                    'branch_ids': [('id', 'in', branch_ids)]
                }
            }
        return {}
    
    @api.onchange('report_format')
    def _onchange_report_format(self):
        """Adjust options based on report format."""
        if self.report_format == 'summary':
            # Enable consolidation for summary
            if not any([self.consolidate_by_branch, self.consolidate_by_bu, self.consolidate_by_partner]):
                self.consolidate_by_branch = bool(self.branch_ids)
                self.consolidate_by_bu = bool(self.business_unit_ids)

>>> ops_matrix_accounting/views/ops_accounting_menus.xml <<<
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Rename the standard Invoicing menu to "Accounting" -->
    <record id="account.menu_finance" model="ir.ui.menu">
        <field name="name">Accounting</field>
    </record>

    <!-- Create OPS Accounting submenu structure -->
    <menuitem id="menu_ops_accounting_root" name="OPS Accounting" parent="account.menu_finance" sequence="100"/>
    <menuitem id="menu_ops_accounting_reports" name="Financial Reports" parent="menu_ops_accounting_root" sequence="10"/>
</odoo>

>>> ops_matrix_accounting/views/ops_budget_views.xml <<<
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- List View -->
    <record id="view_ops_budget_tree" model="ir.ui.view">
        <field name="name">ops.budget.list</field>
        <field name="model">ops.budget</field>
        <field name="arch" type="xml">
            <list string="Budgets" decoration-info="state == 'draft'" decoration-success="state == 'confirmed'" decoration-muted="state == 'done'">
                <field name="name"/>
                <field name="ops_branch_id"/>
                <field name="ops_business_unit_id"/>
                <field name="date_from"/>
                <field name="date_to"/>
                <field name="total_planned"/>
                <field name="total_practical"/>
                <field name="total_committed"/>
                <field name="available_balance"/>
                <field name="currency_id" invisible="1"/>
                <field name="state"/>
            </list>
        </field>
    </record>

    <!-- Form View -->
    <record id="view_ops_budget_form" model="ir.ui.view">
        <field name="name">ops.budget.form</field>
        <field name="model">ops.budget</field>
        <field name="arch" type="xml">
            <form string="Budget">
                <header>
                    <button name="action_confirm"
                            string="Confirm"
                            type="object"
                            icon="fa-check"
                            class="oe_highlight"/>
                    <button name="action_done"
                            string="Close"
                            type="object"
                            icon="fa-lock"/>
                    <button name="action_draft"
                            string="Reset to Draft"
                            type="object"
                            icon="fa-undo"/>
                    <field name="state" widget="statusbar"/>
                </header>
                <sheet>
                    <div class="oe_title">
                        <h1>
                            <field name="name" placeholder="e.g. 2024 Q1 Marketing Budget"/>
                        </h1>
                    </div>
                    <group col="4">
                        <group colspan="2">
                            <field name="ops_branch_id"/>
                            <field name="ops_business_unit_id"/>
                            <field name="currency_id" groups="base.group_multi_currency"/>
                        </group>
                        <group colspan="2">
                            <field name="date_from"/>
                            <field name="date_to"/>
                            <field name="active" invisible="1"/>
                        </group>
                    </group>
                    <notebook>
                        <page string="Budget Lines" name="budget_lines">
                            <field name="line_ids" widget="section_and_note_one2many">
                                <list editable="bottom">
                                    <field name="general_account_id"/>
                                    <field name="planned_amount"/>
                                    <field name="practical_amount"/>
                                    <field name="committed_amount"/>
                                    <field name="available_amount"/>
                                    <field name="currency_id" invisible="1"/>
                                </list>
                            </field>
                            <group class="oe_subtotal_footer oe_right" colspan="2">
                                <field name="total_planned" widget="monetary"/>
                                <field name="total_practical" widget="monetary"/>
                                <field name="total_committed" widget="monetary"/>
                                <field name="available_balance" class="oe_subtotal_footer_separator" widget="monetary"/>
                            </group>
                        </page>
                    </notebook>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids"/>
                    <field name="activity_ids"/>
                    <field name="message_ids"/>
                </div>
            </form>
        </field>
    </record>

    <!-- Search View -->
    <record id="view_ops_budget_search" model="ir.ui.view">
        <field name="name">ops.budget.search</field>
        <field name="model">ops.budget</field>
        <field name="arch" type="xml">
            <search>
                <field name="name"/>
                <field name="ops_branch_id"/>
                <field name="ops_business_unit_id"/>
                <separator/>
                <filter string="Draft" name="draft" domain="[('state', '=', 'draft')]"/>
                <filter string="Confirmed" name="confirmed" domain="[('state', '=', 'confirmed')]"/>
                <filter string="Done" name="done" domain="[('state', '=', 'done')]"/>
                <separator/>
                <filter string="Active" name="active" domain="[('active', '=', True)]"/>
                <filter string="Branch" name="group_by_branch" context="{'group_by': 'ops_branch_id'}"/>
                <filter string="Business Unit" name="group_by_bu" context="{'group_by': 'ops_business_unit_id'}"/>
                <filter string="Status" name="group_by_state" context="{'group_by': 'state'}"/>
            </search>
        </field>
    </record>

    <!-- Action -->
    <record id="action_ops_budget" model="ir.actions.act_window">
        <field name="name">Budget Control</field>
        <field name="res_model">ops.budget</field>
        <field name="view_mode">list,form</field>
        <field name="search_view_id" ref="view_ops_budget_search"/>
        <field name="context">{'search_default_active': 1}</field>
        <field name="help" type="html">
            <p class="o_view_nocontent_smiling_face">
                Create your first budget!
            </p>
            <p>
                A budget helps you control expenses by setting planned amounts
                for each expense account within a specific branch and business unit.
            </p>
        </field>
    </record>

    <!-- Menu Item -->
    <menuitem id="menu_ops_budget"
              name="Budget Control"
              parent="account.menu_finance_reports"
              action="action_ops_budget"
              sequence="15"/>
</odoo>

>>> ops_matrix_accounting/views/ops_financial_report_wizard_views.xml <<<
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- Financial Report Wizard Form View -->
    <record id="view_ops_financial_report_wizard_form" model="ir.ui.view">
        <field name="name">ops.financial.report.wizard.form</field>
        <field name="model">ops.financial.report.wizard</field>
        <field name="arch" type="xml">
            <form string="Financial Report">
                <sheet>
                    <group col="4">
                        <group colspan="2">
                            <field name="report_type" widget="radio"/>
                            <field name="date_from"/>
                            <field name="date_to"/>
                        </group>
                        <group colspan="2">
                            <field name="branch_id"/>
                            <field name="target_move" widget="radio"/>
                            <field name="company_id" invisible="1"/>
                        </group>
                    </group>
                </sheet>
                <footer>
                    <button string="View On-Screen Analysis"
                            name="action_view_data"
                            type="object"
                            icon="fa-bar-chart"
                            class="btn-primary"/>
                    <button string="Print PDF"
                            name="action_print_pdf"
                            type="object"
                            icon="fa-file-pdf-o"
                            class="btn-secondary"/>
                    <button string="Export Excel"
                            name="action_export_xlsx"
                            type="object"
                            icon="fa-file-excel-o"
                            class="btn-secondary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel" icon="fa-times"/>
                </footer>
            </form>
        </field>
    </record>

    <!-- Financial Report Wizard Action -->
    <record id="action_ops_financial_report_wizard" model="ir.actions.act_window">
        <field name="name">Financial Reports</field>
        <field name="res_model">ops.financial.report.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <!-- Menu Item -->
    <menuitem id="menu_ops_financial_report_wizard"
              name="Financial Reports"
              parent="menu_ops_accounting_reports"
              action="action_ops_financial_report_wizard"
              sequence="10"/>
</odoo>

>>> ops_matrix_accounting/views/ops_general_ledger_wizard_enhanced_views.xml <<<
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    
    <!-- Enhanced General Ledger Wizard Form View -->
    <record id="view_ops_general_ledger_wizard_enhanced_form" model="ir.ui.view">
        <field name="name">ops.general.ledger.wizard.enhanced.form</field>
        <field name="model">ops.general.ledger.wizard.enhanced</field>
        <field name="arch" type="xml">
            <form string="General Ledger Report with Matrix Filters">
                <sheet>
                    <div class="oe_title">
                        <h1>General Ledger Report</h1>
                        <h3 class="text-muted">Matrix-Enhanced Financial Reporting</h3>
                        <div class="text-muted mt-2">
                            <field name="filter_summary" widget="text" readonly="1"/>
                        </div>
                    </div>
                    
                    <!-- Quick Stats Alert -->
                    <div class="alert alert-info" role="alert" invisible="record_count == 0">
                        <div class="row">
                            <div class="col-8">
                                <strong>Estimated records:</strong> 
                                <field name="record_count" readonly="1"/> transactions
                            </div>
                            <div class="col-4 text-right">
                                <span invisible="record_count &lt;= 10000" class="badge badge-success">
                                    Good size
                                </span>
                                <span invisible="record_count &lt;= 10000 or record_count &gt; 50000" class="badge badge-warning">
                                    Large dataset
                                </span>
                                <span invisible="record_count &lt;= 50000" class="badge badge-danger">
                                    Very large - use filters
                                </span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Tabbed Interface for Filters -->
                    <notebook>
                        <!-- Tab 1: Period & Company -->
                        <page string="Period &amp; Company" name="page_period">
                            <group>
                                <group string="Reporting Period">
                                    <field name="date_from"/>
                                    <field name="date_to"/>
                                    <field name="include_initial_balance"/>
                                </group>
                                
                                <group string="Company &amp; Journals">
                                    <field name="company_id" options="{'no_create': True}"/>
                                    <field name="journal_ids" widget="many2many_tags" options="{'no_create': True}"/>
                                </group>
                            </group>
                            
                            <group>
                                <group string="Transaction Filters">
                                    <field name="target_move" widget="radio"/>
                                    <field name="reconciled" widget="radio"/>
                                </group>
                            </group>
                        </page>
                        
                        <!-- Tab 2: Matrix Dimensions (PRIMARY FEATURE) -->
                        <page string="Matrix Dimensions" name="page_matrix">
                            <div class="alert alert-primary" role="alert">
                                <h4><i class="fa fa-filter"/> Matrix Filtering</h4>
                                <p>Filter transactions by Branch and/or Business Unit dimensions for precise organizational reporting.</p>
                            </div>
                            
                            <group>
                                <group string="Branch Selection">
                                    <field name="branch_ids" widget="many2many_tags" options="{'no_create': True, 'color_field': 'color'}"/>
                                </group>
                                
                                <group string="Business Unit Selection">
                                    <field name="business_unit_ids" widget="many2many_tags" options="{'no_create': True, 'color_field': 'color'}"/>
                                </group>
                            </group>
                            
                            <separator string="Matrix Filter Mode"/>
                            <group>
                                <field name="matrix_filter_mode" widget="radio" class="oe_inline"/>
                            </group>
                            
                            <div class="alert alert-info mt-3" role="alert">
                                <h5>Filter Mode Explanation:</h5>
                                <ul class="mb-0">
                                    <li invisible="matrix_filter_mode != 'any'">
                                        <strong>Any Dimension:</strong> Shows transactions matching ANY selected branch OR business unit (inclusive)
                                    </li>
                                    <li invisible="matrix_filter_mode != 'both'">
                                        <strong>Both Dimensions:</strong> Shows transactions matching BOTH selected branch AND business unit (restrictive)
                                    </li>
                                    <li invisible="matrix_filter_mode != 'exact'">
                                        <strong>Exact Combination:</strong> Shows only transactions with exact branch-BU combinations (e.g., Branch A + BU X only)
                                    </li>
                                </ul>
                            </div>
                        </page>
                        
                        <!-- Tab 3: Accounts -->
                        <page string="Accounts" name="page_accounts">
                            <group>
                                <group string="Account Selection">
                                    <field name="account_ids" widget="many2many_tags" options="{'no_create': True}"/>
                                    <field name="account_type_ids"/>
                                </group>
                                
                                <group string="Display Options">
                                    <field name="display_account" widget="radio"/>
                                </group>
                            </group>
                            
                            <div class="alert alert-secondary mt-3" role="alert">
                                <p class="mb-0">
                                    <strong>Tip:</strong> Leave account fields empty to include all accounts, or select specific accounts/types for focused analysis.
                                </p>
                            </div>
                        </page>
                        
                        <!-- Tab 4: Partners -->
                        <page string="Partners" name="page_partners">
                            <group>
                                <group string="Partner Filter">
                                    <field name="partner_ids" widget="many2many_tags" options="{'no_create': True}"/>
                                </group>
                            </group>
                            
                            <div class="alert alert-secondary mt-3" role="alert">
                                <p class="mb-0">
                                    <strong>Optional:</strong> Filter by specific partners to analyze supplier/customer transactions.
                                </p>
                            </div>
                        </page>
                        
                        <!-- Tab 5: Report Options -->
                        <page string="Report Options" name="page_options">
                            <group>
                                <group string="Report Format">
                                    <field name="report_format" widget="radio"/>
                                    <field name="sort_by"/>
                                </group>
                                
                                <group string="Grouping &amp; Consolidation">
                                    <field name="group_by_date"/>
                                    <separator string="Consolidate By:"/>
                                    <field name="consolidate_by_branch"/>
                                    <field name="consolidate_by_bu"/>
                                    <field name="consolidate_by_partner"/>
                                </group>
                            </group>
                            
                            <div class="alert alert-info mt-3" role="alert">
                                <h5>Format Guide:</h5>
                                <ul class="mb-0">
                                    <li><strong>Detailed:</strong> Line-by-line transaction listing (best for &lt;10k records)</li>
                                    <li><strong>Summary:</strong> Aggregated by account and selected dimensions (efficient for large datasets)</li>
                                    <li><strong>Both:</strong> Combined detailed and summary views</li>
                                </ul>
                            </div>
                        </page>
                    </notebook>
                    
                    <!-- Action Buttons -->
                    <footer>
                        <button name="action_generate_report"
                                string="Generate Report"
                                type="object"
                                class="btn-primary"
                                icon="fa-file-pdf-o"
                                invisible="not date_from or not date_to"/>
                        <button name="action_export_to_excel"
                                string="Export to Excel"
                                type="object"
                                class="btn-secondary"
                                icon="fa-file-excel-o"
                                invisible="not date_from or not date_to"/>
                        <button name="action_view_transactions"
                                string="View Transactions"
                                type="object"
                                class="btn-secondary"
                                icon="fa-list"
                                invisible="not date_from or not date_to"/>
                        <button string="Cancel"
                                class="btn-secondary"
                                icon="fa-times"
                                special="cancel"/>
                    </footer>
                </sheet>
            </form>
        </field>
    </record>
    
    <!-- Action to Open Enhanced Wizard -->
    <record id="action_ops_general_ledger_wizard_enhanced" model="ir.actions.act_window">
        <field name="name">General Ledger (Matrix)</field>
        <field name="res_model">ops.general.ledger.wizard.enhanced</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="context">{}</field>
    </record>
    
    <!-- Menu Item -->
    <menuitem id="menu_ops_general_ledger_enhanced"
              name="General Ledger (Matrix)"
              parent="account.menu_finance_reports"
              action="action_ops_general_ledger_wizard_enhanced"
              sequence="5"/>

</odoo>

>>> ops_matrix_accounting/views/ops_general_ledger_wizard_views.xml <<<
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_ops_general_ledger_wizard_form" model="ir.ui.view">
        <field name="name">ops.general.ledger.wizard.form</field>
        <field name="model">ops.general.ledger.wizard</field>
        <field name="arch" type="xml">
            <form string="General Ledger Report">
                <sheet>
                    <div class="oe_title">
                        <h1>General Ledger Report</h1>
                    </div>
                    <group col="4">
                        <group>
                            <field name="date_from"/>
                            <field name="date_to"/>
                            <field name="target_move"/>
                        </group>
                        <group>
                            <field name="company_id" invisible="1"/>
                            <field name="account_ids" widget="many2many_tags"/>
                        </group>
                    </group>
                </sheet>
                <footer>
                    <button string="Print PDF" name="action_print_pdf" type="object" class="btn-primary" icon="fa-file-pdf-o"/>
                    <button string="Export Excel" name="action_export_xlsx" type="object" class="btn-secondary" icon="fa-file-excel-o"/>
                    <button string="Cancel" class="btn-secondary" special="cancel" icon="fa-times"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_ops_general_ledger_wizard" model="ir.actions.act_window">
        <field name="name">General Ledger</field>
        <field name="res_model">ops.general.ledger.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="binding_view_types">form</field>
    </record>

    <menuitem id="menu_ops_general_ledger_report" 
              name="General Ledger" 
              parent="menu_ops_accounting_reports" 
              action="action_ops_general_ledger_wizard" 
              sequence="10"/>
</odoo>

>>> ops_matrix_accounting/views/ops_pdc_views.xml <<<
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- List View -->
    <record id="view_ops_pdc_tree" model="ir.ui.view">
        <field name="name">ops.pdc.list</field>
        <field name="model">ops.pdc</field>
        <field name="arch" type="xml">
            <list string="Post-Dated Checks" decoration-info="state == 'draft'" decoration-success="state == 'cleared'" decoration-danger="state == 'bounced'">
                <field name="name"/>
                <field name="date"/>
                <field name="maturity_date"/>
                <field name="partner_id"/>
                <field name="payment_type"/>
                <field name="amount"/>
                <field name="currency_id" invisible="1"/>
                <field name="ops_branch_id"/>
                <field name="ops_business_unit_id"/>
                <field name="state"/>
            </list>
        </field>
    </record>

    <!-- Form View -->
    <record id="view_ops_pdc_form" model="ir.ui.view">
        <field name="name">ops.pdc.form</field>
        <field name="model">ops.pdc</field>
        <field name="arch" type="xml">
            <form string="Post-Dated Check">
                <!-- Anti-Fraud Security: Authority check field -->
                <field name="can_user_manage_pdc" invisible="1"/>
                <header>
                    <!-- Anti-Fraud Security: Register button restricted to authorized users -->
                    <button name="action_register"
                            string="Register"
                            type="object"
                            icon="fa-check"
                            class="oe_highlight"
                            invisible="state != 'draft' or not can_user_manage_pdc"
                            groups="ops_matrix_core.group_ops_treasury_manager"/>
                    <!-- Anti-Fraud Security: Deposit button restricted to authorized users -->
                    <button name="action_deposit"
                            string="Deposit"
                            type="object"
                            icon="fa-upload"
                            class="oe_highlight"
                            invisible="state != 'registered' or not can_user_manage_pdc"
                            groups="ops_matrix_core.group_ops_treasury_manager"/>
                    <field name="state" widget="statusbar"/>
                </header>
                <sheet>
                    <div class="oe_title">
                        <h1>
                            <field name="name" readonly="1"/>
                        </h1>
                    </div>
                    <group col="4">
                        <group string="Basic Information" colspan="2">
                            <field name="partner_id"/>
                            <field name="payment_type"/>
                            <field name="amount"/>
                            <field name="currency_id" groups="base.group_multi_currency"/>
                            <field name="check_number"/>
                            <field name="bank_id"/>
                        </group>
                        <group string="Dates" colspan="2">
                            <field name="date"/>
                            <field name="maturity_date"/>
                        </group>
                    </group>
                    <group col="4">
                        <group string="Matrix Dimensions" colspan="2">
                            <field name="ops_branch_id"/>
                            <field name="ops_business_unit_id"/>
                        </group>
                        <group string="Accounting Information" colspan="2">
                            <field name="journal_id"/>
                            <field name="holding_account_id"/>
                            <field name="move_id" readonly="1"/>
                            <field name="deposit_move_id" readonly="1"/>
                        </group>
                    </group>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids"/>
                    <field name="activity_ids"/>
                    <field name="message_ids"/>
                </div>
            </form>
        </field>
    </record>

    <!-- Search View -->
    <record id="view_ops_pdc_search" model="ir.ui.view">
        <field name="name">ops.pdc.search</field>
        <field name="model">ops.pdc</field>
        <field name="arch" type="xml">
            <search>
                <field name="name"/>
                <field name="partner_id"/>
                <field name="check_number"/>
                <field name="ops_branch_id"/>
                <field name="ops_business_unit_id"/>
                <separator/>
                <filter string="Draft" name="draft" domain="[('state', '=', 'draft')]"/>
                <filter string="Registered" name="registered" domain="[('state', '=', 'registered')]"/>
                <filter string="Deposited" name="deposited" domain="[('state', '=', 'deposited')]"/>
                <filter string="Cleared" name="cleared" domain="[('state', '=', 'cleared')]"/>
                <filter string="Bounced" name="bounced" domain="[('state', '=', 'bounced')]"/>
                <separator/>
                <filter string="Customer PDCs" name="inbound" domain="[('payment_type', '=', 'inbound')]"/>
                <filter string="Vendor PDCs" name="outbound" domain="[('payment_type', '=', 'outbound')]"/>
                <filter string="Status" name="group_by_state" context="{'group_by': 'state'}"/>
                <filter string="Partner" name="group_by_partner" context="{'group_by': 'partner_id'}"/>
                <filter string="Branch" name="group_by_branch" context="{'group_by': 'ops_branch_id'}"/>
                <filter string="Business Unit" name="group_by_bu" context="{'group_by': 'ops_business_unit_id'}"/>
            </search>
        </field>
    </record>

    <!-- Actions -->
    <record id="action_ops_pdc_receivable" model="ir.actions.act_window">
        <field name="name">Customer PDCs</field>
        <field name="res_model">ops.pdc</field>
        <field name="view_mode">list,form</field>
        <field name="context">{'default_payment_type': 'inbound', 'search_default_inbound': 1}</field>
        <field name="help" type="html">
            <p class="o_view_nocontent_smiling_face">
                Create your first post-dated check from a customer!
            </p>
        </field>
    </record>

    <record id="action_ops_pdc_payable" model="ir.actions.act_window">
        <field name="name">Vendor PDCs</field>
        <field name="res_model">ops.pdc</field>
        <field name="view_mode">list,form</field>
        <field name="context">{'default_payment_type': 'outbound', 'search_default_outbound': 1}</field>
        <field name="help" type="html">
            <p class="o_view_nocontent_smiling_face">
                Create your first post-dated check to a vendor!
            </p>
        </field>
    </record>

    <!-- Menu Items -->
    <menuitem id="menu_ops_pdc_receivable"
              name="PDC Receivables"
              parent="account.menu_finance_receivables"
              action="action_ops_pdc_receivable"
              sequence="20"/>

    <menuitem id="menu_ops_pdc_payable"
              name="PDC Payables"
              parent="account.menu_finance_payables"
              action="action_ops_pdc_payable"
              sequence="20"/>
</odoo>

>>> ops_matrix_accounting/views/ops_reporting_views.xml <<<
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    
    <!-- Company Consolidation Wizard View -->
    <record id="view_ops_company_consolidation_wizard" model="ir.ui.view">
        <field name="name">ops.company.consolidation.wizard</field>
        <field name="model">ops.company.consolidation</field>
        <field name="arch" type="xml">
            <form string="Company Consolidation Report">
                <sheet>
                    <div class="oe_title">
                        <h1>Company Consolidated P&amp;L Report</h1>
                    </div>
                    
                    <group>
                        <group string="Filters">
                            <field name="company_id" options="{'no_create': True}"/>
                            <field name="date_from"/>
                            <field name="date_to"/>
                            <field name="compare_with_previous"/>
                        </group>
                        
                        <group string="Options">
                            <field name="branch_ids" widget="many2many_tags" options="{'no_create': True}"/>
                            <field name="report_detail_level"/>
                        </group>
                    </group>
                    
                    <group string="Report Preview" invisible="not report_data">
                        <group>
                            <div>
                                <strong>Report generated for period:</strong>
                                <field name="date_from" readonly="1" nolabel="1"/> to
                                <field name="date_to" readonly="1" nolabel="1"/>
                            </div>
                        </group>
                    </group>
                    
                    <footer>
                        <button name="action_generate_pdf"
                                string="Generate PDF"
                                type="object"
                                class="btn-primary"
                                icon="fa-file-pdf-o"/>
                        <button name="action_generate_xlsx"
                                string="Export to Excel"
                                type="object"
                                class="btn-secondary"
                                icon="fa-file-excel-o"/>
                        <button string="Cancel"
                                class="btn-secondary"
                                icon="fa-times"
                                special="cancel"/>
                    </footer>
                </sheet>
            </form>
        </field>
    </record>
    
    <!-- Company Consolidation Action -->
    <record id="action_ops_company_consolidation" model="ir.actions.act_window">
        <field name="name">Company Consolidation</field>
        <field name="res_model">ops.company.consolidation</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="context">{}</field>
    </record>
    
    <!-- Branch Report Wizard View -->
    <record id="view_ops_branch_report_wizard" model="ir.ui.view">
        <field name="name">ops.branch.report.wizard</field>
        <field name="model">ops.branch.report</field>
        <field name="arch" type="xml">
            <form string="Branch P&amp;L Report">
                <sheet>
                    <div class="oe_title">
                        <h1>Branch Profit &amp; Loss Report</h1>
                    </div>
                    
                    <group>
                        <group string="Selection">
                            <field name="branch_id" options="{'no_create': True}"/>
                            <field name="business_unit_ids" widget="many2many_tags" options="{'no_create': True}"/>
                        </group>
                        
                        <group string="Period">
                            <field name="date_from"/>
                            <field name="date_to"/>
                        </group>
                    </group>
                    
                    <group string="Report Preview" invisible="not report_data">
                        <group>
                            <div>
                                <strong>Report generated for:</strong>
                                <field name="branch_id" readonly="1" nolabel="1"/>
                            </div>
                        </group>
                    </group>
                    
                    <footer>
                        <button name="action_generate_pdf" 
                                string="Generate PDF" 
                                type="object" 
                                class="btn-primary"/>
                        <button string="Cancel" 
                                class="btn-secondary" 
                                special="cancel"/>
                    </footer>
                </sheet>
            </form>
        </field>
    </record>
    
    <!-- Branch Report Action -->
    <record id="action_ops_branch_report" model="ir.actions.act_window">
        <field name="name">Branch P&amp;L Report</field>
        <field name="res_model">ops.branch.report</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="context">{}</field>
    </record>
    
    <!-- Business Unit Report Wizard View -->
    <record id="view_ops_business_unit_report_wizard" model="ir.ui.view">
        <field name="name">ops.business.unit.report.wizard</field>
        <field name="model">ops.business.unit.report</field>
        <field name="arch" type="xml">
            <form string="Business Unit Report">
                <sheet>
                    <div class="oe_title">
                        <h1>Business Unit Profitability Report</h1>
                    </div>
                    
                    <group>
                        <group string="Selection">
                            <field name="business_unit_id" options="{'no_create': True}"/>
                            <field name="business_unit_branch_ids" invisible="1"/>
                            <field name="branch_ids" widget="many2many_tags" options="{'no_create': True}"/>
                            <field name="consolidate_by_branch"/>
                        </group>
                        
                        <group string="Period">
                            <field name="date_from"/>
                            <field name="date_to"/>
                        </group>
                    </group>
                    
                    <group string="Report Preview" invisible="not report_data">
                        <group>
                            <div>
                                <strong>Report generated for:</strong>
                                <field name="business_unit_id" readonly="1" nolabel="1"/>
                            </div>
                        </group>
                    </group>
                    
                    <footer>
                        <button name="action_generate_pdf" 
                                string="Generate PDF" 
                                type="object" 
                                class="btn-primary"/>
                        <button string="Cancel" 
                                class="btn-secondary" 
                                special="cancel"/>
                    </footer>
                </sheet>
            </form>
        </field>
    </record>
    
    <!-- Business Unit Report Action -->
    <record id="action_ops_business_unit_report" model="ir.actions.act_window">
        <field name="name">Business Unit Report</field>
        <field name="res_model">ops.business.unit.report</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="context">{}</field>
    </record>
    
    <!-- Consolidated Balance Sheet Wizard View -->
    <record id="view_ops_consolidated_balance_sheet_wizard" model="ir.ui.view">
        <field name="name">ops.consolidated.balance.sheet.wizard</field>
        <field name="model">ops.consolidated.balance.sheet</field>
        <field name="arch" type="xml">
            <form string="Consolidated Balance Sheet">
                <sheet>
                    <div class="oe_title">
                        <h1>Consolidated Balance Sheet</h1>
                    </div>
                    
                    <group>
                        <group string="Companies">
                            <field name="company_ids" widget="many2many_tags" options="{'no_create': True}"/>
                            <field name="date"/>
                        </group>
                        
                        <group string="Consolidation Options">
                            <field name="include_intercompany"/>
                            <field name="currency_id" options="{'no_create': True}"/>
                        </group>
                    </group>
                    
                    <group string="Report Preview" invisible="not report_data">
                        <group>
                            <div>
                                <strong>Consolidation as of:</strong>
                                <field name="date" readonly="1" nolabel="1"/>
                            </div>
                        </group>
                    </group>
                    
                    <footer>
                        <button name="action_generate_pdf" 
                                string="Generate PDF" 
                                type="object" 
                                class="btn-primary"/>
                        <button string="Cancel" 
                                class="btn-secondary" 
                                special="cancel"/>
                    </footer>
                </sheet>
            </form>
        </field>
    </record>
    
    <!-- Consolidated Balance Sheet Action -->
    <record id="action_ops_consolidated_balance_sheet" model="ir.actions.act_window">
        <field name="name">Consolidated Balance Sheet</field>
        <field name="res_model">ops.consolidated.balance.sheet</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="context">{}</field>
    </record>
    
    <!-- Matrix Profitability Analysis Wizard View -->
    <record id="view_ops_matrix_profitability_analysis_wizard" model="ir.ui.view">
        <field name="name">ops.matrix.profitability.analysis.wizard</field>
        <field name="model">ops.matrix.profitability.analysis</field>
        <field name="arch" type="xml">
            <form string="Matrix Profitability Analysis">
                <sheet>
                    <div class="oe_title">
                        <h1>Matrix Profitability Analysis</h1>
                        <h3>Branch x Business Unit Performance Matrix</h3>
                    </div>
                    
                    <group>
                        <group string="Filters">
                            <field name="company_id" options="{'no_create': True}"/>
                        </group>
                        
                        <group string="Period">
                            <field name="date_from"/>
                            <field name="date_to"/>
                        </group>
                    </group>
                    
                    <group string="Report Preview" invisible="not matrix_data">
                        <group>
                            <div>
                                <strong>Analysis for:</strong>
                                <field name="company_id" readonly="1" nolabel="1"/>
                            </div>
                        </group>
                    </group>
                    
                    <footer>
                        <button name="action_generate_heatmap" 
                                string="Generate Heatmap" 
                                type="object" 
                                class="btn-primary"/>
                        <button string="Cancel" 
                                class="btn-secondary" 
                                special="cancel"/>
                    </footer>
                </sheet>
            </form>
        </field>
    </record>
    
    <!-- Matrix Profitability Analysis Action -->
    <record id="action_ops_matrix_profitability" model="ir.actions.act_window">
        <field name="name">Matrix Profitability Analysis</field>
        <field name="res_model">ops.matrix.profitability.analysis</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
        <field name="context">{}</field>
    </record>
    
    <!-- Menu Structure -->
    <menuitem id="menu_ops_reporting" 
              name="Matrix Reports" 
              parent="account.menu_finance_reports"
              sequence="10"/>
    
    <menuitem id="menu_ops_company_consolidation"
              name="Company Consolidation"
              parent="menu_ops_reporting"
              action="action_ops_company_consolidation"
              sequence="10"/>
    
    <menuitem id="menu_ops_branch_report"
              name="Branch P&amp;L"
              parent="menu_ops_reporting"
              action="action_ops_branch_report"
              sequence="20"/>
    
    <menuitem id="menu_ops_business_unit_report"
              name="Business Unit Report"
              parent="menu_ops_reporting"
              action="action_ops_business_unit_report"
              sequence="30"/>
    
    <menuitem id="menu_ops_consolidated_balance_sheet"
              name="Consolidated Balance Sheet"
              parent="menu_ops_reporting"
              action="action_ops_consolidated_balance_sheet"
              sequence="40"/>
    
    <menuitem id="menu_ops_matrix_profitability"
              name="Matrix Profitability Analysis"
              parent="menu_ops_reporting"
              action="action_ops_matrix_profitability"
              sequence="50"/>

</odoo>

>>> ops_matrix_accounting/security/ir.model.access.csv <<<
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_ops_pdc_user,ops.pdc.user,model_ops_pdc,ops_matrix_core.group_ops_user,1,1,1,0
access_ops_pdc_manager,ops.pdc.manager,model_ops_pdc,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_budget_user,ops.budget.user,model_ops_budget,ops_matrix_core.group_ops_user,1,0,0,0
access_ops_budget_manager,ops.budget.manager,model_ops_budget,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_budget_line_user,ops.budget.line.user,model_ops_budget_line,ops_matrix_core.group_ops_user,1,0,0,0
access_ops_budget_line_manager,ops.budget.line.manager,model_ops_budget_line,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_gl_wizard_user,ops.general.ledger.wizard.user,model_ops_general_ledger_wizard,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_gl_wizard_enhanced_user,ops.general.ledger.wizard.enhanced.user,model_ops_general_ledger_wizard_enhanced,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_gl_wizard_enhanced_manager,ops.general.ledger.wizard.enhanced.manager,model_ops_general_ledger_wizard_enhanced,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_fin_report_wizard_user,ops.financial.report.wizard.user,model_ops_financial_report_wizard,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_company_consolidation_user,ops.company.consolidation.user,model_ops_company_consolidation,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_company_consolidation_manager,ops.company.consolidation.manager,model_ops_company_consolidation,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_branch_report_user,ops.branch.report.user,model_ops_branch_report,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_branch_report_manager,ops.branch.report.manager,model_ops_branch_report,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_business_unit_report_user,ops.business.unit.report.user,model_ops_business_unit_report,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_business_unit_report_manager,ops.business.unit.report.manager,model_ops_business_unit_report,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_consolidated_balance_sheet_user,ops.consolidated.balance.sheet.user,model_ops_consolidated_balance_sheet,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_consolidated_balance_sheet_manager,ops.consolidated.balance.sheet.manager,model_ops_consolidated_balance_sheet,ops_matrix_core.group_ops_manager,1,1,1,1
access_ops_matrix_profitability_analysis_user,ops.matrix.profitability.analysis.user,model_ops_matrix_profitability_analysis,ops_matrix_core.group_ops_user,1,1,1,1
access_ops_matrix_profitability_analysis_manager,ops.matrix.profitability.analysis.manager,model_ops_matrix_profitability_analysis,ops_matrix_core.group_ops_manager,1,1,1,1

###############################################
### MODULE: ops_matrix_reporting (Pattern Reference)
###############################################

>>> ops_matrix_reporting/__manifest__.py <<<
{
    'name': 'OPS Matrix Reporting',
    'version': '19.0.1.0',
    'category': 'Reporting',
    'summary': 'Branch/Business Unit Matrix Analytics and Reporting',
    'description': """
    High-performance SQL-based reporting and analytics for the OPS Matrix framework.
    
    Features:
    - Sales Analysis by Branch and Business Unit
    - Financial Analysis with dimension tracking
    - Inventory Health and BU segregation verification
    - Spreadsheet Dashboard integration
    - Strict record-level security enforcement
    """,
    'author': 'OPS Matrix Development Team',
    'license': 'LGPL-3',
    'installable': True,
    'application': True,
    'auto_install': False,
    'depends': [
        'ops_matrix_core',
        'sale_management',
        'account',
        'stock',
        'spreadsheet_dashboard',
    ],
    'data': [
        # Security
        'security/ir.model.access.csv',
        'security/ir_rule.xml',
        # Views
        'views/ops_sales_analysis_views.xml',
        'views/ops_financial_analysis_views.xml',
        'views/ops_inventory_analysis_views.xml',
        'views/ops_excel_export_wizard_views.xml',
        'views/reporting_menu.xml',
    ],
    'assets': {
        'web.assets_backend': [
            'ops_matrix_reporting/static/src/css/reporting.css',
        ],
    },
    'external_dependencies': {
        'python': ['xlsxwriter'],
    },
    'images': ['static/description/icon.png'],
}

>>> ops_matrix_reporting/models/__init__.py <<<
# -*- coding: utf-8 -*-

from . import ops_sales_analysis
from . import ops_financial_analysis
from . import ops_inventory_analysis

__all__ = [
    'ops_sales_analysis',
    'ops_financial_analysis',
    'ops_inventory_analysis',
]

>>> ops_matrix_reporting/models/__init__.py <<<
# -*- coding: utf-8 -*-

from . import ops_sales_analysis
from . import ops_financial_analysis
from . import ops_inventory_analysis

__all__ = [
    'ops_sales_analysis',
    'ops_financial_analysis',
    'ops_inventory_analysis',
]

>>> ops_matrix_reporting/models/ops_financial_analysis.py <<<
from odoo import models, fields, api


class OpsFinancialAnalysis(models.Model):
    """
    Financial Analysis Report - Read-Only SQL View
    
    This model represents a PostgreSQL materialized view that provides
    high-performance financial analytics with Branch and Business Unit dimensions.
    
    The view joins account_move_line with account_move to provide:
    - Date of journal entry
    - Account information
    - Branch and Business Unit dimensions (from move)
    - Debit/Credit amounts and balance
    - Move status and type
    
    CRITICAL: This model is read-only (_auto=False) and backed by a PostgreSQL view.
    Only posted journal entries from actual invoices/bills are included.
    """
    
    _name = 'ops.financial.analysis'
    _description = 'Financial Analysis by Branch and Business Unit'
    _auto = False  # Don't auto-create table
    _rec_name = 'id'
    _order = 'date DESC'
    
    # ========================================================================
    # FIELDS - Mirror the View Columns
    # ========================================================================
    id = fields.Id(readonly=True)
    
    date = fields.Date(
        string='Entry Date',
        readonly=True,
        help='The accounting date of the journal entry, which determines the fiscal period for reporting. '
             'This is distinct from the transaction date and is used for period-end closing and financial statements. '
             'Use Case: Filter by date range to generate monthly/quarterly/annual financial reports and P&L statements. '
             'Example: "2025-01-01 to 2025-01-31" for January financial results. '
             'Important: Only posted entries (state=posted) are included - draft entries are excluded from this analysis. '
             'Note: This is the move date (account.move.date), not the line date - all lines in a move share the same date. '
             'Related: Combine with ops_branch_id and ops_business_unit_id for multi-dimensional financial analysis.'
    )
    
    move_id = fields.Many2one(
        'account.move',
        string='Journal Entry',
        readonly=True,
        help='The parent journal entry (account move) that contains this line item. '
             'Used to trace back to the source document (invoice, bill, payment, etc.) and view full transaction context. '
             'Use Case: Click to view complete journal entry details including all debit/credit lines and original document reference. '
             'Example: "INV/2025/0001" for customer invoice or "BILL/2025/0001" for vendor bill. '
             'Important: Each move can have multiple lines (debits and credits must balance). '
             'Navigation: From analysis view → move_id → view original invoice/bill with payment status and customer/vendor details. '
             'Related: move_type indicates whether this is a customer invoice, vendor bill, credit note, etc.'
    )
    
    account_id = fields.Many2one(
        'account.account',
        string='Account',
        readonly=True,
        help='The General Ledger (GL) account to which this financial transaction is posted. '
             'Accounts are organized in a chart of accounts with categories like Assets, Liabilities, Equity, Revenue, Expenses. '
             'Use Case: Group by account_id to generate trial balance, balance sheet, and income statement reports. '
             'Example: "101000 - Cash" for cash accounts, "400000 - Product Sales" for revenue, "600000 - COGS" for expenses. '
             'Important: Account type determines where it appears in financial statements (BS vs P&L). '
             'Analysis: Use get_account_analysis() to see account balances broken down by branch and BU dimensions. '
             'Related: Filter by account.account_type (asset_receivable, liability_payable, expense, income) for specific report types.'
    )
    
    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        readonly=True,
        help='The operational branch (location/store) to which this financial transaction is attributed for P&L reporting. '
             'This dimension enables branch-level financial statements including income statements and balance sheets. '
             'Use Case: Generate separate P&L statements per branch to evaluate location profitability and cost centers. '
             'Example: "Branch A: $100K revenue, $80K expenses = $20K profit vs Branch B: $90K revenue, $85K expenses = $5K profit". '
             'Important: Inherited from the parent move (invoice/bill level), not line level - all lines share the branch. '
             'Analysis: Use get_summary_by_branch() for aggregated debits, credits, and net balance per branch. '
             'Security: Users only see financial data from branches they have access to via security rules.'
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        readonly=True,
        help='The business unit (product line/division) to which this financial transaction is attributed for divisional P&L. '
             'This dimension enables BU-level financial statements to track divisional profitability independently. '
             'Use Case: Generate separate P&L per BU to evaluate which product lines are profitable and which need strategic changes. '
             'Example: "Electronics BU: $200K revenue, $120K COGS, $50K OpEx = $30K profit. Clothing BU: $150K revenue, $100K COGS, $60K OpEx = -$10K loss". '
             'Important: Combined with ops_branch_id, enables full matrix reporting (Branch × BU P&L grid). '
             'Analysis: Use get_account_analysis() for account-level detail by both branch and BU simultaneously. '
             'Note: Inherited from parent move level for consistency across all lines in the transaction.'
    )
    
    move_type = fields.Selection([
        ('out_invoice', 'Customer Invoice'),
        ('out_refund', 'Customer Credit Note'),
        ('in_invoice', 'Vendor Bill'),
        ('in_refund', 'Vendor Credit Note'),
    ], string='Move Type', readonly=True,
       help='The transaction type that originated this journal entry, indicating whether it increases or decreases revenue/expenses. '
            'out_invoice: Customer Invoice (increases A/R and revenue). '
            'out_refund: Customer Credit Note (decreases A/R and revenue, issued for returns/corrections). '
            'in_invoice: Vendor Bill (increases A/P and expenses/COGS). '
            'in_refund: Vendor Credit Note (decreases A/P and expenses, received for returns/corrections). '
            'Use Case: Filter by move_type to separate sales analysis (out_*) from procurement analysis (in_*). '
            'Example: "Sum all out_invoice for total revenue, sum all in_invoice for total expenses". '
            'Important: Only these 4 transaction types are included - journal entries, payments, and manual moves are excluded. '
            'Analysis: Use get_receivables_payables_by_dimension() to analyze A/R (out_invoice) and A/P (in_invoice) by branch/BU.')
    
    debit = fields.Float(
        string='Debit',
        readonly=True,
        help='The debit amount for this journal entry line in the company currency. '
             'In double-entry accounting, debits increase Assets and Expenses, decrease Liabilities and Equity. '
             'Use Case: Sum debits by account to see total increases to asset/expense accounts during a period. '
             'Example: "Cash account debits of $50K = cash received from customers". '
             'Important: Debit and Credit always balance in a journal entry - total debits must equal total credits. '
             'Analysis: Debit - Credit = Balance. Positive balance indicates net debit position. '
             'Warning: Currency is always company currency - multi-currency transactions are converted at entry date rate.'
    )
    
    credit = fields.Float(
        string='Credit',
        readonly=True,
        help='The credit amount for this journal entry line in the company currency. '
             'In double-entry accounting, credits increase Liabilities, Equity, and Revenue, decrease Assets. '
             'Use Case: Sum credits by account to see total increases to liability/revenue accounts during a period. '
             'Example: "Sales revenue account credits of $100K = total sales revenue earned". '
             'Important: Every transaction has offsetting debits and credits - they must always balance (sum to zero). '
             'Analysis: Credit - Debit = negative Balance. Net credit position appears as negative balance. '
             'Related: For P&L analysis, revenue accounts show credits (good), expense accounts show debits (costs).'
    )
    
    balance = fields.Float(
        string='Balance',
        readonly=True,
        help='The net balance of this journal entry line, calculated as (debit - credit). '
             'Positive balance = net debit position (Assets/Expenses increase). Negative balance = net credit position (Liabilities/Revenue increase). '
             'Use Case: Sum balances by account to generate Trial Balance report showing net position for each GL account. '
             'Example: "Cash account balance +$10K = net cash increase. Sales revenue balance -$50K = revenue earned (credit normal)". '
             'Important: Balance sign convention: Assets/Expenses positive when growing, Liabilities/Equity/Revenue negative when growing. '
             'Analysis: Group by account_id and sum balance to see net change in each account during reporting period. '
             'Related: For period P&L, sum balances of all expense accounts (positive) and revenue accounts (negative) to calculate profit.'
    )
    
    partner_id = fields.Many2one(
        'res.partner',
        string='Partner',
        readonly=True,
        help='The business partner (customer or vendor) associated with this financial transaction. '
             'For customer invoices/credits: this is the customer. For vendor bills/credits: this is the supplier. '
             'Use Case: Track accounts receivable per customer and accounts payable per vendor by branch/BU dimensions. '
             'Example: "Customer ABC owes $15K across 3 branches (A/R analysis), Vendor XYZ is owed $8K across 2 BUs (A/P analysis)". '
             'Important: Partner is only populated for A/R and A/P account lines - expense and revenue lines may have null partner. '
             'Analysis: Use get_receivables_payables_by_dimension() to see aged receivables and payables by customer/vendor and dimension. '
             'Related: Cross-reference with sales analysis to see customer profitability (revenue vs payment behavior).'
    )
    
    # ========================================================================
    # SQL VIEW CREATION
    # ========================================================================
    def init(self):
        """
        Create the PostgreSQL view when the model is initialized.
        
        The view:
        1. Joins account_move_line with account_move
        2. Filters for posted entries (state='posted')
        3. Includes only transaction moves (out_invoice, out_refund, in_invoice, in_refund)
        4. Includes Branch and Business Unit dimensions from the move
        5. Optimized for financial analysis and multi-dimensional reporting
        """
        self.env.cr.execute(
            f"""
            CREATE OR REPLACE VIEW {self._table} AS (
                SELECT
                    -- Identification
                    aml.id,
                    aml.move_id,
                    aml.account_id,
                    
                    -- Temporal
                    CAST(am.date AS date) AS date,
                    
                    -- OPS Matrix Dimensions (from move level)
                    am.ops_branch_id,
                    am.ops_business_unit_id,
                    
                    -- Move information
                    am.move_type,
                    am.partner_id,
                    
                    -- Amounts
                    aml.debit,
                    aml.credit,
                    (aml.debit - aml.credit) AS balance
                
                FROM account_move_line aml
                
                INNER JOIN account_move am ON aml.move_id = am.id
                
                WHERE
                    -- Only posted entries
                    am.state = 'posted'
                    -- Only transaction-related moves
                    AND am.move_type IN ('out_invoice', 'out_refund', 'in_invoice', 'in_refund')
                    -- Exclude lines with zero balance
                    AND (aml.debit != 0 OR aml.credit != 0)
            )
            """
        )
    
    # ========================================================================
    # STATISTICS & AGGREGATIONS
    # ========================================================================
    @api.model
    def get_summary_by_branch(self):
        """
        Get financial summary grouped by branch.
        
        Returns aggregated financial data by branch:
        - Total debits
        - Total credits
        - Net balance
        - Transaction count
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                COUNT(*) as transaction_count,
                SUM(debit) as total_debits,
                SUM(credit) as total_credits,
                SUM(balance) as net_balance
            FROM ops_financial_analysis
            WHERE ops_branch_id IN (
                SELECT id FROM res_company
                WHERE id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_branch_id
            ORDER BY net_balance DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_summary_by_business_unit(self):
        """
        Get financial summary grouped by business unit.
        
        Returns aggregated financial data by BU:
        - Total debits
        - Total credits
        - Net balance
        - Transaction count
        """
        self.env.cr.execute(
            """
            SELECT
                ops_business_unit_id,
                COUNT(*) as transaction_count,
                SUM(debit) as total_debits,
                SUM(credit) as total_credits,
                SUM(balance) as net_balance
            FROM ops_financial_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_business_unit_id
            ORDER BY net_balance DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_account_analysis(self):
        """
        Get detailed analysis by account, branch, and business unit.
        
        Shows financial position by GL account and dimension:
        - Account balance by dimension
        - Helps identify cost centers and profit centers
        """
        self.env.cr.execute(
            """
            SELECT
                account_id,
                ops_branch_id,
                ops_business_unit_id,
                COUNT(*) as transaction_count,
                SUM(debit) as total_debits,
                SUM(credit) as total_credits,
                SUM(balance) as account_balance
            FROM ops_financial_analysis
            WHERE 
                ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY account_id, ops_branch_id, ops_business_unit_id
            ORDER BY account_balance DESC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_receivables_payables_by_dimension(self):
        """
        Get A/R and A/P analysis by dimension.
        
        Shows:
        - Customer receivables by branch/BU
        - Vendor payables by branch/BU
        - Helps manage working capital by dimension
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                ops_business_unit_id,
                move_type,
                partner_id,
                COUNT(*) as transaction_count,
                SUM(balance) as dimension_balance
            FROM ops_financial_analysis
            WHERE 
                move_type IN ('out_invoice', 'in_invoice')
                AND ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY ops_branch_id, ops_business_unit_id, move_type, partner_id
            ORDER BY dimension_balance DESC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    @api.model
    def create(self, vals):
        """Prevent creation of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be created.")
    
    def write(self, vals):
        """Prevent modification of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be modified.")
    
    def unlink(self):
        """Prevent deletion of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be deleted.")

>>> ops_matrix_reporting/models/ops_inventory_analysis.py <<<
from odoo import models, fields, api


class OpsInventoryAnalysis(models.Model):
    """
    Inventory Analysis Report - Read-Only SQL View
    
    This model represents a PostgreSQL materialized view that provides
    high-performance inventory analytics with Business Unit segregation.
    
    The view queries stock_quant to provide:
    - Product inventory levels
    - Location information
    - Business Unit dimension (from product via quant)
    - Quantity on hand
    - Stock value (quantity * standard cost)
    
    CRITICAL: This model is read-only (_auto=False) and backed by a PostgreSQL view.
    Ensures accurate inventory visibility respecting BU boundaries.
    """
    
    _name = 'ops.inventory.analysis'
    _description = 'Inventory Health and BU Segregation Analysis'
    _auto = False  # Don't auto-create table
    _rec_name = 'id'
    _order = 'product_id'
    
    # ========================================================================
    # FIELDS - Mirror the View Columns
    # ========================================================================
    id = fields.Id(readonly=True)
    
    product_id = fields.Many2one(
        'product.product',
        string='Product',
        readonly=True,
        help='The specific product variant held in inventory at this location. '
             'Used to track stock levels, valuation, and availability across the warehouse network. '
             'Use Case: Analyze inventory turnover rates, identify slow-moving stock, and plan replenishment by BU. '
             'Example: "Product SKU-001 has 500 units on-hand across 3 locations worth $25K". '
             'Important: This is the variant (product.product), not the template - tracking is at SKU level. '
             'Analysis: Use get_low_stock_alerts() to identify products below reorder points, get_overstocked_items() for excess inventory. '
             'Related: Product belongs to a Business Unit (ops_business_unit_id) - inventory respects BU silo boundaries.'
    )
    
    location_id = fields.Many2one(
        'stock.location',
        string='Location',
        readonly=True,
        help='The specific warehouse location (bin, shelf, zone) where this product quantity is physically stored. '
             'Locations are organized hierarchically: Warehouse → Zone → Bin, enabling precise inventory tracking. '
             'Use Case: Track which locations hold specific products for picking optimization and space utilization analysis. '
             'Example: "WH/Stock/Shelf-A/Bin-3 contains 50 units of Product X". '
             'Important: Only internal storage and transit locations are included (usage=internal/transit) - customer/vendor locations excluded. '
             'Analysis: Use get_inventory_by_location() to see total inventory value and diversity per physical location. '
             'Related: Each location typically belongs to a warehouse (stock.warehouse) which may be assigned to a branch.'
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        readonly=True,
        help='The business unit (division/product line) that owns and manages this inventory based on product assignment. '
             'This enables BU-level inventory silos ensuring each division controls its own stock independently. '
             'Use Case: Generate separate inventory reports per BU for P&L accuracy and divisional performance measurement. '
             'Example: "Electronics BU has $500K inventory value across 200 SKUs, Clothing BU has $300K across 150 SKUs". '
             'Important: Inherited from product.template.business_unit_id - product BU assignment determines inventory ownership. '
             'Security: Users only see inventory from BUs they have access to via persona assignments. '
             'Analysis: Use verify_bu_segregation() to identify products incorrectly assigned to multiple BUs (data integrity check).'
    )
    
    quantity = fields.Float(
        string='Quantity On Hand',
        readonly=True,
        help='The total physical quantity of this product currently present in this location, regardless of reservations. '
             'This is the actual stock-on-hand including both available and reserved units. '
             'Use Case: Calculate total inventory investment, track stock movements over time, identify excess or shortage situations. '
             'Example: "100 units on-hand: 70 available for sale + 30 reserved for existing orders". '
             'Important: Measured in product\'s unit of measure (UoM) - pieces, kg, liters, etc. Check product.uom_id for unit. '
             'Calculation: Available Quantity = Quantity - Reserved Quantity. '
             'Warning: Zero or negative quantities indicate stock discrepancies requiring physical inventory count.'
    )
    
    standard_price = fields.Float(
        string='Unit Cost',
        readonly=True,
        help='The standard cost per unit for this product, used for inventory valuation and margin calculations. '
             'This represents the acquisition cost (for purchased goods) or production cost (for manufactured goods). '
             'Use Case: Calculate total inventory value (quantity × standard_price) and cost of goods sold (COGS) for margin analysis. '
             'Example: "Product cost $50/unit × 100 units = $5,000 inventory value". '
             'Important: This is the cost at the time of snapshot - does not reflect current purchase price if costs have changed. '
             'Warning: Standard price should be updated periodically to reflect actual costs - outdated costs distort profitability reports. '
             'Related: Compare with sale price to calculate potential margin before selling (sale_price - standard_price).'
    )
    
    stock_value = fields.Float(
        string='Stock Value',
        readonly=True,
        help='The total inventory value for this product at this location, calculated as (quantity × standard_price). '
             'This represents the total capital investment tied up in inventory at cost basis. '
             'Use Case: Track total inventory investment by location, product, and BU to manage working capital and inventory turns. '
             'Example: "100 units × $50/unit = $5,000 stock value in Location A". '
             'Important: Sum across all locations and products to get total inventory asset value for balance sheet. '
             'Analysis: High stock value + low turnover = excess inventory tying up cash. Target: minimize value while maintaining availability. '
             'Related: Compare total stock_value to monthly sales to calculate inventory turnover ratio (Days Inventory Outstanding).'
    )
    
    reserved_quantity = fields.Float(
        string='Reserved Qty',
        readonly=True,
        help='The quantity of this product already reserved/allocated for confirmed sales orders awaiting delivery. '
             'Reserved stock is physically on-hand but committed to customers - not available for new orders. '
             'Use Case: Calculate true available-to-promise (ATP) inventory for sales quotations and order fulfillment planning. '
             'Example: "100 units on-hand: 30 reserved for Order #123, 70 available for new orders". '
             'Important: Reservations are created when sales orders are confirmed, released when shipment is completed. '
             'Warning: High reserved_quantity relative to total quantity indicates pending fulfillment backlog - may need expedited shipping. '
             'Related: Available Quantity = Quantity - Reserved Quantity shows true sellable inventory.'
    )
    
    available_quantity = fields.Float(
        string='Available Qty',
        readonly=True,
        help='The quantity of this product available for new sales orders, calculated as (quantity - reserved_quantity). '
             'This is the true "sellable" inventory that can be promised to new customers without overselling. '
             'Use Case: Check available_quantity before accepting new orders to avoid stockouts and backorders. '
             'Example: "100 on-hand - 30 reserved = 70 available for new orders". '
             'Important: This is the Available-to-Promise (ATP) metric used by sales teams and e-commerce systems. '
             'Warning: Negative available_quantity indicates oversold situation - more reserved than on-hand (requires urgent replenishment). '
             'Analysis: Low available_quantity triggers reorder points - use with minimum stock rules to prevent stockouts. '
             'Related: Compare with demand forecast to ensure sufficient stock for upcoming sales without excess inventory.'
    )
    
    # ========================================================================
    # SQL VIEW CREATION
    # ========================================================================
    def init(self):
        """
        Create the PostgreSQL view when the model is initialized.
        
        The view:
        1. Queries stock_quant for all stock quantities
        2. Joins with product_product and product_template for BU
        3. Includes location information
        4. Calculates stock value
        5. Optimized for BU-aware inventory analysis
        """
        self.env.cr.execute(
            f"""
            CREATE OR REPLACE VIEW {self._table} AS (
                SELECT
                    -- Identification
                    sq.id,
                    sq.product_id,
                    sq.location_id,
                    
                    -- OPS Matrix Dimension (from product)
                    pt.business_unit_id AS ops_business_unit_id,
                    
                    -- Inventory quantities
                    sq.quantity,
                    CAST(pp.standard_price AS NUMERIC) AS standard_price,
                    sq.reserved_quantity,
                    
                    -- Calculated fields
                    (sq.quantity * CAST(pp.standard_price AS NUMERIC)) AS stock_value,
                    (sq.quantity - sq.reserved_quantity) AS available_quantity
                
                FROM stock_quant sq
                
                INNER JOIN product_product pp ON sq.product_id = pp.id
                INNER JOIN product_template pt ON pp.product_tmpl_id = pt.id
                
                WHERE
                    -- Only include locations that are actual warehouses/storage
                    sq.location_id IN (
                        SELECT id FROM stock_location 
                        WHERE usage IN ('internal', 'transit')
                    )
                    -- Only non-zero quantities (filter out ghost records)
                    AND (sq.quantity != 0 OR sq.reserved_quantity != 0)
            )
            """
        )
    
    # ========================================================================
    # STATISTICS & AGGREGATIONS
    # ========================================================================
    @api.model
    def get_summary_by_business_unit(self):
        """
        Get inventory summary grouped by business unit.
        
        Returns aggregated inventory data by BU:
        - Total on-hand quantity
        - Total reserved quantity
        - Total available quantity
        - Total stock value
        - Item count
        """
        self.env.cr.execute(
            """
            SELECT
                ops_business_unit_id,
                COUNT(DISTINCT product_id) as product_count,
                COUNT(*) as location_product_count,
                SUM(quantity) as total_on_hand,
                SUM(reserved_quantity) as total_reserved,
                SUM(available_quantity) as total_available,
                SUM(stock_value) as total_value
            FROM ops_inventory_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_business_unit_id
            ORDER BY total_value DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_inventory_by_location(self):
        """
        Get inventory summary grouped by location and business unit.
        
        Shows warehouse-level inventory positions:
        - Inventory by warehouse
        - Shows BU ownership
        - Identifies stock segregation
        """
        self.env.cr.execute(
            """
            SELECT
                location_id,
                ops_business_unit_id,
                COUNT(DISTINCT product_id) as product_count,
                SUM(quantity) as total_on_hand,
                SUM(reserved_quantity) as total_reserved,
                SUM(available_quantity) as total_available,
                SUM(stock_value) as location_bu_value
            FROM ops_inventory_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY location_id, ops_business_unit_id
            ORDER BY location_bu_value DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_low_stock_alerts(self, threshold_value=1000):
        """
        Get inventory items with low stock value (potential issue).
        
        :param threshold_value: Value threshold to flag as "low stock"
        :return: Products below value threshold by BU
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                ops_business_unit_id,
                location_id,
                COUNT(*) as location_count,
                SUM(quantity) as total_quantity,
                SUM(stock_value) as total_value
            FROM ops_inventory_analysis
            WHERE 
                ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY product_id, ops_business_unit_id, location_id
            HAVING SUM(stock_value) > 0 AND SUM(stock_value) < %s
            ORDER BY total_value ASC
            """,
            [self.env.uid, threshold_value]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_overstocked_items(self, threshold_qty=100):
        """
        Get inventory items with excess/overstock condition.
        
        Helps identify potentially slow-moving or obsolete stock:
        - High quantity
        - Low recent movement
        - By BU
        
        :param threshold_qty: Quantity threshold to flag as "overstocked"
        :return: Products above quantity threshold by BU
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                ops_business_unit_id,
                COUNT(*) as location_count,
                SUM(quantity) as total_quantity,
                SUM(available_quantity) as total_available,
                SUM(stock_value) as total_value,
                ROUND((SUM(quantity) / NULLIF(SUM(reserved_quantity), 0))::numeric, 2) as qty_to_reserved_ratio
            FROM ops_inventory_analysis
            WHERE 
                ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY product_id, ops_business_unit_id
            HAVING SUM(quantity) > %s
            ORDER BY total_value DESC
            """,
            [self.env.uid, threshold_qty]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def verify_bu_segregation(self):
        """
        Verify that inventory is properly segregated by Business Unit.
        
        Returns products where:
        - Quantities exist in multiple BU assignments (possible data integrity issue)
        - Used for BU-aware inventory audits
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                COUNT(DISTINCT ops_business_unit_id) as bu_count,
                ARRAY_AGG(DISTINCT ops_business_unit_id) as bu_ids,
                SUM(quantity) as total_qty,
                SUM(stock_value) as total_value
            FROM ops_inventory_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY product_id
            HAVING COUNT(DISTINCT ops_business_unit_id) > 1
            ORDER BY total_value DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    @api.model
    def create(self, vals):
        """Prevent creation of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be created.")
    
    def write(self, vals):
        """Prevent modification of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be modified.")
    
    def unlink(self):
        """Prevent deletion of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be deleted.")

>>> ops_matrix_reporting/models/ops_sales_analysis.py <<<
from odoo import models, fields, api
from odoo.sql_db import Cursor


class OpsSalesAnalysis(models.Model):
    """
    Sales Analysis Report - Read-Only SQL View
    
    This model represents a PostgreSQL materialized view that provides
    high-performance sales analytics with Branch and Business Unit dimensions.
    
    The view joins sale.order_line with sale.order to provide:
    - Date of sale
    - Product sold
    - Customer (partner)
    - Branch and Business Unit dimensions
    - Quantities and revenue
    - Margin calculations
    
    CRITICAL: This model is read-only (_auto=False) and backed by a PostgreSQL view.
    """
    
    _name = 'ops.sales.analysis'
    _description = 'Sales Analysis by Branch and Business Unit'
    _auto = False  # Don't auto-create table
    _rec_name = 'id'
    _order = 'date_order DESC'
    
    # ========================================================================
    # FIELDS - Mirror the View Columns
    # ========================================================================
    id = fields.Id(readonly=True)
    
    date_order = fields.Datetime(
        string='Order Date',
        readonly=True,
        help='Date and time when the sale order was created in the system. '
             'This field is used as the primary temporal dimension for sales trend analysis and period comparisons. '
             'Use Case: Filter by date range to analyze sales performance over specific periods (month, quarter, year). '
             'Example: "2025-01-01 to 2025-03-31" for Q1 sales analysis. '
             'Note: Only confirmed/done orders (state=sale/done) are included in this analysis view. '
             'Related: Combine with ops_branch_id and ops_business_unit_id for multi-dimensional time series analysis.'
    )
    
    product_id = fields.Many2one(
        'product.product',
        string='Product',
        readonly=True,
        help='The specific product variant sold in this transaction line. '
             'Used to analyze product performance, identify top sellers, and track product margins across dimensions. '
             'Use Case: Group by product_id to see total revenue and margin per product. '
             'Example: "Product A sold 500 units with 25% average margin in Branch X". '
             'Important: This is the variant (product.product), not the template (product.template). '
             'Analysis: Use get_margin_analysis() to identify products with negative margins that need price adjustments. '
             'Related: Combine with ops_business_unit_id to verify product silo enforcement.'
    )
    
    partner_id = fields.Many2one(
        'res.partner',
        string='Customer',
        readonly=True,
        help='The customer (partner) who purchased the products in this sale order. '
             'Used to analyze customer purchasing patterns, identify top customers, and track customer profitability by dimension. '
             'Use Case: Group by partner_id to calculate customer lifetime value (CLV) and average order value per branch/BU. '
             'Example: "Customer ABC generated $50K revenue across 3 branches with 22% average margin". '
             'Important: Only business partners with type=contact or company are included (not addresses). '
             'Analysis: Cross-reference with receivables reports to identify high-value customers with payment issues. '
             'Related: Filter by ops_branch_id to see which customers prefer specific branches or regions.'
    )
    
    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        readonly=True,
        help='The operational branch (location/store) that originated and owns this sale transaction. '
             'This is the primary geographic dimension for sales analysis and performance comparison across locations. '
             'Use Case: Compare revenue, margin, and volume across branches to identify high/low performers. '
             'Example: "Branch A: $100K revenue, 20% margin vs Branch B: $80K revenue, 25% margin". '
             'Important: This field respects user security rules - users only see sales from their allowed branches. '
             'Analysis: Use get_summary_by_branch() for aggregated branch performance metrics. '
             'Note: Legacy field name uses res.company model but represents operational branch concept.'
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        readonly=True,
        help='The business unit (product line/division) that owns this sale transaction. '
             'This is the product/service dimension for sales analysis, enabling P&L tracking by division. '
             'Use Case: Analyze which product lines (BUs) generate the most revenue and margin across different branches. '
             'Example: "Electronics BU: $200K revenue in 5 branches, Consumer Goods BU: $150K in 3 branches". '
             'Important: Combined with ops_branch_id, this creates the matrix intersection for true multi-dimensional analysis. '
             'Analysis: Use get_summary_by_matrix() to see Branch × BU performance grid. '
             'Security: Users only see BU data they have access to via their persona assignments.'
    )
    
    product_uom_qty = fields.Float(
        string='Quantity',
        readonly=True,
        help='The quantity of products sold in this transaction line, measured in the product\'s unit of measure (UoM). '
             'Used to calculate volume metrics, track unit sales trends, and compute average selling price per unit. '
             'Use Case: Track which products sell in high volumes vs high value but low volume (luxury goods). '
             'Example: "Product A sold 1000 units at $10 each = $10K revenue vs Product B sold 10 units at $1K = $10K revenue". '
             'Important: Quantity is in the product\'s default UoM (pieces, kg, liters, etc.) - check product.uom_id for unit type. '
             'Calculation: Average selling price = price_subtotal / product_uom_qty. '
             'Related: Compare with reserved_quantity in inventory analysis to forecast demand.'
    )
    
    price_subtotal = fields.Float(
        string='Subtotal (ex. tax)',
        readonly=True,
        help='The total revenue for this transaction line excluding taxes (net price × quantity). '
             'This is the primary revenue metric used for all sales analysis, margin calculations, and financial reporting. '
             'Use Case: Sum by dimension (branch/BU/time period) to calculate total revenue and compare performance. '
             'Example: "Branch A generated $50K subtotal in Q1 across 200 order lines". '
             'Important: Excludes taxes and shipping charges - use this for margin calculations, not customer invoices. '
             'Calculation: Margin = price_subtotal - (product_uom_qty × standard_price). '
             'Warning: Currency is the company currency - multi-currency sales are converted at transaction date rate.'
    )
    
    margin = fields.Float(
        string='Margin Amount',
        readonly=True,
        help='The gross profit amount for this transaction line, calculated as revenue minus cost of goods sold (COGS). '
             'Formula: margin = price_subtotal - (product_uom_qty × standard_price). '
             'Use Case: Identify which products, branches, or BUs generate the highest absolute profit contribution. '
             'Example: "$1000 revenue - $600 COGS = $400 margin". '
             'Important: Margin can be negative if selling below cost - use get_margin_analysis() to identify loss-making products. '
             'Warning: Based on standard_price (cost) at transaction time - does not reflect inventory valuation changes. '
             'Analysis: High margin products may need volume increases, low margin products may need price increases or cost reductions.'
    )
    
    margin_percent = fields.Float(
        string='Margin %',
        readonly=True,
        help='The gross profit margin expressed as a percentage of revenue, calculated as (margin / price_subtotal) × 100. '
             'This is the key profitability metric for comparing performance across products with different price points. '
             'Use Case: Identify high-margin products (>30%) and low-margin products (<10%) to guide pricing strategy. '
             'Example: "$400 margin / $1000 revenue = 40% margin percentage". '
             'Interpretation: 0% = break-even, <0% = loss, 10-20% = competitive, 20-30% = good, >30% = excellent. '
             'Warning: Percentage can be misleading - a 50% margin on a $10 sale ($5 profit) is less valuable than 10% on $1000 ($100 profit). '
             'Related: Compare margin_percent across branches to identify operational efficiency differences or pricing inconsistencies.'
    )
    
    # ========================================================================
    # SQL VIEW CREATION
    # ========================================================================
    def init(self):
        """
        Create the PostgreSQL view when the model is initialized.
        
        The view:
        1. Joins sale.order_line with sale.order
        2. Filters for confirmed orders (state in confirmed, done)
        3. Calculates margin as (price_subtotal - cogs)
        4. Includes Branch and Business Unit dimensions
        5. Optimized for pivot/grouping operations
        """
        self.env.cr.execute(
            f"""
            CREATE OR REPLACE VIEW {self._table} AS (
                SELECT
                    -- Identification
                    sol.id::integer AS id,
                    
                    -- Temporal
                    so.date_order::timestamp AS date_order,
                    
                    -- Products & Customers (explicit integer casting for Many2one fields)
                    sol.product_id::integer AS product_id,
                    so.partner_id::integer AS partner_id,
                    
                    -- OPS Matrix Dimensions (explicit integer casting for Many2one fields)
                    so.ops_branch_id::integer AS ops_branch_id,
                    so.ops_business_unit_id::integer AS ops_business_unit_id,
                    
                    -- Quantities & Revenue (explicit numeric casting for float fields)
                    sol.product_uom_qty::numeric AS product_uom_qty,
                    sol.price_subtotal::numeric AS price_subtotal,
                    
                    -- Margin Calculation (already numeric from computation)
                    (
                        sol.price_subtotal::numeric -
                        (sol.product_uom_qty::numeric * COALESCE(CAST(pp.standard_price AS NUMERIC), 0))
                    )::numeric AS margin,
                    
                    -- Margin Percentage (already numeric from computation)
                    CASE
                        WHEN sol.price_subtotal = 0 THEN 0::numeric
                        ELSE ROUND(
                            (
                                (
                                    sol.price_subtotal::numeric -
                                    (sol.product_uom_qty::numeric * COALESCE(CAST(pp.standard_price AS NUMERIC), 0))
                                ) / sol.price_subtotal::numeric * 100
                            )::numeric,
                            2
                        )
                    END AS margin_percent
                
                FROM sale_order_line sol
                
                INNER JOIN sale_order so ON sol.order_id = so.id
                LEFT JOIN product_product pp ON sol.product_id = pp.id
                LEFT JOIN product_template pt ON pp.product_tmpl_id = pt.id
                
                WHERE
                    -- Only include confirmed/done orders
                    so.state IN ('sale', 'done')
                    -- Exclude cancelled lines
                    AND sol.state != 'cancel'
            )
            """
        )
    
    # ========================================================================
    # STATISTICS & AGGREGATIONS
    # ========================================================================
    @api.model
    def get_summary_by_branch(self):
        """
        Get summary statistics grouped by branch.
        
        Returns aggregated sales data by branch:
        - Total revenue
        - Total margin
        - Average margin %
        - Total units sold
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                COUNT(*) as line_count,
                SUM(product_uom_qty) as total_qty,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent
            FROM ops_sales_analysis
            WHERE ops_branch_id IN (
                SELECT id FROM res_company
                WHERE id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_branch_id
            ORDER BY total_revenue DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_summary_by_business_unit(self):
        """
        Get summary statistics grouped by business unit.
        
        Returns aggregated sales data by BU:
        - Total revenue
        - Total margin
        - Average margin %
        - Total units sold
        """
        self.env.cr.execute(
            """
            SELECT
                ops_business_unit_id,
                COUNT(*) as line_count,
                SUM(product_uom_qty) as total_qty,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent
            FROM ops_sales_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_business_unit_id
            ORDER BY total_revenue DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_summary_by_matrix(self):
        """
        Get summary statistics grouped by Branch AND Business Unit (matrix view).
        
        Returns aggregated sales data by the Branch/BU matrix intersection:
        - Revenue per dimension pair
        - Margin per dimension pair
        - Units per dimension pair
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                ops_business_unit_id,
                COUNT(*) as line_count,
                SUM(product_uom_qty) as total_qty,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent
            FROM ops_sales_analysis
            WHERE 
                ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY ops_branch_id, ops_business_unit_id
            ORDER BY total_revenue DESC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_margin_analysis(self):
        """
        Get detailed margin analysis by product, branch, and BU.
        
        Identifies products and dimensions with:
        - Highest margins
        - Lowest margins
        - Negative margin (loss-making) products
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                ops_branch_id,
                ops_business_unit_id,
                COUNT(*) as transaction_count,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin
            FROM ops_sales_analysis
            WHERE 
                ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY product_id, ops_branch_id, ops_business_unit_id
            ORDER BY avg_margin_percent ASC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    @api.model
    def create(self, vals):
        """Prevent creation of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be created.")
    
    def write(self, vals):
        """Prevent modification of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be modified.")
    
    def unlink(self):
        """Prevent deletion of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be deleted.")

>>> ops_matrix_reporting/wizard/__init__.py <<<
# -*- coding: utf-8 -*-
from . import ops_excel_export_wizard

>>> ops_matrix_reporting/wizard/ops_excel_export_wizard.py <<<
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import io
import base64
import logging

_logger = logging.getLogger(__name__)

try:
    import xlsxwriter
except ImportError:
    _logger.warning("xlsxwriter library not found. Excel export will not be available.")
    xlsxwriter = None


class OpsExcelExportWizard(models.TransientModel):
    _name = 'ops.excel.export.wizard'
    _description = 'OPS Excel Export Wizard'
    
    report_type = fields.Selection([
        ('sales', 'Sales Analysis'),
        ('financial', 'Financial Analysis'),
        ('inventory', 'Inventory Analysis'),
    ], string='Report Type', required=True, default='sales')
    
    date_from = fields.Date(string='Date From')
    date_to = fields.Date(string='Date To')
    
    branch_ids = fields.Many2many(
        'res.company', 
        string='Branches',
        help='Leave empty to include all branches'
    )
    
    business_unit_ids = fields.Many2many(
        'ops.business.unit', 
        string='Business Units',
        help='Leave empty to include all business units'
    )
    
    filename = fields.Char(string='Filename', readonly=True)
    excel_file = fields.Binary(string='Excel File', readonly=True)
    state = fields.Selection([
        ('draft', 'Draft'),
        ('done', 'Done'),
    ], default='draft')
    
    @api.constrains('date_from', 'date_to')
    def _check_dates(self):
        """Validate date range."""
        for wizard in self:
            if wizard.date_from and wizard.date_to:
                if wizard.date_from > wizard.date_to:
                    raise ValidationError(
                        _('The start date must be earlier than the end date.')
                    )
    
    def action_generate_excel(self):
        """Generate Excel file based on report type."""
        self.ensure_one()
        
        # Check if xlsxwriter is available
        if xlsxwriter is None:
            raise UserError(
                _('Excel export functionality is not available. '
                  'Please install the xlsxwriter Python library:\n\n'
                  'pip install xlsxwriter')
            )
        
        try:
            # Generate Excel file
            if self.report_type == 'sales':
                excel_data = self._generate_sales_excel()
                filename = 'sales_analysis.xlsx'
            elif self.report_type == 'financial':
                excel_data = self._generate_financial_excel()
                filename = 'financial_analysis.xlsx'
            elif self.report_type == 'inventory':
                excel_data = self._generate_inventory_excel()
                filename = 'inventory_analysis.xlsx'
            else:
                raise ValidationError(_('Invalid report type selected.'))
            
            # Save file to wizard
            self.write({
                'excel_file': base64.b64encode(excel_data),
                'filename': filename,
                'state': 'done',
            })
            
            # Return action to download file
            return {
                'type': 'ir.actions.act_window',
                'res_model': 'ops.excel.export.wizard',
                'view_mode': 'form',
                'res_id': self.id,
                'target': 'new',
            }
            
        except Exception as e:
            _logger.exception("Error generating Excel export")
            raise UserError(
                _('Failed to generate Excel file:\n\n%s') % str(e)
            )
    
    def _generate_sales_excel(self):
        """Generate Sales Analysis Excel report."""
        # Build domain
        domain = []
        if self.date_from:
            domain.append(('date_order', '>=', self.date_from))
        if self.date_to:
            domain.append(('date_order', '<=', self.date_to))
        if self.branch_ids:
            domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
        if self.business_unit_ids:
            domain.append(('ops_business_unit_id', 'in', self.business_unit_ids.ids))
        
        # Fetch data
        sales_data = self.env['ops.sales.analysis'].search_read(
            domain,
            ['date_order', 'product_id', 'partner_id', 'ops_branch_id', 
             'ops_business_unit_id', 'product_uom_qty', 'price_subtotal', 
             'margin', 'margin_percent'],
            order='date_order desc, partner_id'
        )
        
        # Create Excel file
        output = io.BytesIO()
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet('Sales Analysis')
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#4472C4',
            'font_color': 'white',
            'border': 1,
            'align': 'center',
            'valign': 'vcenter',
        })
        
        currency_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        percent_format = workbook.add_format({
            'num_format': '0.00%',
            'border': 1,
        })
        
        number_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        text_format = workbook.add_format({'border': 1})
        
        # Set column widths
        worksheet.set_column('A:A', 12)  # Date
        worksheet.set_column('B:B', 30)  # Product
        worksheet.set_column('C:C', 25)  # Customer
        worksheet.set_column('D:D', 20)  # Branch
        worksheet.set_column('E:E', 20)  # Business Unit
        worksheet.set_column('F:F', 12)  # Quantity
        worksheet.set_column('G:G', 15)  # Revenue
        worksheet.set_column('H:H', 15)  # Margin
        worksheet.set_column('I:I', 12)  # Margin %
        
        # Write headers
        headers = ['Date', 'Product', 'Customer', 'Branch', 'Business Unit', 
                   'Quantity', 'Revenue', 'Margin', 'Margin %']
        for col, header in enumerate(headers):
            worksheet.write(0, col, header, header_format)
        
        # Write data
        row = 1
        total_qty = 0
        total_revenue = 0
        total_margin = 0
        
        for record in sales_data:
            worksheet.write(row, 0, record['date_order'], text_format)
            worksheet.write(row, 1, record['product_id'][1] if record.get('product_id') else '', text_format)
            worksheet.write(row, 2, record['partner_id'][1] if record.get('partner_id') else '', text_format)
            worksheet.write(row, 3, record['ops_branch_id'][1] if record.get('ops_branch_id') else '', text_format)
            worksheet.write(row, 4, record['ops_business_unit_id'][1] if record.get('ops_business_unit_id') else '', text_format)
            worksheet.write(row, 5, record['product_uom_qty'], number_format)
            worksheet.write(row, 6, record['price_subtotal'], currency_format)
            worksheet.write(row, 7, record['margin'], currency_format)
            worksheet.write(row, 8, record['margin_percent'] / 100, percent_format)
            
            total_qty += record['product_uom_qty']
            total_revenue += record['price_subtotal']
            total_margin += record['margin']
            row += 1
        
        # Write totals
        total_format = workbook.add_format({
            'bold': True,
            'bg_color': '#E7E6E6',
            'border': 1,
            'num_format': '#,##0.00',
        })
        
        worksheet.write(row, 4, 'TOTAL:', total_format)
        worksheet.write(row, 5, total_qty, total_format)
        worksheet.write(row, 6, total_revenue, total_format)
        worksheet.write(row, 7, total_margin, total_format)
        avg_margin = (total_margin / total_revenue * 100) if total_revenue else 0
        worksheet.write(row, 8, f'{avg_margin:.2f}%', total_format)
        
        workbook.close()
        output.seek(0)
        return output.read()
    
    def _generate_financial_excel(self):
        """Generate Financial Analysis Excel report."""
        # Build domain
        domain = []
        if self.date_from:
            domain.append(('date', '>=', self.date_from))
        if self.date_to:
            domain.append(('date', '<=', self.date_to))
        if self.branch_ids:
            domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
        if self.business_unit_ids:
            domain.append(('ops_business_unit_id', 'in', self.business_unit_ids.ids))
        
        # Fetch data
        financial_data = self.env['ops.financial.analysis'].search_read(
            domain,
            ['date', 'account_id', 'ops_branch_id', 'ops_business_unit_id', 
             'move_type', 'partner_id', 'debit', 'credit', 'balance'],
            order='date desc, account_id'
        )
        
        # Create Excel file
        output = io.BytesIO()
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet('Financial Analysis')
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#70AD47',
            'font_color': 'white',
            'border': 1,
            'align': 'center',
        })
        
        currency_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        text_format = workbook.add_format({'border': 1})
        
        # Set column widths
        worksheet.set_column('A:A', 12)
        worksheet.set_column('B:B', 30)
        worksheet.set_column('C:C', 20)
        worksheet.set_column('D:D', 20)
        worksheet.set_column('E:E', 15)
        worksheet.set_column('F:F', 25)
        worksheet.set_column('G:G', 15)
        worksheet.set_column('H:H', 15)
        worksheet.set_column('I:I', 15)
        
        # Write headers
        headers = ['Date', 'Account', 'Branch', 'Business Unit', 'Move Type', 
                   'Partner', 'Debit', 'Credit', 'Balance']
        for col, header in enumerate(headers):
            worksheet.write(0, col, header, header_format)
        
        # Write data
        row = 1
        total_debit = 0
        total_credit = 0
        total_balance = 0
        
        for record in financial_data:
            worksheet.write(row, 0, record['date'], text_format)
            worksheet.write(row, 1, record['account_id'][1] if record.get('account_id') else '', text_format)
            worksheet.write(row, 2, record['ops_branch_id'][1] if record.get('ops_branch_id') else '', text_format)
            worksheet.write(row, 3, record['ops_business_unit_id'][1] if record.get('ops_business_unit_id') else '', text_format)
            worksheet.write(row, 4, record.get('move_type', ''), text_format)
            worksheet.write(row, 5, record['partner_id'][1] if record.get('partner_id') else '', text_format)
            worksheet.write(row, 6, record['debit'], currency_format)
            worksheet.write(row, 7, record['credit'], currency_format)
            worksheet.write(row, 8, record['balance'], currency_format)
            
            total_debit += record['debit']
            total_credit += record['credit']
            total_balance += record['balance']
            row += 1
        
        # Write totals
        total_format = workbook.add_format({
            'bold': True,
            'bg_color': '#E7E6E6',
            'border': 1,
            'num_format': '#,##0.00',
        })
        
        worksheet.write(row, 5, 'TOTAL:', total_format)
        worksheet.write(row, 6, total_debit, total_format)
        worksheet.write(row, 7, total_credit, total_format)
        worksheet.write(row, 8, total_balance, total_format)
        
        workbook.close()
        output.seek(0)
        return output.read()
    
    def _generate_inventory_excel(self):
        """Generate Inventory Analysis Excel report."""
        # Build domain
        domain = []
        if self.business_unit_ids:
            domain.append(('ops_business_unit_id', 'in', self.business_unit_ids.ids))
        
        # Fetch data
        inventory_data = self.env['ops.inventory.analysis'].search_read(
            domain,
            ['product_id', 'location_id', 'ops_business_unit_id', 'quantity', 
             'reserved_quantity', 'available_quantity', 'standard_price', 'stock_value'],
            order='product_id, location_id'
        )
        
        # Create Excel file
        output = io.BytesIO()
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet('Inventory Analysis')
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#FFC000',
            'font_color': 'white',
            'border': 1,
            'align': 'center',
        })
        
        currency_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        number_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        text_format = workbook.add_format({'border': 1})
        
        # Set column widths
        worksheet.set_column('A:A', 35)
        worksheet.set_column('B:B', 30)
        worksheet.set_column('C:C', 20)
        worksheet.set_column('D:D', 12)
        worksheet.set_column('E:E', 12)
        worksheet.set_column('F:F', 12)
        worksheet.set_column('G:G', 12)
        worksheet.set_column('H:H', 15)
        
        # Write headers
        headers = ['Product', 'Location', 'Business Unit', 'On Hand', 'Reserved', 
                   'Available', 'Unit Price', 'Stock Value']
        for col, header in enumerate(headers):
            worksheet.write(0, col, header, header_format)
        
        # Write data
        row = 1
        total_on_hand = 0
        total_reserved = 0
        total_available = 0
        total_value = 0
        
        for record in inventory_data:
            worksheet.write(row, 0, record['product_id'][1] if record.get('product_id') else '', text_format)
            worksheet.write(row, 1, record['location_id'][1] if record.get('location_id') else '', text_format)
            worksheet.write(row, 2, record['ops_business_unit_id'][1] if record.get('ops_business_unit_id') else '', text_format)
            worksheet.write(row, 3, record['quantity'], number_format)
            worksheet.write(row, 4, record['reserved_quantity'], number_format)
            worksheet.write(row, 5, record['available_quantity'], number_format)
            worksheet.write(row, 6, record['standard_price'], currency_format)
            worksheet.write(row, 7, record['stock_value'], currency_format)
            
            total_on_hand += record['quantity']
            total_reserved += record['reserved_quantity']
            total_available += record['available_quantity']
            total_value += record['stock_value']
            row += 1
        
        # Write totals
        total_format = workbook.add_format({
            'bold': True,
            'bg_color': '#E7E6E6',
            'border': 1,
            'num_format': '#,##0.00',
        })
        
        worksheet.write(row, 2, 'TOTAL:', total_format)
        worksheet.write(row, 3, total_on_hand, total_format)
        worksheet.write(row, 4, total_reserved, total_format)
        worksheet.write(row, 5, total_available, total_format)
        worksheet.write(row, 6, '', total_format)
        worksheet.write(row, 7, total_value, total_format)
        
        workbook.close()
        output.seek(0)
        return output.read()
    
    def action_download(self):
        """Download the generated Excel file."""
        self.ensure_one()
        
        if not self.excel_file:
            raise UserError(_('No Excel file has been generated yet.'))
        
        return {
            'type': 'ir.actions.act_url',
            'url': f'/web/content/ops.excel.export.wizard/{self.id}/excel_file/{self.filename}?download=true',
            'target': 'self',
        }


========================================
END OF EXPORT
========================================
