============================================
MODULE: ops_matrix_core
============================================

>>> STRUCTURE <<<
ops_matrix_core/__init__.py
ops_matrix_core/__manifest__.py
ops_matrix_core/controllers/__init__.py
ops_matrix_core/controllers/availability_report.py
ops_matrix_core/controllers/ops_matrix_api.py
ops_matrix_core/data/ir_cron_archiver.xml
ops_matrix_core/data/ir_cron_data.xml
ops_matrix_core/data/ir_module_category.xml
ops_matrix_core/data/ir_sequence_data.xml
ops_matrix_core/data/ops_account_templates.xml
ops_matrix_core/data/ops_archive_templates.xml
ops_matrix_core/data/ops_default_data.xml
ops_matrix_core/data/ops_default_data_clean.xml
ops_matrix_core/data/ops_governance_rule_templates.xml
ops_matrix_core/data/ops_governance_templates.xml
ops_matrix_core/data/ops_governance_templates_extended.xml
ops_matrix_core/data/ops_persona_templates.xml
ops_matrix_core/data/ops_product_templates.xml
ops_matrix_core/data/ops_seed_test_data.py
ops_matrix_core/data/ops_sla_templates.xml
ops_matrix_core/data/product_rules.xml
ops_matrix_core/data/res_groups.xml
ops_matrix_core/data/sale_order_actions.xml
ops_matrix_core/data/templates/ops_governance_rule_templates.xml
ops_matrix_core/data/templates/ops_persona_templates.xml
ops_matrix_core/data/templates/ops_sla_templates.xml
ops_matrix_core/data/templates/ops_user_templates.xml
ops_matrix_core/demo/ops_demo_data.xml
ops_matrix_core/demo/ops_demo_data_clean.xml
ops_matrix_core/hooks.py
ops_matrix_core/migrations/19.0.1.0/__init__.py
ops_matrix_core/migrations/19.0.1.0/post_migration.py
ops_matrix_core/migrations/__init__.py
ops_matrix_core/models/__init__.py
ops_matrix_core/models/account_move.py
ops_matrix_core/models/ir_actions_report.py
ops_matrix_core/models/mail_message.py
ops_matrix_core/models/ops_analytic_mixin.py
ops_matrix_core/models/ops_analytic_setup.py
ops_matrix_core/models/ops_api_key.py
ops_matrix_core/models/ops_approval_dashboard.py
ops_matrix_core/models/ops_approval_request.py
ops_matrix_core/models/ops_archive_policy.py
ops_matrix_core/models/ops_audit_log.py
ops_matrix_core/models/ops_branch.py
ops_matrix_core/models/ops_business_unit.py
ops_matrix_core/models/ops_dashboard_config.py
ops_matrix_core/models/ops_dashboard_widget.py
ops_matrix_core/models/ops_governance_limits.py
ops_matrix_core/models/ops_governance_mixin.py
ops_matrix_core/models/ops_governance_rule.py
ops_matrix_core/models/ops_inter_branch_transfer.py
ops_matrix_core/models/ops_matrix_config.py
ops_matrix_core/models/ops_matrix_mixin.py
ops_matrix_core/models/ops_mixin.py
ops_matrix_core/models/ops_performance_indexes.py
ops_matrix_core/models/ops_persona.py
ops_matrix_core/models/ops_persona_delegation.py
ops_matrix_core/models/ops_product_request.py
ops_matrix_core/models/ops_security_audit.py
ops_matrix_core/models/ops_security_rules.py
ops_matrix_core/models/ops_sla_instance.py
ops_matrix_core/models/ops_sla_mixin.py
ops_matrix_core/models/ops_sla_template.py
ops_matrix_core/models/partner.py
ops_matrix_core/models/pricelist.py
ops_matrix_core/models/product.py
ops_matrix_core/models/purchase_order.py
ops_matrix_core/models/res_company.py
ops_matrix_core/models/res_users.py
ops_matrix_core/models/sale_order.py
ops_matrix_core/models/sale_order_import_wizard.py
ops_matrix_core/models/stock_move.py
ops_matrix_core/models/stock_picking.py
ops_matrix_core/models/stock_quant.py
ops_matrix_core/models/stock_warehouse.py
ops_matrix_core/models/stock_warehouse_orderpoint.py
ops_matrix_core/reports/ops_products_availability_report.xml
ops_matrix_core/security/ir_rule.xml
ops_matrix_core/static/src/components/matrix_availability_tab/matrix_availability_tab.xml
ops_matrix_core/tests/__init__.py
ops_matrix_core/tests/common.py
ops_matrix_core/tests/test_analytic_setup.py
ops_matrix_core/tests/test_matrix_foundation.py
ops_matrix_core/tests/test_matrix_governance.py
ops_matrix_core/tests/test_matrix_integration.py
ops_matrix_core/tests/test_matrix_reporting.py
ops_matrix_core/tests/test_matrix_security.py
ops_matrix_core/tests/test_matrix_transactions.py
ops_matrix_core/tests/test_workflows.py
ops_matrix_core/tools/test_api_client.py
ops_matrix_core/views/account_move_views.xml
ops_matrix_core/views/ops_analytic_views.xml
ops_matrix_core/views/ops_api_key_views.xml
ops_matrix_core/views/ops_approval_dashboard_views.xml
ops_matrix_core/views/ops_approval_request_views.xml
ops_matrix_core/views/ops_archive_policy_views.xml
ops_matrix_core/views/ops_audit_log_views.xml
ops_matrix_core/views/ops_branch_dashboard_views.xml
ops_matrix_core/views/ops_branch_views.xml
ops_matrix_core/views/ops_bu_dashboard_views.xml
ops_matrix_core/views/ops_business_unit_views.xml
ops_matrix_core/views/ops_dashboard_config_views.xml
ops_matrix_core/views/ops_dashboard_menu.xml
ops_matrix_core/views/ops_executive_dashboard_views.xml
ops_matrix_core/views/ops_governance_rule_views.xml
ops_matrix_core/views/ops_governance_violation_report_views.xml
ops_matrix_core/views/ops_inter_branch_transfer_views.xml
ops_matrix_core/views/ops_persona_delegation_views.xml
ops_matrix_core/views/ops_persona_views.xml
ops_matrix_core/views/ops_product_request_views.xml
ops_matrix_core/views/ops_sales_dashboard_views.xml
ops_matrix_core/views/ops_sla_instance_views.xml
ops_matrix_core/views/ops_sla_template_views.xml
ops_matrix_core/views/partner_views.xml
ops_matrix_core/views/product_silo_views.xml
ops_matrix_core/views/product_views.xml
ops_matrix_core/views/res_company_views.xml
ops_matrix_core/views/res_users_views.xml
ops_matrix_core/views/sale_order_import_wizard_views.xml
ops_matrix_core/views/sale_order_views.xml
ops_matrix_core/views/stock_picking_views.xml
ops_matrix_core/views/stock_warehouse_orderpoint_views.xml
ops_matrix_core/wizard/__init__.py
ops_matrix_core/wizard/ops_governance_violation_report.py
ops_matrix_core/wizard/ops_welcome_wizard.py

>>> __manifest__.py <<<
# -*- coding: utf-8 -*-
{
    'name': 'OPS Matrix Core',
    'version': '19.0.1.3',
    'category': 'Operations',
    'summary': 'Core module for OPS Matrix Framework',
    'description': """
        OPS Matrix Framework - Core Module
        ==================================
        This module provides the foundation for the OPS Matrix Framework.
        It includes Company, Branch, Business Unit models and the security framework.
    """,
    'author': 'Gemini Agent',
    'website': 'https://www.example.com',
    'license': 'LGPL-3',
    'depends': [
        'base',
        'mail',
        'analytic',
        'account',
        'sale',
        'purchase',
        'stock',
        'hr',  # Required for ops.persona employee_id field
    ],
    'data': [
        # Load in exact order
        # Data & Config (Groups must load first)
        'data/ir_module_category.xml',
        'data/res_groups.xml',
        
        # Security (depends on groups)
        'security/ir.model.access.csv',
        'security/ir_rule.xml',
        
        # Sequences and core data
        'data/ir_sequence_data.xml',
        
        # Template Data Files (Active templates for reference)
        'data/templates/ops_persona_templates.xml',
        'data/templates/ops_governance_rule_templates.xml',
        'data/templates/ops_sla_templates.xml',
        
        # Views - Main Structure (load Business Unit before Branch, as Branch references BU action)
        'views/ops_business_unit_views.xml',
        'views/ops_branch_views.xml',
        'views/res_company_views.xml',
        'views/ops_inter_branch_transfer_views.xml',
        
        # Views - Persona Engine
        'views/ops_persona_views.xml',
        'views/ops_persona_delegation_views.xml',
        'views/res_users_views.xml',
        
        # Views - Governance & Approvals
        'views/ops_approval_request_views.xml',
        'views/ops_governance_rule_views.xml',
        'views/ops_approval_dashboard_views.xml',
        'views/ops_governance_violation_report_views.xml',
        'views/ops_archive_policy_views.xml',
        'views/ops_analytic_views.xml',
        
        # Views - SLA
        'views/ops_sla_template_views.xml',
        'views/ops_sla_instance_views.xml',
        
        # Views - Dashboards (CE compatible)
        'views/ops_executive_dashboard_views.xml',
        'views/ops_branch_dashboard_views.xml',
        'views/ops_bu_dashboard_views.xml',
        'views/ops_sales_dashboard_views.xml',
        'views/ops_dashboard_menu.xml',
        'views/ops_dashboard_config_views.xml',
        
        # Views - Standard Model Extensions
        'views/product_views.xml',
        'views/partner_views.xml',
        'views/sale_order_views.xml',
        'views/sale_order_import_wizard_views.xml',
        'views/account_move_views.xml',
        'views/stock_picking_views.xml',
        'views/stock_warehouse_orderpoint_views.xml',
        'views/product_silo_views.xml',
        
        # Views - API Integration & Security
        'views/ops_api_key_views.xml',
        'views/ops_audit_log_views.xml',
        
        # Additional data
        'data/ir_cron_data.xml',
        'data/ir_cron_archiver.xml',
        'data/sale_order_actions.xml',
        
        # Archive policy templates (inactive by default)
        'data/ops_archive_templates.xml',
        
        # Reports
        'reports/ops_products_availability_report.xml',
    ],
    'demo': [
        'demo/ops_demo_data.xml',
    ],
    'assets': {
        'web.assets_backend': [
            'ops_matrix_core/static/src/js/storage_guard.js',  # Load first for safety
            'ops_matrix_core/static/src/js/report_action_override.js',
        ],
    },
    'post_init_hook': 'post_init_hook',
    'installable': True,
    'application': True,
    'auto_install': False,
}
--- ops_matrix_core/models/__init__.py ---
# -*- coding: utf-8 -*-

# ==================================================================
# CRITICAL: Import Order Matters - Dependencies!
# ==================================================================
# 1. Core Structure (Company â†’ Branch â†’ BU â†’ Config â†’ Mixin)
from . import res_company          # First: base Odoo model
from . import ops_branch            # Second: Branch model (depends on company)
from . import ops_business_unit     # Third: BU model (depends on branch)
from . import ops_matrix_config     # Fourth: Configuration model
from . import ops_mixin             # Fifth: Mixin (depends on branch/BU)
from . import ops_matrix_mixin      # Sixth: Matrix dimension propagation mixin
from . import ops_analytic_setup    # Analytic accounting setup wizard
from . import ops_performance_indexes  # Performance optimization indexes

# 2. Security Engine (depends on user model)
from . import ops_security_rules    # Security rule engine
from . import ops_security_audit    # Security audit logging

# 2a. API Authentication & Audit Logging
from . import ops_api_key           # API key management
from . import ops_audit_log         # API audit logging

# 3. Persona Engine (depends on branch/BU)
from . import ops_persona
from . import ops_persona_delegation
from . import res_users

# 3a. Inter-Branch Transfers
from . import ops_inter_branch_transfer

# 4. Governance & Approvals
from . import ops_governance_mixin
from . import ops_governance_limits      # NEW: Related limit models
from . import ops_governance_rule
from . import ops_approval_request
from . import ops_approval_dashboard
from . import ops_archive_policy

# 5. SLA Engine
from . import ops_sla_mixin
from . import ops_sla_template
from . import ops_sla_instance

# 6. Dashboard Configuration
from . import ops_dashboard_config
from . import ops_dashboard_widget

# 7. Standard Model Extensions
from . import ir_actions_report  # Governance enforcement on PDF generation
from . import product
from . import partner
from . import pricelist
from . import sale_order
from . import purchase_order
from . import account_move
from . import stock_warehouse
from . import stock_warehouse_orderpoint
from . import stock_picking
from . import stock_move
from . import stock_quant
from . import mail_message

# 7. Product Requests
from . import ops_product_request

# 8. Wizards (Located in models folder currently)
from . import sale_order_import_wizard

--- ops_matrix_core/models/account_move.py ---
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
import logging

_logger = logging.getLogger(__name__)

class AccountMove(models.Model):
    _inherit = ['account.move', 'ops.matrix.mixin']
    _name = 'account.move'
    
    # The following fields are inherited from ops.matrix.mixin:
    # - ops_branch_id (Many2one to res.company - will be ops.branch)
    # - ops_business_unit_id (Many2one to ops.business.unit)
    # - ops_company_id (computed Many2one to res.company)
    # - ops_analytic_distribution (computed Json field)
    
    # ========================================================================
    # ADDITIONAL FIELDS
    # ========================================================================
    
    ops_source_order_id = fields.Reference(
        [('sale.order', 'Sale Order'), ('purchase.order', 'Purchase Order')],
        string='Source Order',
        help='Original order that generated this invoice/bill',
        readonly=True
    )
    
    ops_analytic_summary = fields.Char(
        compute='_compute_analytic_summary',
        string='Analytic Summary',
        store=True,
        help='Summary of Branch and Business Unit dimensions'
    )
    
    # Anti-Fraud Security: Button-level authority for invoice posting
    can_user_validate_invoices = fields.Boolean(
        compute='_compute_can_user_validate_invoices',
        string='Can Validate Invoices',
        help='Technical field: User has authority to post/validate invoices'
    )
    
    # ========================================================================
    # COMPUTE METHODS
    # ========================================================================
    
    @api.depends_context('uid')
    def _compute_can_user_validate_invoices(self):
        """
        Check if current user has authority to validate invoices.
        
        ADMIN BYPASS: System administrators always have access.
        PERSONA LOGIC: Uses additive authority - if ANY persona grants the right, access is granted.
        """
        for record in self:
            # Admin bypass
            if self.env.su or self.env.user.has_group('base.group_system'):
                record.can_user_validate_invoices = True
            else:
                # Check persona authority using the helper method
                record.can_user_validate_invoices = self.env.user.has_ops_authority('can_validate_invoices')
    
    @api.depends('ops_branch_id', 'ops_business_unit_id')
    def _compute_analytic_summary(self):
        """Compute human-readable summary of matrix dimensions."""
        for move in self:
            parts = []
            if move.ops_branch_id:
                branch_code = move.ops_branch_id.code if hasattr(move.ops_branch_id, 'code') else move.ops_branch_id.name
                parts.append(_("Branch: %s") % branch_code)
            if move.ops_business_unit_id:
                bu_code = move.ops_business_unit_id.code if hasattr(move.ops_business_unit_id, 'code') else move.ops_business_unit_id.name
                parts.append(_("BU: %s") % bu_code)
            
            move.ops_analytic_summary = " | ".join(parts) if parts else _("No dimensions")
    
    # ========================================================================
    # CRUD METHODS
    # ========================================================================
    
    @api.model_create_multi
    def create(self, vals_list):
        """Auto-assign analytic distribution from matrix dimensions when creating moves."""
        # First, propagate dimensions from source orders
        for vals in vals_list:
            self._propagate_matrix_dimensions(vals)
        
        # Create the records
        moves = super().create(vals_list)
        
        # Then update analytic distribution for each move
        for move in moves:
            # Only update if we have branch or BU (may have been set via defaults)
            if move.ops_branch_id or move.ops_business_unit_id:
                # Compute distribution based on current values
                distribution = move._compute_analytic_distribution_values()
                
                # Apply to all move lines
                if distribution and move.line_ids:
                    for line in move.line_ids:
                        # Only update if line doesn't already have analytic distribution
                        if not line.analytic_distribution:
                            line.analytic_distribution = distribution
        
        return moves
    
    def write(self, vals):
        """Update analytic distribution when matrix dimensions change."""
        # Capture old values for branch and BU before write
        old_branch_values = {move.id: move.ops_branch_id for move in self}
        old_bu_values = {move.id: move.ops_business_unit_id for move in self}
        
        # Perform the write
        result = super().write(vals)
        
        # Check if we need to update analytic distribution
        update_moves = self.filtered(lambda m: (
            (m.id in old_branch_values and m.ops_branch_id != old_branch_values[m.id]) or
            (m.id in old_bu_values and m.ops_business_unit_id != old_bu_values[m.id])
        ))
        
        if update_moves:
            for move in update_moves:
                # Only update draft or posted moves (based on business rules)
                if move.state in ('draft', 'posted'):
                    distribution = move._compute_analytic_distribution_values()
                    
                    if distribution:
                        # Update lines that don't have manual analytic assignments
                        for line in move.line_ids.filtered(lambda l: not l.analytic_distribution):
                            line.analytic_distribution = distribution
                    
                    # Log the change for audit trail
                    move.message_post(
                        body=_('Matrix dimensions updated: Branch=%s, BU=%s') % (
                            move.ops_branch_id.name if move.ops_branch_id else 'None',
                            move.ops_business_unit_id.name if move.ops_business_unit_id else 'None'
                        )
                    )
        
        return result
    
    # ========================================================================
    # ONCHANGE METHODS
    # ========================================================================
    
    @api.onchange('ops_branch_id')
    def _onchange_ops_branch_id(self):
        """Filter available BUs when branch changes and update analytic distribution."""
        if self.ops_branch_id:
            # Filter available BUs
            available_bus = self.env['ops.business.unit'].search([
                ('branch_ids', 'in', self.ops_branch_id.id),
                ('active', '=', True)
            ])
            
            # Reset BU if incompatible
            if self.ops_business_unit_id and self.ops_business_unit_id not in available_bus:
                self.ops_business_unit_id = False
            
            # Update analytic distribution on lines
            if self.line_ids:
                distribution = self._compute_analytic_distribution_values()
                for line in self.line_ids.filtered(lambda l: not l.analytic_distribution):
                    line.analytic_distribution = distribution
            
            return {
                'domain': {
                    'ops_business_unit_id': [('id', 'in', available_bus.ids)]
                }
            }
        return {}
    
    @api.onchange('ops_business_unit_id')
    def _onchange_ops_business_unit_id(self):
        """Update analytic distribution when BU changes."""
        if self.line_ids:
            distribution = self._compute_analytic_distribution_values()
            for line in self.line_ids.filtered(lambda l: not l.analytic_distribution):
                line.analytic_distribution = distribution
    
    # ========================================================================
    # VALIDATION CONSTRAINTS
    # ========================================================================
    
    @api.constrains('ops_branch_id', 'ops_business_unit_id')
    def _check_matrix_dimensions(self):
        """Ensure required dimensions are present for invoices."""
        for move in self:
            # Only validate for invoice types
            if move.move_type in ('out_invoice', 'in_invoice', 'out_refund', 'in_refund'):
                if not move.ops_branch_id:
                    raise ValidationError(_(
                        "Branch is required for %s '%s'. Please select a branch before confirming."
                    ) % (move.move_type, move.name))
                
                if not move.ops_business_unit_id:
                    raise ValidationError(_(
                        "Business Unit is required for %s '%s'. Please select a business unit before confirming."
                    ) % (move.move_type, move.name))
                
                # Also validate that BU operates in the selected branch
                if (move.ops_branch_id and move.ops_business_unit_id and 
                    move.ops_branch_id not in move.ops_business_unit_id.branch_ids):
                    raise ValidationError(_(
                        "Business Unit '%(bu_name)s' does not operate in Branch '%(branch_name)s'. "
                        "Please select a compatible combination."
                    ) % {
                        'bu_name': move.ops_business_unit_id.name,
                        'branch_name': move.ops_branch_id.name
                    })
    
    # ========================================================================
    # ACTION METHODS
    # ========================================================================
    
    def action_post(self):
        """Override post action to validate matrix dimensions before posting."""
        # Validate dimensions for invoices
        invoice_moves = self.filtered(lambda m: m.is_invoice(include_receipts=True))
        for move in invoice_moves:
            if not move.ops_branch_id:
                raise ValidationError(_(
                    "Cannot post invoice %s without a Branch. Please select a branch."
                ) % move.name)
            
            if not move.ops_business_unit_id:
                raise ValidationError(_(
                    "Cannot post invoice %s without a Business Unit. Please select a business unit."
                ) % move.name)
        
        # Ensure analytic distribution is set on lines
        for move in self:
            if move.ops_branch_id or move.ops_business_unit_id:
                distribution = move._compute_analytic_distribution_values()
                if distribution:
                    for line in move.line_ids.filtered(lambda l: not l.analytic_distribution):
                        line.analytic_distribution = distribution
        
        return super().action_post()
    
    def action_recompute_analytic_distribution(self):
        """Manual action to recompute analytic distribution for selected moves."""
        for move in self:
            distribution = move._compute_analytic_distribution_values()
            if distribution:
                for line in move.line_ids:
                    line.analytic_distribution = distribution
                
                move.message_post(
                    body=_('Analytic distribution recomputed for all lines.')
                )
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Analytic Distribution Updated'),
                'message': _('Analytic distribution has been recomputed for %d moves.') % len(self),
                'type': 'success',
                'sticky': False,
            }
        }
    
    # ========================================================================
    # HELPER METHODS
    # ========================================================================
    
    def _compute_analytic_distribution_values(self):
        """
        Compute analytic distribution values for this move using dynamic configuration.
        Weights are retrieved from ops.matrix.config instead of hardcoded values.
        """
        self.ensure_one()
        
        # Get configuration
        config = self.env['ops.matrix.config'].get_config(
            company_id=self.company_id.id if self.company_id else None
        )
        
        # Extract analytic account IDs
        branch_account_id = None
        bu_account_id = None
        
        if self.ops_branch_id:
            if hasattr(self.ops_branch_id, 'analytic_account_id') and self.ops_branch_id.analytic_account_id:
                branch_account_id = self.ops_branch_id.analytic_account_id.id
            elif hasattr(self.ops_branch_id, 'ops_analytic_account_id') and self.ops_branch_id.ops_analytic_account_id:
                branch_account_id = self.ops_branch_id.ops_analytic_account_id.id
        
        if self.ops_business_unit_id and self.ops_business_unit_id.analytic_account_id:
            bu_account_id = self.ops_business_unit_id.analytic_account_id.id
        
        # Use config to calculate distribution
        return config.get_analytic_distribution(
            branch_id=branch_account_id,
            bu_id=bu_account_id
        )
    
    def _propagate_matrix_dimensions(self, vals):
        """
        Propagate matrix dimensions from source order to invoice/bill.
        
        This method examines the context or related orders to extract
        ops_branch_id and ops_business_unit_id and populate them in vals.
        
        :param vals: Dictionary of values being created
        """
        # Check if dimensions already explicitly set
        if vals.get('ops_branch_id') or vals.get('ops_business_unit_id'):
            return
        
        # Try to find source order from invoice_origin or context
        invoice_origin = vals.get('invoice_origin')
        source_order = None
        
        if invoice_origin:
            # Parse invoice_origin (e.g., "SO0001234" or "PO0001234")
            source_order = self._find_source_order(invoice_origin)
        
        # If source order found, extract dimensions
        if source_order:
            if hasattr(source_order, 'ops_branch_id') and source_order.ops_branch_id:
                vals['ops_branch_id'] = source_order.ops_branch_id.id
            if hasattr(source_order, 'ops_business_unit_id') and source_order.ops_business_unit_id:
                vals['ops_business_unit_id'] = source_order.ops_business_unit_id.id
            vals['ops_source_order_id'] = f"{source_order._name},{source_order.id}"
    
    def _find_source_order(self, origin_reference):
        """
        Find the source order (SaleOrder or PurchaseOrder) by origin reference.
        
        :param origin_reference: String like "SO0001234" or "PO0001234"
        :return: RecordSet of order or None
        """
        if not origin_reference:
            return None
        
        # Try to find sale order
        sale_order = self.env['sale.order'].search([
            '|',
            ('name', '=', origin_reference),
            ('name', '=', origin_reference.replace('SO', '').lstrip('0') or origin_reference)
        ], limit=1)
        
        if sale_order:
            return sale_order
        
        # Try to find purchase order
        purchase_order = self.env['purchase.order'].search([
            '|',
            ('name', '=', origin_reference),
            ('name', '=', origin_reference.replace('PO', '').lstrip('0') or origin_reference)
        ], limit=1)
        
        return purchase_order if purchase_order else None
    
    def action_invoice_sent(self):
        """
        Override email sending to enforce governance rules.
        
        This prevents users from sending invoices by email
        if they violate governance rules or have pending approvals.
        """
        # ADMIN BYPASS: Allow administrators to send anything
        if self.env.su or self.env.user.has_group('base.group_system'):
            # Log admin override for audit trail
            try:
                for move in self:
                    if move.is_invoice(include_receipts=True):
                        self.env['ops.security.audit'].sudo().log_security_override(
                            model_name=move._name,
                            record_id=move.id,
                            reason='Admin bypass used to send Invoice/Bill without governance checks'
                        )
            except Exception as e:
                _logger.warning("Failed to log admin override: %s", str(e))
            return super().action_invoice_sent()
        
        for move in self:
            # Only enforce for invoices and bills
            if move.is_invoice(include_receipts=True):
                _logger.info("OPS Governance: Checking invoice %s for email commitment", move.name)
                
                # Check for pending approvals (if governance mixin is applied)
                if hasattr(move, 'approval_request_ids'):
                    pending_approvals = move.approval_request_ids.filtered(
                        lambda a: a.state == 'pending'
                    )
                    
                    if pending_approvals:
                        rule_names = ', '.join(pending_approvals.mapped('rule_id.name'))
                        raise UserError(_(
                            "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s' "
                            "until it satisfies company Governance Rules.\n\n"
                            "â³ Pending Approval: %s\n\n"
                            "This document is locked for external commitment (email or print) "
                            "until the required approvals are granted."
                        ) % (move.display_name, rule_names))
                
                # Enforce governance rules (if mixin is applied)
                if hasattr(move, '_enforce_governance_rules'):
                    try:
                        move._enforce_governance_rules(move, trigger_type='on_write')
                        _logger.info("OPS Governance: Invoice %s passed all governance checks for email", move.name)
                    except UserError as e:
                        # Re-raise with enhanced message for email context
                        error_message = str(e)
                        if 'requires approval' in error_message.lower():
                            raise UserError(_(
                                "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n"
                                "%s\n\n"
                                "External commitment (email/print) is blocked until approval is granted."
                            ) % (move.display_name, error_message))
                        else:
                            raise UserError(_(
                                "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n%s"
                            ) % (move.display_name, error_message))
        
        # If all checks pass, proceed with email wizard
        return super().action_invoice_sent()


class AccountMoveLine(models.Model):
    _inherit = ['account.move.line', 'ops.matrix.mixin']
    _name = 'account.move.line'
    
    # These fields are inherited from ops.matrix.mixin:
    # - ops_branch_id
    # - ops_business_unit_id
    # - ops_company_id
    # - ops_analytic_distribution
    
    # ========================================================================
    # DEFAULT METHODS
    # ========================================================================
    
    def _get_default_ops_branch(self):
        """Get default branch from parent move if available."""
        if self._context.get('default_move_id'):
            move = self.env['account.move'].browse(self._context['default_move_id'])
            if move.ops_branch_id:
                return move.ops_branch_id.id
        return super()._get_default_ops_branch()
    
    def _get_default_ops_business_unit(self):
        """Get default BU from parent move if available."""
        if self._context.get('default_move_id'):
            move = self.env['account.move'].browse(self._context['default_move_id'])
            if move.ops_business_unit_id:
                return move.ops_business_unit_id.id
        return super()._get_default_ops_business_unit()
    
    # ========================================================================
    # ONCHANGE METHODS
    # ========================================================================
    
    @api.onchange('ops_branch_id', 'ops_business_unit_id')
    def _onchange_matrix_dimensions(self):
        """Update analytic distribution when matrix dimensions change on line."""
        distribution = self._compute_analytic_distribution_values()
        if distribution:
            self.analytic_distribution = distribution
        elif self.analytic_distribution:
            # Clear if no dimensions
            self.analytic_distribution = False
    
    @api.onchange('move_id')
    def _onchange_move_id_propagate_dimensions(self):
        """
        When move_id changes or is set, inherit the move's matrix dimensions.
        
        This ensures that when a line is added to a move with specific dimensions,
        it automatically gets the correct dimensions.
        """
        if self.move_id:
            # Inherit dimensions from parent move if not already set
            if not self.ops_branch_id and self.move_id.ops_branch_id:
                self.ops_branch_id = self.move_id.ops_branch_id
            if not self.ops_business_unit_id and self.move_id.ops_business_unit_id:
                self.ops_business_unit_id = self.move_id.ops_business_unit_id
            
            # Update analytic distribution
            distribution = self._compute_analytic_distribution_values()
            if distribution:
                self.analytic_distribution = distribution
    
    # ========================================================================
    # HELPER METHODS
    # ========================================================================
    
    def _compute_analytic_distribution_values(self):
        """
        Compute analytic distribution for this line using dynamic configuration.
        Weights are retrieved from ops.matrix.config instead of hardcoded values.
        """
        self.ensure_one()
        
        # Get configuration
        company_id = self.company_id.id if self.company_id else (
            self.move_id.company_id.id if self.move_id and self.move_id.company_id else None
        )
        config = self.env['ops.matrix.config'].get_config(company_id=company_id)
        
        # Check if line has its own dimensions, otherwise use move's dimensions
        branch = self.ops_branch_id or (self.move_id.ops_branch_id if self.move_id else False)
        bu = self.ops_business_unit_id or (self.move_id.ops_business_unit_id if self.move_id else False)
        
        # Extract analytic account IDs
        branch_account_id = None
        bu_account_id = None
        
        if branch:
            if hasattr(branch, 'analytic_account_id') and branch.analytic_account_id:
                branch_account_id = branch.analytic_account_id.id
            elif hasattr(branch, 'ops_analytic_account_id') and branch.ops_analytic_account_id:
                branch_account_id = branch.ops_analytic_account_id.id
        
        if bu and bu.analytic_account_id:
            bu_account_id = bu.analytic_account_id.id
        
        # Use config to calculate distribution
        return config.get_analytic_distribution(
            branch_id=branch_account_id,
            bu_id=bu_account_id
        )

--- ops_matrix_core/models/ir_actions_report.py ---
# -*- coding: utf-8 -*-
from odoo import models, _
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)


class IrActionsReport(models.Model):
    _inherit = 'ir.actions.report'

    def _render_qweb_pdf(self, report_ref, res_ids=None, data=None):
        """
        Override PDF rendering to enforce governance rules.
        
        This prevents users from printing/downloading PDFs of documents
        that violate active governance rules or require pending approvals.
        
        Blocks print for: sale.order, purchase.order, account.move
        """
        # ADMIN BYPASS: Allow administrators to print anything
        if self.env.su or self.env.user.has_group('base.group_system'):
            return super()._render_qweb_pdf(report_ref, res_ids, data)
        
        # Determine the model being reported
        report_sudo = self._get_report(report_ref)
        target_model = report_sudo.model
        
        # Only enforce for governance-enabled models
        governed_models = ['sale.order', 'purchase.order', 'account.move']
        
        if target_model in governed_models and res_ids:
            # Get the records being printed
            records = self.env[target_model].browse(res_ids)
            
            for record in records:
                # Check if model has governance mixin
                if hasattr(record, '_enforce_governance_rules'):
                    try:
                        # Check for pending approvals
                        if hasattr(record, 'approval_request_ids'):
                            pending_approvals = record.approval_request_ids.filtered(
                                lambda a: a.state == 'pending'
                            )
                            
                            if pending_approvals:
                                rule_names = ', '.join(pending_approvals.mapped('rule_id.name'))
                                raise UserError(_(
                                    "ðŸš« COMMITMENT BLOCKED: You cannot Print or Download PDF for "
                                    "document '%s' until it satisfies company Governance Rules.\n\n"
                                    "â³ Pending Approval: %s\n\n"
                                    "This document is locked for external commitment (email or print) "
                                    "until the required approvals are granted."
                                ) % (record.display_name, rule_names))
                        
                        # Enforce governance rules (will raise UserError if blocked)
                        # Use 'on_write' trigger as it's the most comprehensive
                        record._enforce_governance_rules(record, trigger_type='on_write')
                        
                        _logger.info(
                            "OPS Governance: PDF generation allowed for %s %s after rules check",
                            target_model, record.id
                        )
                        
                    except UserError as e:
                        # Re-raise with enhanced message for print context
                        error_message = str(e)
                        if 'requires approval' in error_message.lower():
                            # This is an approval requirement - enhance the message
                            raise UserError(_(
                                "ðŸš« COMMITMENT BLOCKED: You cannot Print or Email document '%s'.\n\n"
                                "%s\n\n"
                                "External commitment (print/email) is blocked until approval is granted."
                            ) % (record.display_name, error_message))
                        else:
                            # Re-raise the original error with print context
                            raise UserError(_(
                                "ðŸš« COMMITMENT BLOCKED: You cannot Print document '%s'.\n\n%s"
                            ) % (record.display_name, error_message))
        
        # If all checks pass, proceed with PDF generation
        return super()._render_qweb_pdf(report_ref, res_ids, data)

--- ops_matrix_core/models/mail_message.py ---
from odoo import models, fields, api, _
from odoo.exceptions import AccessError

class MailMessage(models.Model):
    _inherit = 'mail.message'

    ops_is_audit_log = fields.Boolean(string='Is Audit Log', default=False)

    def unlink(self):
        if any(m.ops_is_audit_log for m in self):
            raise AccessError(_("Immutable Audit Log: Deletion Prohibited."))
        return super(MailMessage, self).unlink()

--- ops_matrix_core/models/ops_analytic_mixin.py ---
from odoo import models, api, fields

class OpsAnalyticMixin(models.AbstractModel):
    _name = 'ops.analytic.mixin'
    _description = 'Operations Analytic Account Mixin'

    analytic_account_id = fields.Many2one('account.analytic.account', 
        string='Analytic Account', 
        ondelete='restrict',
        help='Analytic account associated with this record')

    @api.model
    def _get_analytic_name_prefix(self):
        """Override in child models to set specific prefix."""
        return ""

    def write(self, vals):
        """Override to sync analytic account state and name."""
        res = super().write(vals)
        
        for record in self:
            if not record.analytic_account_id:
                continue

            analytic_vals = {}
            
            # Sync active state
            if 'active' in vals:
                analytic_vals['active'] = vals['active']
            
            # Sync name with prefix
            if 'name' in vals:
                prefix = record._get_analytic_name_prefix()
                analytic_vals['name'] = f"{prefix}{vals['name']}"
            
            if analytic_vals:
                record.analytic_account_id.write(analytic_vals)
        
        return res

    def _create_analytic_account(self, name, code, company_id=None, group_id=None):
        """Create analytic account with proper grouping.
        
        Args:
            name: Record name to use for analytic account
            code: Record code to use for analytic account
            company_id: Optional company ID
            group_id: Analytic group ID for proper hierarchy
        
        Returns:
            Created analytic account record
        """
        self.ensure_one()
        
        # Get default plan
        default_plan = self.env['account.analytic.plan'].search(
            [('parent_id', '=', False)], limit=1)
        
        if not default_plan:
            default_plan = self.env['account.analytic.plan'].create({
                'name': 'OPS Structure',
                'parent_id': False,
            })

        prefix = self._get_analytic_name_prefix()
        
        vals = {
            'name': f"{prefix}{name}",
            'code': code,
            'plan_id': default_plan.id,
            'company_id': company_id or self.env.company.id,
        }
        
        if group_id:
            vals['group_id'] = group_id

        return self.env['account.analytic.account'].create(vals)

--- ops_matrix_core/models/ops_analytic_setup.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import logging

_logger = logging.getLogger(__name__)

class OpsAnalyticSetup(models.TransientModel):
    _name = 'ops.analytic.setup'
    _description = 'OPS Analytic Accounting Setup Helper'
    
    def setup_analytic_structure(self):
        """Main method to ensure analytic plans and accounts are properly configured."""
        try:
            # Validate prerequisites
            self._validate_prerequisites()
            
            # Execute setup in controlled sequence with transaction safety
            with self.env.cr.savepoint():
                plans = self._ensure_analytic_plans()
                branch_count = self._sync_branch_analytic_accounts()
                bu_count = self._sync_bu_analytic_accounts()
                self._ensure_accounting_groups()
            
            # Prepare success message with details
            message_parts = [_('Analytic structure setup completed successfully.')]
            if branch_count > 0:
                message_parts.append(_('%s branch analytic accounts created.') % branch_count)
            if bu_count > 0:
                message_parts.append(_('%s business unit analytic accounts created.') % bu_count)
            
            _logger.info(f"Analytic setup completed: {branch_count} branches, {bu_count} BUs")
            
            # Return success message
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _('Setup Complete'),
                    'message': '\n'.join(message_parts),
                    'type': 'success',
                    'sticky': False,
                }
            }
            
        except ValidationError as e:
            _logger.error(f"Validation error during analytic setup: {e}")
            raise UserError(_('Setup failed: %s') % str(e))
            
        except Exception as e:
            _logger.exception("Unexpected error during analytic setup")
            raise UserError(
                _('An unexpected error occurred during setup. Please check the logs or contact your administrator.\n\nError: %s') % str(e)
            )
    
    def _validate_prerequisites(self):
        """Validate system state before running setup."""
        # Check if user has sufficient permissions
        if not self.env.user.has_group('base.group_system'):
            if not self.env.user.has_group('ops_matrix_core.group_ops_matrix_administrator'):
                raise ValidationError(
                    _('You do not have sufficient permissions to run this setup. '
                      'Please contact a System Administrator or Matrix Administrator.')
                )
        
        # Check if accounting module is installed
        if 'account.analytic.plan' not in self.env:
            raise ValidationError(
                _('The Accounting module is not installed or not properly configured. '
                  'Please install the accounting module before running this setup.')
            )
        
        # Verify at least one company exists
        if not self.env['res.company'].search_count([]):
            raise ValidationError(_('No company found in the system. Please create at least one company.'))
        
        # Verify branches exist
        branch_count = self.env['ops.branch'].search_count([('active', '=', True)])
        if branch_count == 0:
            raise ValidationError(
                _('No active branches found. Please create at least one branch before running analytic setup.')
            )
        
        # Verify business units exist
        bu_count = self.env['ops.business.unit'].search_count([('active', '=', True)])
        if bu_count == 0:
            raise ValidationError(
                _('No active business units found. Please create at least one business unit before running analytic setup.')
            )
        
        _logger.info(f"Prerequisites validated: {branch_count} branches, {bu_count} business units")
        return True
    
    def _ensure_analytic_plans(self):
        """Create Matrix Branch and Matrix BU analytic plans if they don't exist."""
        try:
            AnalyticPlan = self.env['account.analytic.plan']
            
            # Branch Plan for tracking operational branches
            branch_plan = AnalyticPlan.search([('name', '=', 'Matrix Branch')], limit=1)
            if not branch_plan:
                branch_plan = AnalyticPlan.create({
                    'name': 'Matrix Branch',
                    'description': 'Operational Branch tracking for Matrix reporting',
                })
                _logger.info(f"Created analytic plan: Matrix Branch (ID: {branch_plan.id})")
            else:
                _logger.info(f"Using existing analytic plan: Matrix Branch (ID: {branch_plan.id})")
            
            # Business Unit Plan for tracking profit centers
            bu_plan = AnalyticPlan.search([('name', '=', 'Matrix Business Unit')], limit=1)
            if not bu_plan:
                bu_plan = AnalyticPlan.create({
                    'name': 'Matrix Business Unit',
                    'description': 'Business Unit profit center tracking',
                })
                _logger.info(f"Created analytic plan: Matrix Business Unit (ID: {bu_plan.id})")
            else:
                _logger.info(f"Using existing analytic plan: Matrix Business Unit (ID: {bu_plan.id})")
            
            # Validate plans were created/found successfully
            if not branch_plan or not bu_plan:
                raise ValidationError(
                    _('Failed to create or retrieve analytic plans. Please check system configuration.')
                )
            
            return {
                'branch_plan': branch_plan,
                'bu_plan': bu_plan,
            }
            
        except Exception as e:
            _logger.error(f"Error creating analytic plans: {e}")
            raise ValidationError(
                _('Failed to create analytic plans: %s') % str(e)
            )
    
    def _sync_branch_analytic_accounts(self):
        """Ensure all active branches have analytic accounts created."""
        try:
            Branch = self.env['ops.branch']
            AnalyticAccount = self.env['account.analytic.account']
            
            # Find branches without analytic accounts
            branches_without_analytic = Branch.search([
                ('active', '=', True),
                ('analytic_account_id', '=', False),
            ])
            
            if not branches_without_analytic:
                _logger.info("All active branches already have analytic accounts")
                return 0
            
            created_count = 0
            failed_branches = []
            
            for branch in branches_without_analytic:
                try:
                    # Validate branch data
                    if not branch.code:
                        raise ValidationError(_('Branch %s has no code defined.') % branch.name)
                    if not branch.company_id:
                        raise ValidationError(_('Branch %s has no company assigned.') % branch.name)
                    
                    # Get or create Branch analytic plan
                    branch_plan = self.env['account.analytic.plan'].search([
                        ('name', '=', 'Matrix Branch')
                    ], limit=1)
                    
                    if not branch_plan:
                        # Create plan if it doesn't exist (should not happen after _ensure_analytic_plans)
                        branch_plan = self._ensure_analytic_plans()['branch_plan']
                    
                    # Check for duplicate analytic account codes
                    existing_account = AnalyticAccount.search([
                        ('code', '=', branch.code),
                        ('plan_id', '=', branch_plan.id),
                    ], limit=1)
                    
                    if existing_account:
                        _logger.warning(
                            f"Analytic account with code {branch.code} already exists, linking to branch {branch.name}"
                        )
                        branch.analytic_account_id = existing_account.id
                        continue
                    
                    # Create analytic account for branch
                    analytic_account = AnalyticAccount.create({
                        'name': f"{branch.code} - {branch.name}",
                        'code': branch.code,
                        'plan_id': branch_plan.id,
                        'company_id': branch.company_id.id,
                        'active': True,
                    })
                    
                    # Link back to branch
                    branch.analytic_account_id = analytic_account.id
                    created_count += 1
                    _logger.info(f"Created analytic account for branch: {branch.name} (ID: {analytic_account.id})")
                    
                except Exception as e:
                    _logger.error(f"Failed to create analytic account for branch {branch.name}: {e}")
                    failed_branches.append(branch.name)
                    continue
            
            if failed_branches:
                raise ValidationError(
                    _('Failed to create analytic accounts for the following branches: %s') % ', '.join(failed_branches)
                )
            
            if created_count:
                _logger.info(f"Successfully created analytic accounts for {created_count} branches")
            
            return created_count
            
        except Exception as e:
            _logger.error(f"Error syncing branch analytic accounts: {e}")
            raise
    
    def _sync_bu_analytic_accounts(self):
        """Ensure all active business units have analytic accounts created."""
        try:
            BU = self.env['ops.business.unit']
            AnalyticAccount = self.env['account.analytic.account']
            
            # Find BUs without analytic accounts
            bus_without_analytic = BU.search([
                ('active', '=', True),
                ('analytic_account_id', '=', False),
            ])
            
            if not bus_without_analytic:
                _logger.info("All active business units already have analytic accounts")
                return 0
            
            created_count = 0
            failed_bus = []
            
            for bu in bus_without_analytic:
                try:
                    # Validate BU data
                    if not bu.code:
                        raise ValidationError(_('Business Unit %s has no code defined.') % bu.name)
                    
                    # Get primary branch for company reference
                    primary_branch = bu.primary_branch_id
                    company_id = None
                    
                    if primary_branch and primary_branch.company_id:
                        company_id = primary_branch.company_id.id
                    elif bu.branch_ids and bu.branch_ids[0].company_id:
                        company_id = bu.branch_ids[0].company_id.id
                    else:
                        company_id = self.env.company.id
                    
                    if not company_id:
                        raise ValidationError(
                            _('Business Unit %s has no associated company. '
                              'Please ensure it is linked to at least one branch with a company.') % bu.name
                        )
                    
                    # Get or create BU analytic plan
                    bu_plan = self.env['account.analytic.plan'].search([
                        ('name', '=', 'Matrix Business Unit')
                    ], limit=1)
                    
                    if not bu_plan:
                        # Create plan if it doesn't exist
                        bu_plan = self._ensure_analytic_plans()['bu_plan']
                    
                    # Check for duplicate analytic account codes
                    existing_account = AnalyticAccount.search([
                        ('code', '=', bu.code),
                        ('plan_id', '=', bu_plan.id),
                    ], limit=1)
                    
                    if existing_account:
                        _logger.warning(
                            f"Analytic account with code {bu.code} already exists, linking to BU {bu.name}"
                        )
                        bu.analytic_account_id = existing_account.id
                        continue
                    
                    # Create analytic account for BU
                    analytic_account = AnalyticAccount.create({
                        'name': f"{bu.code} - {bu.name}",
                        'code': bu.code,
                        'plan_id': bu_plan.id,
                        'company_id': company_id,
                        'active': True,
                    })
                    
                    # Link back to BU
                    bu.analytic_account_id = analytic_account.id
                    created_count += 1
                    _logger.info(f"Created analytic account for BU: {bu.name} (ID: {analytic_account.id})")
                    
                except Exception as e:
                    _logger.error(f"Failed to create analytic account for BU {bu.name}: {e}")
                    failed_bus.append(bu.name)
                    continue
            
            if failed_bus:
                raise ValidationError(
                    _('Failed to create analytic accounts for the following business units: %s') % ', '.join(failed_bus)
                )
            
            if created_count:
                _logger.info(f"Successfully created analytic accounts for {created_count} business units")
            
            return created_count
            
        except Exception as e:
            _logger.error(f"Error syncing BU analytic accounts: {e}")
            raise
    
    def _ensure_accounting_groups(self):
        """Create analytic account groups for Branch and BU if they don't exist."""
        try:
            AnalyticGroup = self.env['account.analytic.group']
            
            # Branch group
            branch_group = AnalyticGroup.search([('name', '=', 'Branches')], limit=1)
            if not branch_group:
                branch_group = AnalyticGroup.create({
                    'name': 'Branches',
                    'description': 'Operational Branches Group',
                })
            
            # Business Unit group
            bu_group = AnalyticGroup.search([('name', '=', 'Business Units')], limit=1)
            if not bu_group:
                bu_group = AnalyticGroup.create({
                    'name': 'Business Units',
                    'description': 'Business Units Profit Centers Group',
                })
            
            return {
                'branch_group': branch_group,
                'bu_group': bu_group,
            }
        except Exception as e:
            # Analytic groups may not exist in all Odoo versions
            _logger.warning(f"Could not create analytic groups: {e}")
            return {}


class AccountAnalyticAccount(models.Model):
    _inherit = 'account.analytic.account'
    
    # Add fields to track linkage (optional but helpful)
    ops_branch_id = fields.Many2one('ops.branch', string='Linked Branch', readonly=True, copy=False)
    ops_business_unit_id = fields.Many2one('ops.business.unit', string='Linked Business Unit', readonly=True, copy=False)
    
    def unlink(self):
        """Prevent deletion if linked to active branch or BU."""
        Branch = self.env['ops.branch']
        BU = self.env['ops.business.unit']
        
        for account in self:
            # Check if linked to an active branch
            branch = Branch.search([
                ('analytic_account_id', '=', account.id),
                ('active', '=', True)
            ], limit=1)
            
            if branch:
                raise UserError(
                    _("Cannot delete analytic account '%(account_name)s' because it is linked to "
                      "active branch '%(branch_name)s'. Deactivate the branch first.") % {
                          'account_name': account.name,
                          'branch_name': branch.name
                      }
                )
            
            # Check if linked to an active BU
            bu = BU.search([
                ('analytic_account_id', '=', account.id),
                ('active', '=', True)
            ], limit=1)
            
            if bu:
                raise UserError(
                    _("Cannot delete analytic account '%(account_name)s' because it is linked to "
                      "active business unit '%(bu_name)s'. Deactivate the BU first.") % {
                          'account_name': account.name,
                          'bu_name': bu.name
                      }
                )
        
        return super().unlink()

--- ops_matrix_core/models/ops_api_key.py ---
# -*- coding: utf-8 -*-

"""
OPS Matrix API Key Management
Provides secure API key generation and management for external integrations
"""

from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
import secrets
import logging

_logger = logging.getLogger(__name__)


class OpsApiKey(models.Model):
    """
    API Key Model for OPS Matrix Framework
    
    Manages API keys for external system integrations with persona-based access control.
    Keys are automatically generated using cryptographically secure tokens.
    """
    _name = 'ops.api.key'
    _description = 'OPS Matrix API Key'
    _inherit = ['mail.thread']
    _order = 'create_date desc'
    _rec_name = 'name'
    
    # ========================================================================
    # FIELDS
    # ========================================================================
    
    name = fields.Char(
        string='API Key Name',
        required=True,
        help='Descriptive name for this API key (e.g., "Production Integration", "Mobile App")'
    )
    
    key = fields.Char(
        string='API Key Token',
        required=True,
        readonly=True,
        copy=False,
        index=True,
        help='The actual API key token - auto-generated and readonly for security'
    )
    
    persona_id = fields.Many2one(
        'ops.persona',
        string='Persona',
        required=True,
        ondelete='cascade',
        help='The persona this API key is linked to - determines access rights and data visibility'
    )
    
    active = fields.Boolean(
        string='Active',
        default=True,
        help='Inactive keys cannot be used for authentication'
    )
    
    created_date = fields.Datetime(
        string='Created Date',
        default=fields.Datetime.now,
        readonly=True,
        help='When this API key was created'
    )
    
    last_used = fields.Datetime(
        string='Last Used',
        readonly=True,
        help='Last time this API key was used for authentication'
    )
    
    usage_count = fields.Integer(
        string='Usage Count',
        default=0,
        readonly=True,
        help='Total number of times this API key has been used'
    )
    
    # Additional metadata
    description = fields.Text(
        string='Description',
        help='Additional notes about this API key and its purpose'
    )
    
    user_id = fields.Many2one(
        'res.users',
        string='Created By',
        default=lambda self: self.env.user,
        readonly=True,
        help='User who created this API key'
    )
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        default=lambda self: self.env.company,
        required=True
    )
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    
    _sql_constraints = [
        ('unique_key', 'UNIQUE(key)', 'API Key must be unique!'),
        ('check_usage_count', 'CHECK(usage_count >= 0)', 'Usage count cannot be negative!')
    ]
    
    # ========================================================================
    # ORM METHODS
    # ========================================================================
    
    @api.model_create_multi
    def create(self, vals_list):
        """
        Override create to auto-generate secure API key token
        """
        for vals in vals_list:
            if 'key' not in vals or not vals.get('key'):
                # Generate cryptographically secure API key
                vals['key'] = self._generate_api_key()
        
        records = super(OpsApiKey, self).create(vals_list)
        
        for record in records:
            _logger.info(f"API Key created: {record.name} (ID: {record.id}) for persona {record.persona_id.name}")
        
        return records
    
    def write(self, vals):
        """
        Override write to prevent modification of key field
        """
        if 'key' in vals and any(rec.id for rec in self):
            raise ValidationError(_('API Key token cannot be modified after creation for security reasons.'))
        
        return super(OpsApiKey, self).write(vals)
    
    def unlink(self):
        """
        Override unlink to log deletion
        """
        for record in self:
            _logger.warning(f"API Key deleted: {record.name} (ID: {record.id})")
        
        return super(OpsApiKey, self).unlink()
    
    # ========================================================================
    # BUSINESS METHODS
    # ========================================================================
    
    def _generate_api_key(self):
        """
        Generate a cryptographically secure API key token
        
        Uses secrets.token_urlsafe(32) which generates a URL-safe text string
        containing 32 random bytes in Base64 encoding (approximately 43 characters)
        
        Returns:
            str: Secure API key token
        """
        return secrets.token_urlsafe(32)
    
    def regenerate_key(self):
        """
        Regenerate the API key token (useful if compromised)
        
        This is the only way to change the key after creation.
        """
        self.ensure_one()
        
        if not self.env.user.has_group('base.group_system'):
            raise ValidationError(_('Only system administrators can regenerate API keys.'))
        
        old_key_preview = self.key[:8] + '...' if self.key else 'N/A'
        new_key = self._generate_api_key()
        
        # Use SQL to bypass write() restriction
        self.env.cr.execute(
            "UPDATE ops_api_key SET key = %s WHERE id = %s",
            (new_key, self.id)
        )
        
        # Invalidate cache
        self.invalidate_recordset(['key'])
        
        _logger.warning(
            f"API Key regenerated: {self.name} (ID: {self.id}) "
            f"Old: {old_key_preview}, New: {new_key[:8]}... "
            f"By: {self.env.user.name}"
        )
        
        # Post message to chatter
        self.message_post(
            body=_('API Key regenerated by %s') % self.env.user.name,
            subject=_('API Key Regenerated')
        )
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('API Key Regenerated'),
                'message': _('The API key has been regenerated. Please update your integration with the new key.'),
                'type': 'warning',
                'sticky': True
            }
        }
    
    def increment_usage(self):
        """
        Increment usage counter and update last used timestamp
        
        Called by API authentication decorator on each successful request
        """
        self.ensure_one()
        
        # Use SQL for performance (avoid ORM overhead on each API call)
        self.env.cr.execute("""
            UPDATE ops_api_key 
            SET usage_count = usage_count + 1, 
                last_used = NOW() AT TIME ZONE 'UTC'
            WHERE id = %s
        """, (self.id,))
        
        # No need to invalidate cache for readonly fields
    
    @api.model
    def validate_key(self, api_key_token):
        """
        Validate an API key token and return the associated key record
        
        Args:
            api_key_token (str): The API key token to validate
            
        Returns:
            ops.api.key: The API key record if valid and active, False otherwise
        """
        if not api_key_token:
            return False
        
        key_record = self.sudo().search([
            ('key', '=', api_key_token),
            ('active', '=', True)
        ], limit=1)
        
        return key_record if key_record else False
    
    def action_deactivate(self):
        """
        Deactivate API key (from UI button)
        """
        self.ensure_one()
        self.active = False
        
        _logger.info(f"API Key deactivated: {self.name} (ID: {self.id}) by {self.env.user.name}")
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('API Key Deactivated'),
                'message': _('This API key is now inactive and cannot be used for authentication.'),
                'type': 'success'
            }
        }
    
    def action_activate(self):
        """
        Activate API key (from UI button)
        """
        self.ensure_one()
        self.active = True
        
        _logger.info(f"API Key activated: {self.name} (ID: {self.id}) by {self.env.user.name}")
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('API Key Activated'),
                'message': _('This API key is now active and can be used for authentication.'),
                'type': 'success'
            }
        }
    
    # ========================================================================
    # VIEWS
    # ========================================================================
    
    def action_view_audit_logs(self):
        """
        Open audit logs for this API key
        """
        self.ensure_one()
        
        return {
            'name': _('Audit Logs - %s') % self.name,
            'type': 'ir.actions.act_window',
            'res_model': 'ops.audit.log',
            'view_mode': 'tree,form',
            'domain': [('api_key_id', '=', self.id)],
            'context': {'default_api_key_id': self.id}
        }

--- ops_matrix_core/models/ops_approval_dashboard.py ---
from odoo import models, fields, api, tools

class OpsApprovalDashboard(models.Model):
    _name = 'ops.approval.dashboard'
    _description = 'Unified Approval Dashboard'
    _auto = False
    _order = 'date_request desc'

    res_model = fields.Char(string='Resource Model', readonly=True)
    res_id = fields.Integer(string='Resource ID', readonly=True)
    name = fields.Char(string='Source Document', readonly=True)
    requester_id = fields.Many2one('res.users', string='Requester', readonly=True)
    date_request = fields.Datetime(string='Request Date', readonly=True)
    sla_status = fields.Selection([
        ('running', 'Running'),
        ('warning', 'Warning'),
        ('critical', 'Critical'),
        ('violated', 'Violated'),
        ('completed', 'Completed')
    ], string='SLA Status', readonly=True)
    time_to_breach = fields.Float(string='Time to Breach (Hours)', readonly=True)
    required_persona_id = fields.Many2one('ops.persona', string='Required Persona', readonly=True)

    def init(self):
        tools.drop_view_if_exists(self.env.cr, self._table)
        
        # Check if all required tables exist
        required_tables = ['ops_approval_request', 'ops_governance_rule', 'ops_persona', 'ops_sla_instance']
        for table in required_tables:
            self.env.cr.execute("""
                SELECT EXISTS (
                    SELECT FROM information_schema.tables
                    WHERE table_name = %s
                )
            """, (table,))
            if not self.env.cr.fetchone()[0]:
                return

        self.env.cr.execute(f"""
            CREATE OR REPLACE VIEW {self._table} AS (
                SELECT
                    req.id AS id,
                    req.model_name AS res_model,
                    req.res_id AS res_id,
                    req.name AS name,
                    req.requested_by AS requester_id,
                    req.create_date AS date_request,
                    sla.status AS sla_status,
                    EXTRACT(EPOCH FROM (sla.deadline - NOW())) / 3600 AS time_to_breach,
                    p.id AS required_persona_id
                FROM
                    ops_approval_request req
                LEFT JOIN
                    ops_governance_rule r ON req.rule_id = r.id
                LEFT JOIN
                    rule_approval_persona_rel rel ON r.id = rel.rule_id
                LEFT JOIN
                    ops_persona p ON rel.persona_id = p.id
                LEFT JOIN
                    ops_sla_instance sla ON sla.res_model = req.model_name AND sla.res_id = req.res_id
                WHERE
                    req.state = 'pending'
            )
        """)

    def action_view_source(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'res_model': self.res_model,
            'res_id': self.res_id,
            'view_mode': 'form',
            'target': 'current',
        }

--- ops_matrix_core/models/ops_approval_request.py ---
from odoo import models, fields, api, Command, _
from typing import List, Dict, Any
import logging

_logger = logging.getLogger(__name__)


class OpsApprovalRequest(models.Model):
    _name = 'ops.approval.request'
    _description = 'Approval Request with Matrix Dimensions'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'create_date desc'

    name = fields.Char(
        string='Reference',
        required=True,
        readonly=True,
        default='New',
        tracking=True,
        help='Unique reference number for this approval request. '
             'Auto-generated on save (format: APP/XXXX). '
             'Used for: Tracking approvals, audit trails, communication with approvers. '
             'Example: APP/0001, APP/0025. '
             'Cannot be changed after creation.'
    )
    rule_id = fields.Many2one(
        'ops.governance.rule',
        string='Rule',
        required=True,
        tracking=True,
        help='The governance rule that triggered this approval request. '
             'The rule defines: validation criteria, approvers, severity, actions. '
             'Click to view rule configuration and understand why approval is needed. '
             'Examples: "Discount Limit Rule", "Margin Protection - Electronics", "High Value Approval". '
             'Related: View rule details to see thresholds and authorized approvers.'
    )
    model_name = fields.Char(string='Model Name', required=True)
    res_id = fields.Integer(string='Record ID', required=True)
    record_ref = fields.Char(string='Record Reference', compute='_compute_record_ref', store=True)
    res_name = fields.Char(string='Record Name', compute='_compute_res_name', store=True)
    notes = fields.Text(
        string='Notes',
        help='Explanation of why this approval is needed and context for approvers. '
             'Include: Reason for exception, business justification, customer context, urgency. '
             'Examples: '
             '- "Customer is major account, discount requested to secure $500K annual contract" '
             '- "Market pricing requires 20% discount to match competitors" '
             '- "Low margin justified by high volume order (1000 units)". '
             'Best Practice: Provide enough detail for approvers to make informed decisions. '
             'Visible to: All approvers and requestor.'
    )
    response_notes = fields.Text(
        string='Response Notes',
        help='Approver\'s explanation of their decision (approval or rejection). '
             'Required when rejecting, optional when approving. '
             'Include: Reason for decision, conditions if any, guidance for future. '
             'Examples: '
             '- "Approved - customer is strategic account" '
             '- "Rejected - margin too low, no business justification provided" '
             '- "Approved conditionally - monitor for repeat requests". '
             'Visible to: Requestor and all users with approval access.'
    )
    
    # Tracking fields
    requested_by = fields.Many2one('res.users', string='Requested By', default=lambda self: self.env.user, required=True, tracking=True)
    requested_date = fields.Datetime(string='Requested Date', default=fields.Datetime.now, required=True)
    approved_by = fields.Many2one('res.users', string='Approved By', readonly=True, tracking=True)
    approved_date = fields.Datetime(string='Approved Date', readonly=True)

    @api.depends('model_name', 'res_id')
    def _compute_record_ref(self):
        """Compute record reference string."""
        for request in self:
            if request.model_name and request.res_id:
                request.record_ref = f"{request.model_name},{request.res_id}"
            else:
                request.record_ref = False

    @api.depends('model_name', 'res_id')
    def _compute_res_name(self):
        """Compute display name of the related record."""
        for request in self:
            if request.model_name and request.res_id:
                try:
                    record = request.env[request.model_name].browse(request.res_id)
                    if record.exists():
                        request.res_name = record.display_name
                    else:
                        request.res_name = f"{request.model_name}#{request.res_id} (Deleted)"
                except Exception:
                    request.res_name = f"{request.model_name}#{request.res_id}"
            else:
                request.res_name = False
    
    # Matrix Dimensions (inherited from source record)
    branch_id = fields.Many2one('ops.branch', string='Branch', tracking=True)
    business_unit_id = fields.Many2one('ops.business.unit', string='Business Unit', tracking=True)
    
    # --- MATRIX DIMENSION FIELDS (ENHANCED) ---
    ops_company_id = fields.Many2one('res.company', string='Company',
                                     compute='_compute_matrix_dimensions', store=True)
    
    ops_branch_id = fields.Many2one('ops.branch', string='OPS Branch',
                                    compute='_compute_matrix_dimensions', store=True)
    
    ops_business_unit_id = fields.Many2one('ops.business.unit', string='OPS Business Unit',
                                           compute='_compute_matrix_dimensions', store=True)
    
    # --- GOVERNANCE VIOLATION DETAILS ---
    violation_type = fields.Selection([
        ('matrix', 'Matrix Validation'),
        ('discount', 'Discount Limit'),
        ('margin', 'Margin Protection'),
        ('price', 'Price Override'),
        ('other', 'Other'),
    ], string='Violation Type',
       tracking=True,
       help='Category of governance rule violation that triggered this approval. '
            'Matrix Validation: Missing or invalid branch/BU selection. '
            'Discount Limit: Discount exceeds authorized limit. '
            'Margin Protection: Profit margin below minimum threshold. '
            'Price Override: Price change exceeds authorized variance. '
            'Other: Custom rule violations. '
            'This determines which approvers are notified and what data is displayed.')
    
    violation_details = fields.Text(
        string='Violation Details',
        help='Detailed explanation of what governance rule was violated and how. '
             'Auto-generated by the system based on the violation type. '
             'Examples: '
             '- "Discount 15% exceeds your limit of 10%" '
             '- "Margin 8% below minimum 12% for Electronics category" '
             '- "Branch selection required but not provided". '
             'Provides context for approvers to understand the issue. '
             'Read-only, populated automatically by governance engine.'
    )
    
    # --- QUANTITATIVE VIOLATION DATA ---
    discount_percent = fields.Float(string='Discount %', digits=(5, 2))
    margin_percent = fields.Float(string='Margin %', digits=(5, 2))
    price_variance_percent = fields.Float(string='Price Variance %', digits=(5, 2))
    
    allowed_limit = fields.Float(string='Allowed Limit', digits=(5, 2),
                                help='What was the allowed limit')
    
    actual_value = fields.Float(string='Actual Value', digits=(5, 2),
                               help='What was the actual value')
    
    # --- APPROVAL CONTEXT ---
    is_governance_violation = fields.Boolean(string='Governance Violation',
                                            compute='_compute_is_governance_violation', store=True)
    
    violation_severity = fields.Selection([
        ('low', 'Low - Informational'),
        ('medium', 'Medium - Requires Attention'),
        ('high', 'High - Requires Approval'),
        ('critical', 'Critical - Blocking'),
    ], string='Violation Severity',
       default='medium',
       tracking=True,
       help='Severity level of this governance violation. '
            'Low: Informational only, no action blocked. '
            'Medium: Requires review but transaction can proceed. '
            'High: Requires approval before transaction can complete. '
            'Critical: Transaction completely blocked until approved. '
            'Severity affects: Notification urgency, approver priority, system behavior. '
            'Default: Medium (requires attention but not blocking).')
    
    # --- COMPUTED FIELDS ---
    matrix_summary = fields.Char(string='Matrix Summary',
                                compute='_compute_matrix_summary', store=True)
    
    violation_summary = fields.Char(string='Violation Summary',
                                   compute='_compute_violation_summary', store=True)
    
    # --- COMPUTED METHODS ---
    
    @api.depends('record_ref')
    def _compute_matrix_dimensions(self):
        """Extract matrix dimensions from referenced record."""
        for approval in self:
            if approval.record_ref:
                try:
                    model_name, record_id = approval.record_ref.split(',')
                    record = self.env[model_name].browse(int(record_id))
                    
                    if record.exists():
                        if hasattr(record, 'company_id'):
                            approval.ops_company_id = record.company_id
                        
                        if hasattr(record, 'ops_branch_id'):
                            approval.ops_branch_id = record.ops_branch_id
                        elif hasattr(record, 'branch_id'):
                            approval.ops_branch_id = record.branch_id
                        
                        if hasattr(record, 'ops_business_unit_id'):
                            approval.ops_business_unit_id = record.ops_business_unit_id
                        elif hasattr(record, 'business_unit_id'):
                            approval.ops_business_unit_id = record.business_unit_id
                except Exception as e:
                    _logger.debug(f"Error computing matrix dimensions: {e}")
                    approval.ops_company_id = False
                    approval.ops_branch_id = False
                    approval.ops_business_unit_id = False
            else:
                approval.ops_company_id = False
                approval.ops_branch_id = False
                approval.ops_business_unit_id = False
    
    @api.depends('rule_id', 'violation_type')
    def _compute_is_governance_violation(self):
        for approval in self:
            approval.is_governance_violation = bool(approval.rule_id or approval.violation_type)
    
    @api.depends('ops_branch_id', 'ops_business_unit_id')
    def _compute_matrix_summary(self):
        for approval in self:
            parts = []
            if approval.ops_branch_id:
                parts.append(f"Branch: {approval.ops_branch_id.code or approval.ops_branch_id.name}")
            if approval.ops_business_unit_id:
                parts.append(f"BU: {approval.ops_business_unit_id.code or approval.ops_business_unit_id.name}")
            approval.matrix_summary = " | ".join(parts) if parts else "No matrix"
    
    @api.depends('violation_type', 'discount_percent', 'margin_percent', 'price_variance_percent', 'allowed_limit', 'actual_value')
    def _compute_violation_summary(self):
        for approval in self:
            if approval.violation_type == 'discount' and approval.discount_percent:
                approval.violation_summary = f"Discount: {approval.discount_percent:.2f}% (Limit: {approval.allowed_limit:.2f}%)"
            elif approval.violation_type == 'margin' and approval.margin_percent:
                approval.violation_summary = f"Margin: {approval.margin_percent:.2f}% (Min: {approval.allowed_limit:.2f}%)"
            elif approval.violation_type == 'price' and approval.price_variance_percent:
                approval.violation_summary = f"Price Variance: {approval.price_variance_percent:.2f}% (Max: {approval.allowed_limit:.2f}%)"
            elif approval.violation_type == 'matrix':
                approval.violation_summary = f"Matrix Validation: {approval.violation_details or 'Missing dimension'}"
            else:
                approval.violation_summary = approval.violation_details or "No violation details"
    
    state = fields.Selection([
        ('pending', 'Pending'),
        ('approved', 'Approved'),
        ('rejected', 'Rejected'),
        ('cancelled', 'Cancelled')
    ], string='Status',
       default='pending',
       tracking=True,
       help='Current status of this approval request. '
            'Pending: Waiting for approver action. '
            'Approved: Request granted, transaction can proceed. '
            'Rejected: Request denied, transaction blocked or cancelled. '
            'Cancelled: Request withdrawn by requestor or system. '
            'State Changes: Pending â†’ Approved/Rejected/Cancelled. '
            'Email notifications sent to requestor on status change.')

    approver_ids = fields.Many2many(
        'res.users',
        'ops_approval_request_user_rel',
        'request_id',
        'user_id',
        string='Approvers',
        tracking=True,
        help='Users authorized to approve or reject this request. '
             'Automatically determined based on: Governance rule configuration, matrix dimensions (branch/BU), violation type. '
             'Selection logic: '
             '- System finds personas with approval authority for the branch/BU '
             '- Filters by violation type (discount/margin/price approvers) '
             '- Falls back to rule-defined approvers if no matches. '
             'Any listed approver can approve/reject. '
             'Notification: All approvers are notified when request is created.'
    )
    
    # Workflow fields
    workflow_id = fields.Many2one('ops.approval.workflow', string='Workflow', related='rule_id.approval_workflow_id', store=True)
    priority = fields.Selection([
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('urgent', 'Urgent'),
    ], string='Priority',
       default='medium',
       tracking=True,
       help='Urgency level for this approval request. '
            'Low: Review within 5 business days. '
            'Medium: Review within 2 business days (default). '
            'High: Review within 1 business day. '
            'Urgent: Review immediately (same day). '
            'Affects: Notification frequency, dashboard placement, SLA tracking. '
            'Set urgency based on: Customer waiting, order deadline, business impact. '
            'Urgent requests appear at top of approver dashboard.')
    
    # --- BUSINESS METHODS ---
    
    def action_view_source_record(self):
        """Open the source record that triggered this approval."""
        self.ensure_one()
        if not self.record_ref:
            return None
        
        try:
            model_name, record_id = self.record_ref.split(',')
            return {
                'type': 'ir.actions.act_window',
                'name': self.name,
                'res_model': model_name,
                'res_id': int(record_id),
                'view_mode': 'form',
                'target': 'current',
            }
        except Exception as e:
            _logger.error(f"Error opening source record: {e}")
            return None
    
    def action_view_rule(self):
        """Open the governance rule that triggered this approval."""
        self.ensure_one()
        if not self.rule_id:
            return None
        
        return {
            'type': 'ir.actions.act_window',
            'name': self.rule_id.name,
            'res_model': 'ops.governance.rule',
            'res_id': self.rule_id.id,
            'view_mode': 'form',
            'target': 'current',
        }
    
    def _find_governance_approvers(self):
        """Find approvers for governance violations based on matrix dimensions."""
        self.ensure_one()
        
        if not self.rule_id:
            return self.env['res.users']
        
        # Use rule's approver finding logic
        if self.record_ref:
            try:
                model_name, record_id = self.record_ref.split(',')
                record = self.env[model_name].browse(int(record_id))
                if record.exists():
                    return self.rule_id._find_approvers(record, self.violation_type or 'other')
            except Exception as e:
                _logger.error(f"Error finding governance approvers: {e}")
        
        return self.env['res.users']

    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsApprovalRequest':
        """Auto-set governance approvers and inherit matrix dimensions from source record."""
        for vals in vals_list:
            # Generate sequence if needed
            if vals.get('name', 'New') == 'New':
                vals['name'] = self.env['ir.sequence'].next_by_code('ops.approval.request') or 'APP/0001'
            
            # Inherit matrix dimensions from source record
            if vals.get('model_name') and vals.get('res_id'):
                try:
                    record = self.env[vals['model_name']].browse(vals['res_id'])
                    if record.exists():
                        # Legacy fields (backward compatibility)
                        if hasattr(record, 'branch_id') and 'branch_id' not in vals:
                            vals['branch_id'] = record.branch_id.id if record.branch_id else False
                        if hasattr(record, 'business_unit_id') and 'business_unit_id' not in vals:
                            vals['business_unit_id'] = record.business_unit_id.id if record.business_unit_id else False
                except Exception as e:
                    _logger.debug(f"Could not inherit matrix dimensions: {e}")
        
        records = super().create(vals_list)
        
        # Set approvers for governance violations
        for record in records:
            if record.is_governance_violation and not record.approver_ids:
                # Find governance-specific approvers
                approvers = record._find_governance_approvers()
                if approvers:
                    record.approver_ids = [(6, 0, approvers.ids)]
        
        return records
    
    def write(self, vals):
        """Track approval/rejection of governance violations."""
        result = super().write(vals)
        
        # If approved/rejected, update source record if it's a governance violation
        if 'state' in vals and vals['state'] in ['approved', 'rejected']:
            for record in self:
                if record.is_governance_violation:
                    record._update_source_record_approval(vals['state'])
        
        return result
    
    def _update_source_record_approval(self, approval_state):
        """Update source record with approval status."""
        for approval in self:
            if not approval.record_ref:
                continue
            
            try:
                model_name, record_id = approval.record_ref.split(',')
                record = self.env[model_name].browse(int(record_id))
                
                if record.exists():
                    # Add approval note to record
                    approval_note = _("Governance approval %s: %s") % (approval_state, approval.name)
                    
                    if hasattr(record, 'message_post'):
                        record.message_post(body=approval_note)
                    
                    # Set approval status field if it exists
                    if hasattr(record, 'governance_approval_status'):
                        record.governance_approval_status = approval_state
                    if hasattr(record, 'governance_approval_id'):
                        record.governance_approval_id = approval.id
            
            except Exception as e:
                _logger.error(f"Error updating source record: {e}")

    def action_approve(self) -> bool:
        """Approve the request."""
        self.ensure_one()
        if self.state != 'pending':
            return False
            
        self.write({
            'state': 'approved',
            'approved_by': self.env.user.id,
            'approved_date': fields.Datetime.now(),
        })
        
        # Unlock the record if it was locked
        if self.model_name and self.res_id:
            try:
                record = self.env[self.model_name].browse(self.res_id)
                if record.exists() and hasattr(record, 'approval_locked'):
                    record.write({'approval_locked': False})
            except Exception as e:
                _logger.debug(f"Could not unlock record: {e}")
        
        # Send notification
        try:
            self.message_post(
                body=_("Approval granted by %s") % self.env.user.name,
                message_type='notification'
            )
        except Exception:
            pass
        
        return True

    def action_reject(self) -> bool:
        """Reject the request."""
        self.ensure_one()
        if self.state != 'pending':
            return False
            
        self.write({
            'state': 'rejected',
            'approved_by': self.env.user.id,
            'approved_date': fields.Datetime.now(),
        })
        
        # Unlock the record if it was locked
        if self.model_name and self.res_id:
            try:
                record = self.env[self.model_name].browse(self.res_id)
                if record.exists() and hasattr(record, 'approval_locked'):
                    record.write({'approval_locked': False})
            except Exception as e:
                _logger.debug(f"Could not unlock record: {e}")
        
        # Send notification
        try:
            self.message_post(
                body=_("Approval rejected by %s. Reason: %s") % (self.env.user.name, self.response_notes or 'No reason given'),
                message_type='notification'
            )
        except Exception:
            pass
        
        return True

    def action_cancel(self) -> bool:
        """Cancel the request."""
        self.ensure_one()
        if self.state != 'pending':
            return False
            
        self.write({'state': 'cancelled'})
        
        # Unlock the record if it was locked
        if self.model_name and self.res_id:
            try:
                record = self.env[self.model_name].browse(self.res_id)
                if record.exists() and hasattr(record, 'approval_locked'):
                    record.write({'approval_locked': False})
            except Exception as e:
                _logger.debug(f"Could not unlock record: {e}")
        
        return True

--- ops_matrix_core/models/ops_archive_policy.py ---
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from dateutil.relativedelta import relativedelta

class OpsArchivePolicy(models.Model):
    _name = 'ops.archive.policy'
    _description = 'Data Archiving Policy'

    name = fields.Char(string='Policy Name', required=True)
    model_id = fields.Many2one('ir.model', string='Model', required=True, ondelete='cascade')
    domain_code = fields.Text(string='Domain Filter', default='[]', help="Python domain to filter records for archiving.")
    retention_months = fields.Integer(string='Retention (Months)', default=12, required=True)
    active = fields.Boolean(default=True)

    @api.constrains('model_id')
    def _check_financial_safety(self):
        forbidden_models = [
            'account.move',
            'account.move.line',
            'stock.move',
            'stock.valuation.layer'
        ]
        for record in self:
            if record.model_id.model in forbidden_models:
                raise UserError(_("Safety Violation: Archiving financial or stock valuation data (%s) is strictly prohibited.") % record.model_id.model)

    def _cron_archive_records(self):
        policies = self.search([('active', '=', True)])
        for policy in policies:
            model = self.env[policy.model_id.model]
            cutoff_date = fields.Datetime.now() - relativedelta(months=policy.retention_months)
            
            # Construct domain
            try:
                domain = eval(policy.domain_code or '[]')
            except Exception:
                domain = []
            
            domain += [('create_date', '<', cutoff_date)]
            
            # Search and unlink in batches
            records = model.search(domain, limit=1000)
            if records:
                records.unlink()

--- ops_matrix_core/models/ops_audit_log.py ---
# -*- coding: utf-8 -*-

"""
OPS Matrix API Audit Log
Comprehensive audit logging for all API requests
"""

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)


class OpsAuditLog(models.Model):
    """
    API Audit Log Model for OPS Matrix Framework
    
    Records all API requests for security auditing, compliance, and debugging.
    This is a read-only model from the UI perspective - logs are created by
    the API controller automatically.
    """
    _name = 'ops.audit.log'
    _description = 'OPS Matrix API Audit Log'
    _order = 'timestamp desc'
    _rec_name = 'endpoint'
    
    # Disable standard tracking
    _log_access = True
    
    # ========================================================================
    # FIELDS
    # ========================================================================
    
    timestamp = fields.Datetime(
        string='Timestamp',
        required=True,
        default=fields.Datetime.now,
        index=True,  # Index for performance on time-based queries
        readonly=True,
        help='When the API request was made'
    )
    
    api_key_id = fields.Many2one(
        'ops.api.key',
        string='API Key',
        ondelete='set null',
        index=True,
        readonly=True,
        help='The API key used for this request'
    )
    
    persona_id = fields.Many2one(
        'ops.persona',
        string='Persona',
        ondelete='set null',
        index=True,
        readonly=True,
        help='The persona associated with the API key'
    )
    
    endpoint = fields.Char(
        string='API Endpoint',
        required=True,
        index=True,
        readonly=True,
        help='The API endpoint URL that was called'
    )
    
    http_method = fields.Selection(
        [
            ('GET', 'GET'),
            ('POST', 'POST'),
            ('PUT', 'PUT'),
            ('DELETE', 'DELETE'),
            ('PATCH', 'PATCH'),
            ('OPTIONS', 'OPTIONS'),
            ('HEAD', 'HEAD')
        ],
        string='HTTP Method',
        required=True,
        readonly=True,
        index=True,
        help='HTTP method used for the request'
    )
    
    ip_address = fields.Char(
        string='IP Address',
        readonly=True,
        index=True,
        help='Client IP address that made the request'
    )
    
    user_agent = fields.Text(
        string='User Agent',
        readonly=True,
        help='Client user agent string'
    )
    
    status_code = fields.Integer(
        string='HTTP Status Code',
        readonly=True,
        index=True,
        help='HTTP response status code (200, 401, 500, etc.)'
    )
    
    response_time = fields.Float(
        string='Response Time (seconds)',
        readonly=True,
        digits=(10, 4),
        help='Time taken to process the request in seconds'
    )
    
    error_message = fields.Text(
        string='Error Message',
        readonly=True,
        help='Error message if the request failed'
    )
    
    # Additional context
    request_params = fields.Text(
        string='Request Parameters',
        readonly=True,
        help='Query parameters or request body (sanitized)'
    )
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        readonly=True,
        index=True,
        help='Company context at time of request'
    )
    
    # Computed fields for analytics
    success = fields.Boolean(
        string='Success',
        compute='_compute_success',
        store=True,
        readonly=True,
        help='Whether the request was successful (status code 200-299)'
    )
    
    date = fields.Date(
        string='Date',
        compute='_compute_date',
        store=True,
        index=True,
        readonly=True,
        help='Date of the request (for daily analytics)'
    )
    
    # ========================================================================
    # COMPUTE METHODS
    # ========================================================================
    
    @api.depends('status_code')
    def _compute_success(self):
        """
        Determine if request was successful based on status code
        2xx status codes are considered successful
        """
        for record in self:
            record.success = 200 <= (record.status_code or 0) < 300
    
    @api.depends('timestamp')
    def _compute_date(self):
        """
        Extract date from timestamp for easier daily analytics
        """
        for record in self:
            record.date = record.timestamp.date() if record.timestamp else False
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    
    _sql_constraints = [
        ('check_status_code', 'CHECK(status_code >= 100 AND status_code < 600)', 
         'Invalid HTTP status code!'),
        ('check_response_time', 'CHECK(response_time >= 0)', 
         'Response time cannot be negative!')
    ]
    
    # ========================================================================
    # ORM METHODS
    # ========================================================================
    
    @api.model
    def create(self, vals):
        """
        Override create to ensure audit log integrity
        """
        # Always mark as readonly after creation
        record = super(OpsAuditLog, self).create(vals)
        
        _logger.debug(
            f"Audit log created: {record.endpoint} [{record.http_method}] "
            f"Status: {record.status_code} IP: {record.ip_address}"
        )
        
        return record
    
    def write(self, vals):
        """
        Prevent modification of audit logs (integrity requirement)
        """
        if self.env.user.has_group('base.group_system'):
            # Only allow system admin to modify (for data correction if needed)
            _logger.warning(
                f"Audit log modified by system admin {self.env.user.name}: "
                f"IDs {self.ids}"
            )
            return super(OpsAuditLog, self).write(vals)
        else:
            raise UserError(_('Audit logs cannot be modified to maintain integrity.'))
    
    def unlink(self):
        """
        Prevent deletion of audit logs (except by system admin)
        """
        if self.env.user.has_group('base.group_system'):
            _logger.warning(
                f"Audit logs deleted by system admin {self.env.user.name}: "
                f"IDs {self.ids}"
            )
            return super(OpsAuditLog, self).unlink()
        else:
            raise UserError(_('Audit logs cannot be deleted to maintain integrity.'))
    
    # ========================================================================
    # BUSINESS METHODS
    # ========================================================================
    
    @api.model
    def log_api_request(self, api_key_id=None, endpoint=None, http_method=None,
                       ip_address=None, user_agent=None, status_code=None,
                       response_time=None, error_message=None, request_params=None):
        """
        Create an audit log entry for an API request
        
        This is the main method called by the API controller to log requests.
        
        Args:
            api_key_id (int): ID of the API key used
            endpoint (str): API endpoint URL
            http_method (str): HTTP method (GET, POST, etc.)
            ip_address (str): Client IP address
            user_agent (str): Client user agent
            status_code (int): HTTP response status code
            response_time (float): Request processing time in seconds
            error_message (str): Error message if any
            request_params (str): Request parameters (sanitized)
            
        Returns:
            ops.audit.log: Created audit log record
        """
        vals = {
            'timestamp': fields.Datetime.now(),
            'endpoint': endpoint,
            'http_method': http_method,
            'ip_address': ip_address,
            'user_agent': user_agent,
            'status_code': status_code,
            'response_time': response_time,
            'error_message': error_message,
            'request_params': request_params,
        }
        
        # Add API key and persona if provided
        if api_key_id:
            vals['api_key_id'] = api_key_id
            api_key = self.env['ops.api.key'].sudo().browse(api_key_id)
            if api_key.exists():
                vals['persona_id'] = api_key.persona_id.id
                vals['company_id'] = api_key.company_id.id
        
        # Create log entry using sudo to bypass permissions
        return self.sudo().create(vals)
    
    @api.model
    def cleanup_old_logs(self, days=90):
        """
        Clean up audit logs older than specified days
        
        This should be called by a scheduled action (cron job)
        
        Args:
            days (int): Number of days to retain logs (default 90)
            
        Returns:
            int: Number of logs deleted
        """
        cutoff_date = fields.Datetime.now() - fields.Datetime.to_datetime(f'{days} days')
        
        old_logs = self.sudo().search([('timestamp', '<', cutoff_date)])
        count = len(old_logs)
        
        if count > 0:
            _logger.info(f"Cleaning up {count} audit logs older than {days} days")
            old_logs.unlink()
        
        return count
    
    # ========================================================================
    # ANALYTICS METHODS
    # ========================================================================
    
    @api.model
    def get_api_usage_stats(self, date_from=None, date_to=None):
        """
        Get API usage statistics for a date range
        
        Args:
            date_from (date): Start date
            date_to (date): End date
            
        Returns:
            dict: Usage statistics
        """
        domain = []
        
        if date_from:
            domain.append(('date', '>=', date_from))
        if date_to:
            domain.append(('date', '<=', date_to))
        
        logs = self.search(domain)
        
        if not logs:
            return {
                'total_requests': 0,
                'successful_requests': 0,
                'failed_requests': 0,
                'avg_response_time': 0.0,
                'unique_api_keys': 0,
                'by_endpoint': {},
                'by_status_code': {}
            }
        
        # Calculate statistics
        total = len(logs)
        successful = len(logs.filtered(lambda l: l.success))
        failed = total - successful
        
        # Average response time
        response_times = logs.filtered(lambda l: l.response_time).mapped('response_time')
        avg_response_time = sum(response_times) / len(response_times) if response_times else 0.0
        
        # Unique API keys
        unique_keys = len(logs.mapped('api_key_id'))
        
        # Group by endpoint
        by_endpoint = {}
        for log in logs:
            endpoint = log.endpoint or 'Unknown'
            if endpoint not in by_endpoint:
                by_endpoint[endpoint] = 0
            by_endpoint[endpoint] += 1
        
        # Group by status code
        by_status_code = {}
        for log in logs:
            status = log.status_code or 0
            if status not in by_status_code:
                by_status_code[status] = 0
            by_status_code[status] += 1
        
        return {
            'total_requests': total,
            'successful_requests': successful,
            'failed_requests': failed,
            'success_rate': (successful / total * 100) if total > 0 else 0,
            'avg_response_time': round(avg_response_time, 4),
            'unique_api_keys': unique_keys,
            'by_endpoint': by_endpoint,
            'by_status_code': by_status_code
        }
    
    def action_view_api_key(self):
        """
        Navigate to the API key record
        """
        self.ensure_one()
        
        if not self.api_key_id:
            raise UserError(_('No API key associated with this log entry.'))
        
        return {
            'name': _('API Key'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.api.key',
            'res_id': self.api_key_id.id,
            'view_mode': 'form',
            'target': 'current'
        }

--- ops_matrix_core/models/ops_branch.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
from typing import List, Dict, Any

class OpsBranch(models.Model):
    _name = 'ops.branch'
    _description = 'Operational Branch (not a legal entity)'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'sequence, id'
    _check_company_auto = True

    # ---------------------------------------------------------
    # Required Fields
    # ---------------------------------------------------------
    name = fields.Char(
        required=True,
        tracking=True,
        string='Branch Name',
        help='Descriptive name for this branch/location. '
             'Example: "Downtown Store", "North Region HQ", "Warehouse 3". '
             'This name appears throughout the system in reports and transactions.'
    )
    code = fields.Char(
        string='Code',
        required=True,
        readonly=True,
        copy=False,
        default=lambda self: _('New'),
        tracking=True,
        help='Unique identifier for this branch within the company. '
             'Auto-generated on save (format: BR-XXXX). '
             'Used in reports, analytics, and as reference in transactions. '
             'Cannot be changed after creation. '
             'Example: BR-001, BR-NORTH, BR-WH3'
    )
    company_id = fields.Many2one(
        'res.company',
        required=True,
        ondelete='restrict',
        default=lambda self: self.env.company,
        index=True,
        tracking=True,
        string='Legal Entity',
        help='The legal entity (company) this branch belongs to. '
             'All branches must be associated with a company for legal and tax purposes. '
             'A company can have multiple branches, but a branch belongs to one company. '
             'Note: This is the LEGAL entity, not the operational structure. '
             'Cannot be changed after transactions are created.'
    )
    manager_id = fields.Many2one(
        'res.users',
        string='Branch Manager',
        domain="[('share', '=', False)]",
        tracking=True,
        help='User responsible for this branch\'s operations. '
             'The manager typically has: approval authority, access to branch reports, '
             'and ability to manage branch-specific settings. '
             'Only internal users (not portal users) can be managers. '
             'Related: Configure persona for the manager to set approval limits and permissions.'
    )
    active = fields.Boolean(
        default=True,
        tracking=True,
        help='If unchecked, this branch becomes invisible in most views but data is preserved. '
             'Use this instead of deleting branches that have historical transactions. '
             'Inactive branches cannot be selected in new transactions but existing records remain visible. '
             'To reactivate: check this box again. '
             'Use Case: Closed stores, merged branches, or temporarily inactive locations.'
    )
    
    # ---------------------------------------------------------
    # Optional Fields
    # ---------------------------------------------------------
    parent_id = fields.Many2one(
        'ops.branch',
        string='Parent Branch',
        index=True,
        help='Parent branch in the organizational hierarchy for multi-level structures. '
             'Example: "North Region HQ" (parent) â†’ "Seattle Store" (child) â†’ "Seattle Outlet" (grandchild). '
             'Child branches can inherit settings and roll up reporting to parents. '
             'Leave empty if this is a top-level branch. '
             'Use Cases: Regionalâ†’Cityâ†’Store, Corporateâ†’Divisionâ†’Department. '
             'Warning: Circular hierarchies (Aâ†’Bâ†’A) are automatically prevented.'
    )
    child_ids = fields.One2many(
        'ops.branch',
        'parent_id',
        string='Sub-Branches',
        help='Branches that report to this branch in the hierarchy. '
             'Example: If this is "North Region", children might be "Seattle", "Portland", "Vancouver". '
             'Use for consolidated reporting: parent branch reports include all child branch data. '
             'Automatically populated when child branches set this branch as their parent.'
    )
    address = fields.Text(
        string='Physical Address',
        help='Complete physical address of this branch location. '
             'Include: Street, City, State/Province, ZIP/Postal Code, Country. '
             'Used in: Customer-facing documents (invoices, delivery notes), shipping labels, branch reports. '
             'Format: Use line breaks for readability. '
             'Example: "123 Main Street\\nSuite 400\\nSeattle, WA 98101\\nUnited States". '
             'Best Practice: Keep updated for accurate shipping and legal compliance.'
    )
    phone = fields.Char(
        string='Phone',
        help='Primary contact phone number for this branch. '
             'Used for: Customer service inquiries, inter-branch communication, emergency contacts. '
             'Format: Use your local convention (e.g., +1-555-123-4567, (555) 123-4567, +44 20 1234 5678). '
             'Best Practice: Include country code for international branches. '
             'Example: "+1-206-555-0100" or "(206) 555-0100"'
    )
    email = fields.Char(
        string='Email',
        help='Primary email address for this branch. '
             'Used for: Automated system notifications, inter-branch communication, customer inquiries. '
             'Format: branch@company.com or location-name@company.com. '
             'Examples: "seattle@acme.com", "north-region@acme.com", "warehouse3@acme.com". '
             'Best Practice: Use a group/department email (not personal) to ensure continuity. '
             'This email may appear on customer-facing documents.'
    )
    warehouse_id = fields.Many2one(
        'stock.warehouse',
        string='Primary Warehouse',
        help='The main warehouse associated with this branch for inventory operations. '
             'This warehouse is used by default when creating: stock transfers, sales orders, purchase orders. '
             'A branch can have multiple warehouses, but this is the primary one. '
             'Important: The warehouse must belong to the same company as the branch. '
             'Use Case: For retail branches, this is the stock room; for distribution centers, the main warehouse. '
             'Leave empty if this branch has no inventory operations (e.g., administrative office).'
    )
    sequence = fields.Integer(
        default=10,
        string='Sequence',
        help='Controls the display order of branches in lists and drop-down menus. '
             'Lower numbers appear first. Default is 10. '
             'Example: Set 1 for headquarters, 5 for regional offices, 10 for standard branches. '
             'Use Cases: Prioritize frequently-used branches, group by region, order by importance. '
             'Tip: Use increments of 5 or 10 to allow easy reordering later.'
    )
    color = fields.Integer(
        string='Color Index',
        default=0,
        help='Color coding for visual identification in kanban and calendar views. '
             'Values 0-11 map to predefined colors in the Odoo interface. '
             'Use Cases: Color code by region (Red=West, Blue=East), by type (Green=Retail, Yellow=Warehouse). '
             'Example: All branches in North region use color 2 (blue), South region uses color 1 (red). '
             'Tip: Keep color scheme consistent across your organization for easy recognition.'
    )

    # ---------------------------------------------------------
    # Analytic Integration
    # ---------------------------------------------------------
    analytic_account_id = fields.Many2one(
        'account.analytic.account',
        string='Analytic Account',
        copy=False,
        readonly=True,
        help='Auto-generated analytic account for financial tracking and cost/profit analysis by branch. '
             'Automatically created when the branch is saved. '
             'Used to: Track revenue and expenses by branch, generate P&L reports, allocate costs. '
             'Format: Code and name match the branch (e.g., "BR-001 - Seattle Store"). '
             'This field is READ-ONLY and managed automatically by the system. '
             'Related: All financial transactions for this branch are tagged with this analytic account.'
    )

    # ---------------------------------------------------------
    # Computed Fields
    # ---------------------------------------------------------
    business_unit_count = fields.Integer(
        compute='_compute_business_unit_count',
        string='Business Units Count',
        help='Number of business units (BUs) operating in this branch. '
             'A branch can host multiple BUs (e.g., Retail, Wholesale, Services). '
             'Computed automatically - counts BUs that list this branch in their operating branches. '
             'Click the smart button to view the list of BUs. '
             'Example: "Downtown Store" might have 3 BUs: Retail Electronics, Retail Appliances, Repair Services. '
             'Use Cases: Understanding branch complexity, resource allocation, reporting structure.'
    )

    # ---------------------------------------------------------
    # SQL Constraints
    # ---------------------------------------------------------
    _sql_constraints = [
        ('code_company_unique',
         'UNIQUE(code, company_id)',
         'Branch Code must be unique per company!')
    ]

    # ---------------------------------------------------------
    # Computed Methods
    # ---------------------------------------------------------
    def _compute_business_unit_count(self) -> None:
        """Count business units operating in this branch."""
        for branch in self:
            branch.business_unit_count = self.env['ops.business.unit'].search_count([
                ('branch_ids', 'in', branch.id)
            ])

    # ---------------------------------------------------------
    # Constraints & Validation
    # ---------------------------------------------------------
    @api.constrains('parent_id')
    def _check_parent_recursion(self) -> None:
        """Prevent circular parent relationships."""
        if not self._check_recursion():
            raise ValidationError(_('Error! You cannot create recursive branch hierarchies.'))

    def unlink(self) -> bool:
        """Prevent deletion if branch has active transactions."""
        for branch in self:
            # Check for related transactions
            transaction_models = [
                'sale.order',
                'purchase.order',
                'account.move',
                'stock.picking',
            ]
            
            for model_name in transaction_models:
                if self.env[model_name].search_count([('ops_branch_id', '=', branch.id)], limit=1) > 0:
                    raise UserError(_(
                        "Cannot delete branch '%s' because it has related transactions. "
                        "Please deactivate it instead."
                    ) % branch.name)
        
        return super().unlink()

    # ---------------------------------------------------------
    # CRUD & Analytic Sync
    # ---------------------------------------------------------
    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsBranch':
        """Create branch with auto-generated code and analytic account."""
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.branch') or 'New'
        
        records = super().create(vals_list)
        records._create_analytic_accounts()
        return records

    def write(self, vals: Dict[str, Any]) -> bool:
        """Update branch and sync analytic account if name/code changed."""
        result = super().write(vals)
        if 'name' in vals or 'code' in vals:
            self._sync_analytic_account_name()
        return result

    # ---------------------------------------------------------
    # Analytic Account Management
    # ---------------------------------------------------------
    def _create_analytic_accounts(self) -> None:
        """Auto-create analytic account for each branch."""
        for branch in self:
            if not branch.analytic_account_id:
                analytic_plan = self._get_or_create_analytic_plan('Branch')
                analytic_account = self.env['account.analytic.account'].create({
                    'name': f"{branch.code} - {branch.name}",
                    'code': branch.code,
                    'plan_id': analytic_plan.id,
                    'company_id': branch.company_id.id,
                })
                branch.analytic_account_id = analytic_account.id

    def _sync_analytic_account_name(self) -> None:
        """Sync analytic account name when branch name/code changes."""
        for branch in self:
            if branch.analytic_account_id:
                branch.analytic_account_id.write({
                    'name': f"{branch.code} - {branch.name}",
                    'code': branch.code,
                })

    def _get_or_create_analytic_plan(self, plan_type: str) -> 'account.analytic.plan':
        """Get or create analytic plan for Branch dimension."""
        plan_name = f"Matrix {plan_type}"
        plan = self.env['account.analytic.plan'].search([('name', '=', plan_name)], limit=1)
        if not plan:
            plan = self.env['account.analytic.plan'].create({
                'name': plan_name,
                # Note: company_id removed - not available in Odoo 19
                'description': f'{plan_type} dimension for Matrix reporting',
            })
        return plan

    # ---------------------------------------------------------
    # Display Name
    # ---------------------------------------------------------
    def name_get(self):
        """Display as '[CODE] Name'."""
        result = []
        for branch in self:
            name = f"[{branch.code}] {branch.name}"
            result.append((branch.id, name))
        return result

--- ops_matrix_core/models/ops_business_unit.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from typing import List, Dict, Any

class OpsBusinessUnit(models.Model):
    _name = 'ops.business.unit'
    _description = 'Strategic Business Unit (Profit Center)'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'sequence, id'

    # ---------------------------------------------------------
    # Basic Fields
    # ---------------------------------------------------------
    name = fields.Char(
        required=True,
        tracking=True,
        string='Business Unit Name',
        help='Business Unit name representing a distinct business vertical, product line, or profit center. '
             'Examples: "Retail Division", "Wholesale Operations", "E-Commerce", "Professional Services". '
             'This name appears throughout the system in: reports, product catalogs, financial statements, access control. '
             'Best Practice: Use consistent naming that reflects your organizational structure. '
             'A BU typically has its own P&L and may operate across multiple branches.'
    )
    code = fields.Char(
        string='Code',
        required=True,
        readonly=True,
        copy=False,
        default=lambda self: _('New'),
        tracking=True,
        help='Unique identifier for this Business Unit across all companies. '
             'Auto-generated on save (format: BU-XXXX). '
             'Used in: Product codes, financial reports, analytics, security rules. '
             'Cannot be changed after creation. '
             'Examples: BU-RETAIL, BU-WHSL, BU-ONLINE, BU-SERV. '
             'Format: Alphanumeric, no spaces, typically 6-12 characters. '
             'This code becomes part of product identifiers if product silo is enabled.'
    )
    description = fields.Text(
        string='Description',
        help='Detailed description of this Business Unit\'s purpose, scope, and responsibilities. '
             'Include: Products/services offered, target market, key objectives, operational scope. '
             'Example: "Retail Division handles all consumer-facing retail sales across our store network, '
             'including electronics, appliances, and accessories. Target customers: individual consumers and small businesses." '
             'Use Cases: Onboarding new employees, documenting organizational structure, clarifying BU boundaries. '
             'Best Practice: Keep updated as the BU evolves.'
    )
    sequence = fields.Integer(
        default=10,
        string='Sequence',
        help='Controls the display order of Business Units in lists, reports, and drop-down menus. '
             'Lower numbers appear first. Default is 10. '
             'Example: Set 1 for flagship BU, 5 for major BUs, 10 for standard BUs, 20 for support BUs. '
             'Use Cases: Prioritize frequently-used BUs, group by importance, order by revenue contribution. '
             'Tip: Use increments of 5 or 10 to allow easy reordering without affecting other BUs.'
    )
    active = fields.Boolean(
        default=True,
        tracking=True,
        help='If unchecked, this Business Unit becomes invisible in most views but historical data is preserved. '
             'Use this instead of deleting BUs that have: historical transactions, products, or financial records. '
             'Inactive BUs cannot be selected for new: products, sales orders, or transactions. '
             'Existing products and transactions remain visible and reportable. '
             'To reactivate: check this box again. '
             'Use Cases: Discontinued product lines, merged BUs, seasonal operations, restructured divisions.'
    )
    color = fields.Integer(
        string='Color Index',
        default=0,
        help='Color coding for visual identification in kanban, calendar, and dashboard views. '
             'Values 0-11 map to predefined Odoo colors. '
             'Use Cases: Color code by BU type (Blue=Retail, Green=Wholesale, Yellow=Services), '
             'by performance (Green=profitable, Red=needs attention), or by market segment. '
             'Example: All B2C BUs use color 2 (blue), B2B BUs use color 3 (yellow). '
             'Tip: Maintain consistent color schemes for easy recognition across reports and views.'
    )
    target_margin_percent = fields.Float(
        string='Target Margin %',
        help='Target profit margin percentage for this Business Unit (e.g., 15.0 for 15%). '
             'Used for: Performance dashboards, variance analysis, manager KPIs, executive reports. '
             'The system compares actual margin against this target and highlights variances. '
             'Example: Retail BUs might target 25%, Wholesale 10%, Services 40%. '
             'Calculation: (Revenue - COGS - Operating Expenses) / Revenue Ã— 100. '
             'Best Practice: Review and adjust quarterly based on market conditions and strategic goals. '
             'Leave at 0 if margin targets don\'t apply to this BU.'
    )

    # ---------------------------------------------------------
    # Hierarchy - Link to Branches (not Companies)
    # ---------------------------------------------------------
    branch_ids = fields.Many2many(
        'ops.branch',
        'business_unit_branch_rel',
        'business_unit_id',
        'branch_id',
        string='Operating Branches',
        required=True,
        help='Branches where this Business Unit operates. Required: At least one branch must be selected. '
             'A BU can operate in multiple branches (multi-location BUs) or a single branch (location-specific BUs). '
             'Examples: '
             '- "Retail Electronics" operates in all retail store branches '
             '- "Warehouse Operations" operates only in the distribution center branch '
             '- "Regional Services" operates in all branches within a region. '
             'Access Control: Users need access to BOTH a branch AND this BU to see related transactions. '
             'Reporting: BU reports can be filtered by branch to analyze performance by location.'
    )
    
    company_ids = fields.Many2many(
        'res.company',
        string='Companies',
        compute='_compute_company_ids',
        store=True,
        help='Legal entities (companies) where this BU operates. Computed automatically from operating branches. '
             'A BU spans companies if its branches belong to different legal entities. '
             'This field is READ-ONLY and automatically maintained. '
             'Used for: Multi-company filtering, legal entity reporting, compliance. '
             'Example: If BU operates in branches from Company A and Company B, both companies are listed. '
             'Important: Cannot be edited directly - change the operating branches to update companies.'
    )
    
    primary_branch_id = fields.Many2one(
        'ops.branch',
        string='Primary Branch',
        tracking=True,
        help='The main/headquarters branch for this Business Unit. '
             'This is where the BU Leader typically sits and where administrative functions are based. '
             'Must be one of the branches selected in "Operating Branches" above. '
             'Used for: Default financial reporting location, primary contact branch, cost allocations. '
             'Example: A regional BU operates in 20 stores but has headquarters in the regional office branch. '
             'Optional: Leave empty if there is no primary branch (all branches are equal). '
             'This does NOT restrict operations to only this branch.'
    )

    # ---------------------------------------------------------
    # Leadership
    # ---------------------------------------------------------
    leader_id = fields.Many2one(
        'res.users',
        string='Unit Leader',
        domain="[('share', '=', False)]",
        tracking=True,
        help='User responsible for this Business Unit\'s overall performance and operations. '
             'Typically has: P&L responsibility, strategic decision authority, resource allocation control. '
             'The leader typically receives: performance reports, approval requests, budget variance alerts. '
             'Only internal users (not portal users) can be BU leaders. '
             'Examples: "VP of Retail", "Wholesale Operations Director", "E-Commerce Manager". '
             'Related: Configure a Persona for the leader to set approval limits and delegation rules. '
             'Best Practice: Assign a leader for each active BU to ensure clear accountability.'
    )

    # ---------------------------------------------------------
    # Analytic Integration
    # ---------------------------------------------------------
    analytic_account_id = fields.Many2one(
        'account.analytic.account',
        string='Analytic Account',
        copy=False,
        readonly=True,
        help='Auto-generated analytic account for tracking this BU as a profit center. '
             'Automatically created when the BU is saved. '
             'Used to: Generate P&L by BU, track revenue and costs, analyze profitability, allocate shared expenses. '
             'Format: Code and name match the BU (e.g., "BU-RETAIL - Retail Division"). '
             'All financial transactions for this BU are tagged with this analytic account. '
             'This field is READ-ONLY and managed automatically by the system. '
             'Financial reports can filter by this account to show BU-specific performance.'
    )

    # ---------------------------------------------------------
    # Computed Fields
    # ---------------------------------------------------------
    branch_count = fields.Integer(
        compute='_compute_branch_count',
        string='Branch Count',
        help='Total number of branches where this Business Unit currently operates. '
             'Computed automatically from the "Operating Branches" list. '
             'Click the smart button to view the full list of branches. '
             'Examples: Single-branch BU shows 1, regional BU might show 10-20, nationwide BU could show 100+. '
             'Use Cases: Assessing BU scale, resource planning, understanding operational complexity. '
             'Performance Tip: BUs operating in many branches may need dedicated coordination roles.'
    )

    @api.depends('branch_ids')
    def _compute_branch_count(self) -> None:
        """Count branches for this BU."""
        for bu in self:
            bu.branch_count = len(bu.branch_ids)

    @api.depends('branch_ids', 'branch_ids.company_id')
    def _compute_company_ids(self) -> None:
        """Compute companies from branches."""
        for bu in self:
            bu.company_ids = bu.branch_ids.mapped('company_id')

    # ---------------------------------------------------------
    # Constraints & Validation
    # ---------------------------------------------------------
    @api.constrains('branch_ids')
    def _check_branch_ids(self) -> None:
        """Business Unit must operate in at least one branch."""
        for bu in self:
            if not bu.branch_ids:
                raise ValidationError(_("Business Unit must operate in at least one branch."))

    @api.constrains('primary_branch_id', 'branch_ids')
    def _check_primary_branch(self) -> None:
        """Primary branch must be in operating branches."""
        for bu in self:
            if bu.primary_branch_id and bu.primary_branch_id not in bu.branch_ids:
                raise ValidationError(_(
                    "Primary branch '%s' must be in the list of operating branches."
                ) % bu.primary_branch_id.name)

    _sql_constraints = [
        ('code_unique',
         'UNIQUE(code)',
         'Business Unit Code must be unique!')
    ]

    # ---------------------------------------------------------
    # CRUD & Analytic Sync
    # ---------------------------------------------------------
    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsBusinessUnit':
        """Create BU with auto-generated code and analytic account."""
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.business.unit') or 'New'
        
        records = super().create(vals_list)
        records._create_analytic_accounts()
        return records

    def write(self, vals: Dict[str, Any]) -> bool:
        """Update BU and sync analytic account if name/code changed."""
        result = super().write(vals)
        if 'name' in vals or 'code' in vals:
            self._sync_analytic_account_name()
        return result

    # ---------------------------------------------------------
    # Analytic Account Management
    # ---------------------------------------------------------
    def _create_analytic_accounts(self) -> None:
        """Create one analytic account per BU (not per branch)."""
        for bu in self:
            if not bu.analytic_account_id:
                # Use primary branch's company, or first company if no primary
                company_id = False
                if bu.primary_branch_id:
                    company_id = bu.primary_branch_id.company_id.id
                elif bu.company_ids:
                    company_id = bu.company_ids[0].id
                else:
                    company_id = self.env.company.id
                
                analytic_plan = self._get_or_create_analytic_plan('Business Unit')
                analytic_account = self.env['account.analytic.account'].create({
                    'name': f"{bu.code} - {bu.name}",
                    'code': bu.code,
                    'plan_id': analytic_plan.id,
                    'company_id': company_id,
                })
                bu.analytic_account_id = analytic_account.id

    def _sync_analytic_account_name(self) -> None:
        """Sync analytic account name when BU name/code changes."""
        for bu in self:
            if bu.analytic_account_id:
                bu.analytic_account_id.write({
                    'name': f"{bu.code} - {bu.name}",
                    'code': bu.code,
                })

    def _get_or_create_analytic_plan(self, plan_type: str) -> 'account.analytic.plan':
        """Get or create analytic plan for Business Unit dimension."""
        plan_name = f"Matrix {plan_type}"
        plan = self.env['account.analytic.plan'].search([('name', '=', plan_name)], limit=1)
        if not plan:
            plan = self.env['account.analytic.plan'].create({
                'name': plan_name,
                # Note: company_id removed - not available in Odoo 19
                'description': f'{plan_type} dimension for Matrix reporting',
            })
        return plan

    # ---------------------------------------------------------
    # Display Name
    # ---------------------------------------------------------
    def name_get(self):
        """Display as '[CODE] Name'."""
        result = []
        for bu in self:
            name = f"[{bu.code}] {bu.name}"
            result.append((bu.id, name))
        return result

--- ops_matrix_core/models/ops_dashboard_config.py ---
# -*- coding: utf-8 -*-
"""OPS Dashboard Configuration Model for user-specific dashboard preferences."""

from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import logging

_logger = logging.getLogger(__name__)


class OpsDashboardConfig(models.TransientModel):
    """Model for configuring dashboard settings."""
    
    _name = 'ops.dashboard.config'
    _description = 'OPS Dashboard Configuration'
    
    # User Preferences
    user_id = fields.Many2one(
        'res.users',
        string='User',
        default=lambda self: self.env.user,
        required=True
    )
    
    # Dashboard Layout
    dashboard_layout = fields.Selection([
        ('standard', 'Standard (3 columns)'),
        ('wide', 'Wide (2 columns)'),
        ('compact', 'Compact (4 columns)'),
    ], string='Dashboard Layout', default='standard')
    
    # Default Date Range
    default_date_range = fields.Selection([
        ('today', 'Today'),
        ('week', 'This Week'),
        ('month', 'This Month'),
        ('quarter', 'This Quarter'),
        ('year', 'This Year'),
        ('custom', 'Custom'),
    ], string='Default Date Range', default='month')
    
    # Matrix Display Options
    show_branch_first = fields.Boolean(
        string='Show Branch Before BU',
        default=True,
        help='Display Branch then BU (vs BU then Branch)'
    )
    
    include_inactive_dimensions = fields.Boolean(
        string='Include Inactive Dimensions',
        default=False,
        help='Show data for inactive branches/BUs'
    )
    
    # Color Scheme
    color_scheme = fields.Selection([
        ('corporate', 'Corporate (Blue)'),
        ('financial', 'Financial (Green)'),
        ('sales', 'Sales (Orange)'),
        ('inventory', 'Inventory (Purple)'),
        ('custom', 'Custom Colors'),
    ], string='Color Scheme', default='corporate')
    
    # Custom Colors
    primary_color = fields.Char(string='Primary Color', default='#1f77b4')
    secondary_color = fields.Char(string='Secondary Color', default='#ff7f0e')
    success_color = fields.Char(string='Success Color', default='#2ca02c')
    warning_color = fields.Char(string='Warning Color', default='#d62728')
    
    # Widget Configuration
    enabled_widgets = fields.Many2many(
        'ops.dashboard.widget',
        string='Enabled Widgets',
        help='Widgets to display on the dashboard'
    )
    
    widget_positions = fields.Json(
        string='Widget Positions',
        help='JSON storing widget positions on dashboard'
    )
    
    # Performance Settings
    cache_duration = fields.Integer(
        string='Cache Duration (minutes)',
        default=15,
        help='How long to cache dashboard data'
    )
    
    auto_refresh = fields.Boolean(
        string='Auto Refresh',
        default=True,
        help='Automatically refresh dashboard data'
    )
    
    refresh_interval = fields.Integer(
        string='Refresh Interval (seconds)',
        default=300,
        help='Seconds between auto-refresh'
    )
    
    # Methods
    def action_save_configuration(self):
        """Save dashboard configuration for user."""
        self.ensure_one()
        
        # Store configuration in user preferences
        config_data = {
            'dashboard_layout': self.dashboard_layout,
            'default_date_range': self.default_date_range,
            'show_branch_first': self.show_branch_first,
            'include_inactive_dimensions': self.include_inactive_dimensions,
            'color_scheme': self.color_scheme,
            'primary_color': self.primary_color,
            'secondary_color': self.secondary_color,
            'success_color': self.success_color,
            'warning_color': self.warning_color,
            'cache_duration': self.cache_duration,
            'auto_refresh': self.auto_refresh,
            'refresh_interval': self.refresh_interval,
        }
        
        # Save to user
        self.user_id.write({
            'ops_dashboard_config': config_data
        })
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Configuration Saved'),
                'message': _('Dashboard configuration saved successfully.'),
                'type': 'success',
                'sticky': False,
            }
        }
    
    def action_reset_to_defaults(self):
        """Reset dashboard configuration to defaults."""
        self.ensure_one()
        
        default_values = {
            'dashboard_layout': 'standard',
            'default_date_range': 'month',
            'show_branch_first': True,
            'include_inactive_dimensions': False,
            'color_scheme': 'corporate',
            'primary_color': '#1f77b4',
            'secondary_color': '#ff7f0e',
            'success_color': '#2ca02c',
            'warning_color': '#d62728',
            'cache_duration': 15,
            'auto_refresh': True,
            'refresh_interval': 300,
        }
        
        self.write(default_values)
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Reset to Defaults'),
                'message': _('Dashboard configuration reset to defaults.'),
                'type': 'info',
                'sticky': False,
            }
        }

--- ops_matrix_core/models/ops_dashboard_widget.py ---
# -*- coding: utf-8 -*-
"""OPS Dashboard Widget Model for defining reusable dashboard components."""

from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import logging

_logger = logging.getLogger(__name__)


class OpsDashboardWidget(models.Model):
    """Model for dashboard widgets."""
    
    _name = 'ops.dashboard.widget'
    _description = 'OPS Dashboard Widget'
    _order = 'sequence, name'
    
    # Basic Information
    name = fields.Char(
        string='Widget Name',
        required=True,
        translate=True
    )
    
    code = fields.Char(
        string='Widget Code',
        required=True,
        copy=False,
        help='Unique code for this widget'
    )
    
    description = fields.Text(
        string='Description',
        translate=True
    )
    
    # Technical Configuration
    widget_type = fields.Selection([
        ('kpi', 'KPI Card'),
        ('chart', 'Chart'),
        ('table', 'Data Table'),
        ('pivot', 'Pivot Table'),
        ('graph', 'Graph'),
        ('gauge', 'Gauge'),
        ('progress', 'Progress Bar'),
    ], string='Widget Type', required=True)
    
    model_name = fields.Char(
        string='Model',
        required=True,
        help='Technical name of the Odoo model (e.g., sale.order)'
    )
    
    domain = fields.Char(
        string='Domain',
        help='Domain filter for widget data (Python expression)'
    )
    
    # Display Configuration
    sequence = fields.Integer(
        string='Sequence',
        default=10,
        help='Display order in dashboard'
    )
    
    icon = fields.Char(
        string='Icon',
        help='FontAwesome icon class (e.g., fa-chart-line)'
    )
    
    color = fields.Char(
        string='Color',
        default='#1f77b4',
        help='Widget color (hex code)'
    )
    
    height = fields.Integer(
        string='Height (px)',
        default=300,
        help='Widget height in pixels'
    )
    
    width = fields.Selection([
        ('small', 'Small (1 column)'),
        ('medium', 'Medium (2 columns)'),
        ('large', 'Large (3 columns)'),
        ('full', 'Full width'),
    ], string='Width', default='medium')
    
    # Data Configuration
    measure_field = fields.Char(
        string='Measure Field',
        help='Field to measure (e.g., amount_total)'
    )
    
    dimension_field = fields.Char(
        string='Dimension Field',
        help='Field to group by (e.g., partner_id)'
    )
    
    group_by_fields = fields.Char(
        string='Group By Fields',
        help='Comma-separated list of fields to group by'
    )
    
    sort_by = fields.Char(
        string='Sort By',
        help='Field to sort results by'
    )
    
    limit = fields.Integer(
        string='Record Limit',
        default=10,
        help='Maximum number of records to display'
    )
    
    # Security
    group_ids = fields.Many2many(
        'res.groups',
        string='Allowed Groups',
        help='User groups that can see this widget'
    )
    
    company_ids = fields.Many2many(
        'res.company',
        string='Companies',
        help='Companies where this widget is available'
    )
    
    # Status
    active = fields.Boolean(
        string='Active',
        default=True
    )
    
    is_system = fields.Boolean(
        string='System Widget',
        default=False,
        help='System widgets cannot be deleted'
    )
    
    # SQL Constraints
    _sql_constraints = [
        ('code_unique', 'UNIQUE(code)', 'Widget code must be unique!'),
    ]
    
    # Methods
    @api.constrains('domain')
    def _check_domain(self):
        """Validate domain expression."""
        for widget in self:
            if widget.domain:
                try:
                    # Try to evaluate the domain to check syntax
                    eval(widget.domain)
                except Exception as e:
                    raise ValidationError(
                        _('Invalid domain expression: %s') % str(e)
                    )
    
    def get_widget_data(self, user_id=None, context=None):
        """Get data for this widget."""
        self.ensure_one()
        
        user = self.env['res.users'].browse(user_id) if user_id else self.env.user
        ctx = context or {}
        
        # Apply security filters
        domain = self._get_security_domain(user)
        if self.domain:
            domain += eval(self.domain)
        
        # Get data based on widget type
        data = {}
        if self.widget_type == 'kpi':
            data = self._get_kpi_data(domain, user, ctx)
        elif self.widget_type == 'chart':
            data = self._get_chart_data(domain, user, ctx)
        elif self.widget_type == 'table':
            data = self._get_table_data(domain, user, ctx)
        elif self.widget_type == 'pivot':
            data = self._get_pivot_data(domain, user, ctx)
        
        return data
    
    def _get_security_domain(self, user):
        """Get security domain based on user's matrix access."""
        domain = []
        
        if not self.model_name:
            return domain
            
        Model = self.env[self.model_name]
        
        # Company restriction
        if hasattr(Model, 'company_id') and user.company_ids:
            domain.append(('company_id', 'in', user.company_ids.ids))
        
        # Branch restriction (if model has ops_branch_id)
        if hasattr(Model, 'ops_branch_id'):
            if user.allowed_branch_ids:
                domain.append(('ops_branch_id', 'in', user.allowed_branch_ids.ids))
        
        # BU restriction (if model has ops_business_unit_id)
        if hasattr(Model, 'ops_business_unit_id'):
            if user.allowed_business_unit_ids:
                domain.append(('ops_business_unit_id', 'in', user.allowed_business_unit_ids.ids))
        
        return domain
    
    def _get_kpi_data(self, domain, user, context):
        """Get KPI data for widget."""
        if not self.measure_field:
            return {'value': 0, 'label': self.name}
        
        Model = self.env[self.model_name]
        records = Model.search(domain)
        
        # Calculate aggregate
        value = sum(records.mapped(self.measure_field))
        
        return {
            'value': value,
            'label': self.name,
            'icon': self.icon,
            'color': self.color,
        }
    
    def _get_chart_data(self, domain, user, context):
        """Get chart data for widget."""
        if not self.dimension_field or not self.measure_field:
            return {'labels': [], 'values': []}
        
        Model = self.env[self.model_name]
        
        # Use read_group for aggregation
        group_by = self.dimension_field
        data = Model.read_group(
            domain,
            [self.measure_field],
            [group_by],
            limit=self.limit,
            orderby=self.sort_by or f'{self.measure_field} desc'
        )
        
        labels = []
        values = []
        
        for item in data:
            label = item.get(group_by, 'Unknown')
            if isinstance(label, tuple):
                label = label[1]  # Get display name from tuple
            labels.append(str(label))
            values.append(item.get(self.measure_field, 0))
        
        return {
            'labels': labels,
            'values': values,
            'color': self.color,
        }
    
    def _get_table_data(self, domain, user, context):
        """Get table data for widget."""
        Model = self.env[self.model_name]
        
        fields = []
        if self.group_by_fields:
            fields = [f.strip() for f in self.group_by_fields.split(',')]
        if self.measure_field and self.measure_field not in fields:
            fields.append(self.measure_field)
        
        records = Model.search(domain, limit=self.limit, order=self.sort_by or 'id desc')
        
        data = []
        for record in records:
            row = {}
            for field in fields:
                value = record[field]
                if isinstance(value, models.Model):
                    value = value.display_name
                row[field] = value
            data.append(row)
        
        return {
            'headers': fields,
            'rows': data,
        }
    
    def _get_pivot_data(self, domain, user, context):
        """Get pivot data for widget."""
        # Similar to chart data but structured for pivot display
        return self._get_chart_data(domain, user, context)
    
    @api.ondelete(at_uninstall=False)
    def _unlink_except_system(self):
        """Prevent deletion of system widgets."""
        if any(widget.is_system for widget in self):
            raise UserError(
                _('System widgets cannot be deleted.')
            )

--- ops_matrix_core/models/ops_governance_limits.py ---
# -*- coding: utf-8 -*-

from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
import logging

_logger = logging.getLogger(__name__)


class OpsGovernanceDiscountLimit(models.Model):
    """Role-Based Discount Limits integrated with Persona Model"""
    _name = 'ops.governance.discount.limit'
    _description = 'Role-Based Discount Limits'
    _order = 'max_discount_percent desc'
    
    rule_id = fields.Many2one('ops.governance.rule', required=True, ondelete='cascade', string='Governance Rule')
    
    # Target definition (either persona or group)
    persona_id = fields.Many2one('ops.persona', string='Persona/Role',
                                 help='Apply limit to users with this persona')
    user_group_id = fields.Many2one('res.groups', string='User Group',
                                    help='Alternative to persona: apply to all users in group')
    
    # Limit configuration
    max_discount_percent = fields.Float(
        string='Maximum Discount %', 
        required=True,
        digits=(5, 2), 
        default=0.0,
        help='Maximum discount percentage without approval'
    )
    
    approval_required_above = fields.Float(
        string='Approval Required Above %',
        digits=(5, 2),
        help='Discount percentage that triggers approval requirement'
    )
    
    # Approval configuration
    approver_persona_ids = fields.Many2many(
        'ops.persona', 
        'discount_limit_approver_rel',
        'limit_id',
        'persona_id',
        string='Approver Personas',
        help='Personas that can approve discount exceptions'
    )
    
    approver_group_ids = fields.Many2many(
        'res.groups', 
        'discount_limit_group_approver_rel',
        'limit_id',
        'group_id',
        string='Approver Groups',
        help='User groups that can approve discount exceptions'
    )
    
    # Scope restrictions
    branch_ids = fields.Many2many(
        'ops.branch', 
        'discount_limit_branch_rel',
        'limit_id',
        'branch_id',
        string='Applicable Branches',
        help='Limit applies only to these branches (empty = all)'
    )
    
    business_unit_ids = fields.Many2many(
        'ops.business.unit', 
        'discount_limit_bu_rel',
        'limit_id',
        'bu_id',
        string='Applicable Business Units',
        help='Limit applies only to these BUs (empty = all)'
    )
    
    product_category_ids = fields.Many2many(
        'product.category', 
        'discount_limit_category_rel',
        'limit_id',
        'category_id',
        string='Applicable Categories',
        help='Limit applies only to these categories (empty = all)'
    )
    
    # Validation
    @api.constrains('persona_id', 'user_group_id')
    def _check_target(self):
        """Ensure either persona or group is specified, but not both."""
        for limit in self:
            if not limit.persona_id and not limit.user_group_id:
                raise ValidationError(_("Either Persona or User Group must be specified"))
            if limit.persona_id and limit.user_group_id:
                raise ValidationError(_("Specify either Persona OR User Group, not both"))
    
    @api.constrains('max_discount_percent', 'approval_required_above')
    def _check_percentages(self):
        """Validate percentage values."""
        for limit in self:
            if limit.max_discount_percent < 0 or limit.max_discount_percent > 100:
                raise ValidationError(_("Maximum discount must be between 0 and 100"))
            if limit.approval_required_above and (limit.approval_required_above < 0 or limit.approval_required_above > 100):
                raise ValidationError(_("Approval threshold must be between 0 and 100"))
    
    def get_applicable_limit(self, user, branch_id=False, bu_id=False, category_id=False):
        """Get applicable discount limit for user in context."""
        self.ensure_one()
        
        # Check persona match
        user_personas = user.persona_ids if hasattr(user, 'persona_ids') else self.env['ops.persona']
        
        for persona in user_personas:
            if self.persona_id == persona:
                # Check scope restrictions
                if self._check_scope(branch_id, bu_id, category_id):
                    return self.max_discount_percent
        
        # Check group match
        if self.user_group_id and user.has_group(self.user_group_id.xml_id or 'base.group_user'):
            if self._check_scope(branch_id, bu_id, category_id):
                return self.max_discount_percent
        
        return 0.0
    
    def _check_scope(self, branch_id, bu_id, category_id):
        """Check if limit applies to given scope."""
        # Check branch scope
        if self.branch_ids and branch_id not in self.branch_ids.ids:
            return False
        
        # Check BU scope
        if self.business_unit_ids and bu_id not in self.business_unit_ids.ids:
            return False
        
        # Check category scope
        if self.product_category_ids and category_id not in self.product_category_ids.ids:
            return False
        
        return True


class OpsGovernanceMarginRule(models.Model):
    """Category-Specific Margin Rules with BU/Branch dimensions"""
    _name = 'ops.governance.margin.rule'
    _description = 'Category-Specific Margin Rules'
    _order = 'minimum_margin_percent desc'
    
    rule_id = fields.Many2one('ops.governance.rule', required=True, ondelete='cascade', string='Governance Rule')
    
    # Scope definition
    product_category_id = fields.Many2one(
        'product.category', 
        string='Product Category',
        required=True,
        help='Product category this margin rule applies to'
    )
    
    business_unit_id = fields.Many2one(
        'ops.business.unit', 
        string='Business Unit',
        help='Optional: restrict to specific BU'
    )
    
    branch_id = fields.Many2one(
        'ops.branch', 
        string='Branch',
        help='Optional: restrict to specific branch'
    )
    
    # Margin thresholds
    minimum_margin_percent = fields.Float(
        string='Minimum Margin %', 
        required=True,
        digits=(5, 2), 
        default=0.0,
        help='Minimum acceptable margin percentage'
    )
    
    warning_margin_percent = fields.Float(
        string='Warning Threshold %',
        digits=(5, 2),
        help='Margin percentage that triggers warning (above minimum)'
    )
    
    critical_margin_percent = fields.Float(
        string='Critical Threshold %',
        digits=(5, 2),
        help='Margin percentage that requires immediate attention'
    )
    
    # Approval configuration
    approver_persona_ids = fields.Many2many(
        'ops.persona', 
        'margin_rule_approver_rel',
        'rule_id',
        'persona_id',
        string='Approver Personas',
        help='Personas that can approve margin exceptions'
    )
    
    auto_escalate_below = fields.Float(
        string='Auto-Escalate Below %',
        digits=(5, 2),
        help='Auto-create approval request when margin falls below this'
    )
    
    # Special handling
    allow_negative_margin = fields.Boolean(
        string='Allow Negative Margin',
        default=False,
        help='Allow margin below zero with approval'
    )
    
    exclude_from_reports = fields.Boolean(
        string='Exclude from Margin Reports',
        default=False,
        help='Hide this category from standard margin reports'
    )
    
    @api.constrains('minimum_margin_percent', 'warning_margin_percent', 'critical_margin_percent')
    def _check_margin_thresholds(self):
        """Validate margin threshold relationships."""
        for rule in self:
            if rule.warning_margin_percent and rule.warning_margin_percent < rule.minimum_margin_percent:
                raise ValidationError(_("Warning threshold must be greater than minimum margin"))
            if rule.critical_margin_percent and rule.critical_margin_percent < rule.minimum_margin_percent:
                raise ValidationError(_("Critical threshold must be greater than minimum margin"))
    
    def get_applicable_margin(self, category_id, bu_id=False, branch_id=False):
        """Get applicable minimum margin for given context."""
        # Try exact match (category + BU + branch)
        if bu_id and branch_id:
            rule = self.search([
                ('product_category_id', '=', category_id),
                ('business_unit_id', '=', bu_id),
                ('branch_id', '=', branch_id),
                ('rule_id', '=', self.rule_id.id),
            ], limit=1)
            if rule:
                return rule.minimum_margin_percent
        
        # Try category + BU
        if bu_id:
            rule = self.search([
                ('product_category_id', '=', category_id),
                ('business_unit_id', '=', bu_id),
                ('branch_id', '=', False),
                ('rule_id', '=', self.rule_id.id),
            ], limit=1)
            if rule:
                return rule.minimum_margin_percent
        
        # Try category + branch
        if branch_id:
            rule = self.search([
                ('product_category_id', '=', category_id),
                ('business_unit_id', '=', False),
                ('branch_id', '=', branch_id),
                ('rule_id', '=', self.rule_id.id),
            ], limit=1)
            if rule:
                return rule.minimum_margin_percent
        
        # Try category only
        rule = self.search([
            ('product_category_id', '=', category_id),
            ('business_unit_id', '=', False),
            ('branch_id', '=', False),
            ('rule_id', '=', self.rule_id.id),
        ], limit=1)
        if rule:
            return rule.minimum_margin_percent
        
        return 0.0


class OpsGovernancePriceAuthority(models.Model):
    """Role-Based Pricing Authority for price override control"""
    _name = 'ops.governance.price.authority'
    _description = 'Role-Based Pricing Authority'
    _order = 'max_price_variance_percent desc'
    
    rule_id = fields.Many2one('ops.governance.rule', required=True, ondelete='cascade', string='Governance Rule')
    
    # Authority definition
    persona_id = fields.Many2one(
        'ops.persona', 
        string='Persona/Role',
        help='Apply authority to users with this persona'
    )
    
    user_group_id = fields.Many2one(
        'res.groups', 
        string='User Group',
        help='Alternative to persona: apply to all users in group'
    )
    
    # Price variance limits
    max_price_variance_percent = fields.Float(
        string='Maximum Price Variance %',
        digits=(5, 2), 
        default=0.0,
        help='Maximum allowed variance from list price (%)'
    )
    
    max_price_increase_percent = fields.Float(
        string='Maximum Price Increase %',
        digits=(5, 2),
        help='Maximum allowed price increase (%)'
    )
    
    max_price_decrease_percent = fields.Float(
        string='Maximum Price Decrease %',
        digits=(5, 2),
        help='Maximum allowed price decrease (%)'
    )
    
    # Override permissions
    can_override_without_approval = fields.Boolean(
        string='Can Override Without Approval',
        default=False,
        help='User can override price without approval'
    )
    
    approval_required_above = fields.Float(
        string='Approval Required Above %',
        digits=(5, 2),
        help='Price variance that triggers approval requirement'
    )
    
    # Scope restrictions
    branch_ids = fields.Many2many(
        'ops.branch', 
        'price_authority_branch_rel',
        'authority_id',
        'branch_id',
        string='Applicable Branches',
        help='Authority applies only to these branches (empty = all)'
    )
    
    business_unit_ids = fields.Many2many(
        'ops.business.unit', 
        'price_authority_bu_rel',
        'authority_id',
        'bu_id',
        string='Applicable Business Units',
        help='Authority applies only to these BUs (empty = all)'
    )
    
    product_category_ids = fields.Many2many(
        'product.category', 
        'price_authority_category_rel',
        'authority_id',
        'category_id',
        string='Applicable Categories',
        help='Authority applies only to these categories (empty = all)'
    )
    
    # Approval configuration
    approver_persona_ids = fields.Many2many(
        'ops.persona', 
        'price_authority_approver_rel',
        'authority_id',
        'persona_id',
        string='Approver Personas',
        help='Personas that can approve price overrides'
    )
    
    # Validation
    @api.constrains('persona_id', 'user_group_id')
    def _check_target(self):
        """Ensure either persona or group is specified, but not both."""
        for auth in self:
            if not auth.persona_id and not auth.user_group_id:
                raise ValidationError(_("Either Persona or User Group must be specified"))
            if auth.persona_id and auth.user_group_id:
                raise ValidationError(_("Specify either Persona OR User Group, not both"))
    
    @api.constrains('max_price_variance_percent', 'max_price_increase_percent', 'max_price_decrease_percent')
    def _check_percentages(self):
        """Validate percentage values."""
        for auth in self:
            if auth.max_price_variance_percent < 0 or auth.max_price_variance_percent > 100:
                raise ValidationError(_("Price variance must be between 0 and 100"))
            if auth.max_price_increase_percent and (auth.max_price_increase_percent < 0 or auth.max_price_increase_percent > 100):
                raise ValidationError(_("Price increase must be between 0 and 100"))
            if auth.max_price_decrease_percent and (auth.max_price_decrease_percent < 0 or auth.max_price_decrease_percent > 100):
                raise ValidationError(_("Price decrease must be between 0 and 100"))
    
    def get_applicable_authority(self, user, branch_id=False, bu_id=False, category_id=False):
        """Get applicable price authority for user in context."""
        self.ensure_one()
        
        # Check persona match
        user_personas = user.persona_ids if hasattr(user, 'persona_ids') else self.env['ops.persona']
        
        for persona in user_personas:
            if self.persona_id == persona:
                # Check scope restrictions
                if self._check_scope(branch_id, bu_id, category_id):
                    return {
                        'max_variance': self.max_price_variance_percent,
                        'can_override': self.can_override_without_approval,
                        'requires_approval_above': self.approval_required_above,
                    }
        
        # Check group match
        if self.user_group_id and user.has_group(self.user_group_id.xml_id or 'base.group_user'):
            if self._check_scope(branch_id, bu_id, category_id):
                return {
                    'max_variance': self.max_price_variance_percent,
                    'can_override': self.can_override_without_approval,
                    'requires_approval_above': self.approval_required_above,
                }
        
        # Default: no authority
        return {'max_variance': 0.0, 'can_override': False, 'requires_approval_above': 0.0}
    
    def _check_scope(self, branch_id, bu_id, category_id):
        """Check if authority applies to given scope."""
        # Check branch scope
        if self.branch_ids and branch_id not in self.branch_ids.ids:
            return False
        
        # Check BU scope
        if self.business_unit_ids and bu_id not in self.business_unit_ids.ids:
            return False
        
        # Check category scope
        if self.product_category_ids and category_id not in self.product_category_ids.ids:
            return False
        
        return True


class OpsApprovalWorkflow(models.Model):
    """Approval Workflow Definition for multi-step approvals"""
    _name = 'ops.approval.workflow'
    _description = 'Approval Workflow Definition'
    _order = 'name'
    
    name = fields.Char(string='Workflow Name', required=True)
    code = fields.Char(string='Code', required=True, readonly=True, copy=False, default='New')
    active = fields.Boolean(string='Active', default=True)
    description = fields.Text(string='Description')
    
    # Steps configuration
    step_ids = fields.One2many(
        'ops.approval.workflow.step', 
        'workflow_id',
        string='Approval Steps',
        help='Define the sequence of approval steps'
    )
    
    # Settings
    allow_parallel_approval = fields.Boolean(
        string='Allow Parallel Approval',
        default=False,
        help='Multiple approvers can approve simultaneously'
    )
    
    require_unanimous = fields.Boolean(
        string='Require Unanimous Approval',
        default=True,
        help='All approvers must approve'
    )
    
    auto_approve_after_days = fields.Integer(
        string='Auto-Approve After Days',
        default=0,
        help='Automatically approve if no action after X days (0 = disabled)'
    )
    
    # Notifications
    notify_on_submission = fields.Boolean(string='Notify on Submission', default=True)
    notify_on_approval = fields.Boolean(string='Notify on Approval', default=True)
    notify_on_rejection = fields.Boolean(string='Notify on Rejection', default=True)
    
    # Methods
    def get_next_approvers(self, current_step=0):
        """Get approvers for next step in workflow."""
        self.ensure_one()
        steps = self.step_ids.sorted('sequence')
        if current_step >= len(steps):
            return self.env['res.users']
        
        step = steps[current_step]
        return step.get_approvers()
    
    @api.model_create_multi
    def create(self, vals_list):
        """Generate code if not provided."""
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.approval.workflow') or 'WF001'
        return super().create(vals_list)


class OpsApprovalWorkflowStep(models.Model):
    """Approval Workflow Step for defining approval sequences"""
    _name = 'ops.approval.workflow.step'
    _description = 'Approval Workflow Step'
    _order = 'sequence, id'
    
    workflow_id = fields.Many2one('ops.approval.workflow', required=True, ondelete='cascade', string='Workflow')
    sequence = fields.Integer(string='Sequence', required=True, default=10)
    name = fields.Char(string='Step Name', required=True)
    
    # Approver definition
    approver_persona_ids = fields.Many2many(
        'ops.persona', 
        'step_persona_approver_rel',
        'step_id',
        'persona_id',
        string='Approver Personas',
        help='Users with these personas can approve'
    )
    
    approver_group_ids = fields.Many2many(
        'res.groups', 
        'step_group_approver_rel',
        'step_id',
        'group_id',
        string='Approver Groups',
        help='Users in these groups can approve'
    )
    
    specific_approver_ids = fields.Many2many(
        'res.users', 
        'step_specific_approver_rel',
        'step_id',
        'user_id',
        string='Specific Approvers',
        help='Specific users who can approve'
    )
    
    # Conditions
    minimum_approvers_required = fields.Integer(
        string='Minimum Approvers Required', 
        default=1,
        help='Minimum number of approvers required to proceed'
    )
    
    approval_threshold_percent = fields.Integer(
        string='Approval Threshold %', 
        default=100,
        help='Percentage of approvers required to approve'
    )
    
    # Actions
    auto_approve_if_no_action = fields.Boolean(
        string='Auto-Approve If No Action',
        default=False
    )
    
    days_for_auto_approve = fields.Integer(
        string='Days for Auto-Approval',
        default=0
    )
    
    # Methods
    def get_approvers(self):
        """Get all approvers for this step."""
        self.ensure_one()
        approvers = self.env['res.users']
        
        # Get users from personas
        if self.approver_persona_ids:
            approvers |= self.approver_persona_ids.mapped('user_id')
        
        # Get users from groups
        for group in self.approver_group_ids:
            approvers |= self.env['res.users'].search([('groups_id', 'in', group.id)])
        
        # Add specific approvers
        approvers |= self.specific_approver_ids
        
        return approvers

--- ops_matrix_core/models/ops_governance_mixin.py ---
# -*- coding: utf-8 -*-
from odoo import _, models, fields, api
from odoo.exceptions import ValidationError, UserError
from typing import List, Dict, Any, Optional
import logging

_logger = logging.getLogger(__name__)


class OpsGovernanceMixin(models.AbstractModel):
    """
    Mixin to add governance rule enforcement to any model.
    
    Models that inherit from this mixin will automatically enforce
    ops.governance.rule records during create and write operations.
    """
    _name = 'ops.governance.mixin'
    _description = 'Operations Governance Mixin - Rule Enforcement'

    approval_locked = fields.Boolean(
        string='Approval Locked',
        default=False,
        help='Record is locked pending approval',
        copy=False
    )

    approval_request_ids = fields.One2many(
        'ops.approval.request',
        compute='_compute_approval_requests',
        string='Approval Request List'
    )

    approval_request_count = fields.Integer(
        compute='_compute_approval_requests',
        string='Number of Approvals'
    )

    def _compute_approval_requests(self) -> None:
        for record in self:
            if record.id:
                approvals = self.env['ops.approval.request'].search([
                    ('model_name', '=', record._name),
                    ('res_id', '=', record.id),
                ])
                record.approval_request_ids = approvals
                record.approval_request_count = len(approvals)
            else:
                record.approval_request_ids = False
                record.approval_request_count = 0

    def action_view_approvals(self) -> Dict[str, Any]:
        """Open approval requests for this record."""
        self.ensure_one()
        return {
            'name': 'Approval Requests',
            'type': 'ir.actions.act_window',
            'res_model': 'ops.approval.request',
            'view_mode': 'list,form',
            'domain': [('model_name', '=', self._name), ('res_id', '=', self.id)],
            'context': {'default_model_name': self._name, 'default_res_id': self.id},
        }

    def action_request_approval(self) -> bool:
        """Manually request approval."""
        self.ensure_one()
        # Find applicable rules that require approval
        rules = self.env['ops.governance.rule'].search([
            ('model_id.model', '=', self._name),
            ('action_type', '=', 'require_approval'),
            ('active', '=', True),
        ])
        
        if not rules:
            raise UserError(_('No approval rules configured for this model.'))
        
        # Apply first matching rule
        for rule in rules:
            self._apply_governance_rule(rule, 'manual')
            break
        
        return True

    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsGovernanceMixin':
        """
        Override create to enforce governance rules on record creation.
        
        :param vals_list: List of dictionaries for new records
        :return: Created records
        """
        # Create the records first
        records = super().create(vals_list)
        
        # Enforce governance rules
        self._enforce_governance_rules(records, 'on_create')
        
        return records

    def write(self, vals: Dict[str, Any]) -> bool:
        """
        Override write to enforce governance rules on record updates.
        
        :param vals: Dictionary of values to update
        :return: Result of parent write operation
        """
        # Check if record is approval locked
        for record in self:
            if hasattr(record, 'approval_locked') and record.approval_locked:
                # Check if user is trying to change fields other than approval_locked
                if set(vals.keys()) - {'approval_locked'}:
                    # Cancel pending approvals if data changed
                    pending_approvals = self.env['ops.approval.request'].search([
                        ('model_name', '=', record._name),
                        ('res_id', '=', record.id),
                        ('state', '=', 'pending'),
                    ])
                    pending_approvals.write({'state': 'cancelled'})
                    
                    # Unlock and allow change
                    vals['approval_locked'] = False
        
        result = super().write(vals)
        
        # Enforce governance rules
        self._enforce_governance_rules(self, 'on_write')
        
        return result

    def unlink(self) -> bool:
        """
        Override unlink to enforce governance rules on record deletion.
        
        :return: Result of parent unlink operation
        """
        # Enforce governance rules before deletion
        self._enforce_governance_rules(self, 'on_unlink')
        
        return super().unlink()

    def _enforce_governance_rules(self, records, trigger_type: str) -> None:
        """
        Find and enforce all active governance rules for this model and trigger type.
        
        :param records: Record(s) to evaluate rules against
        :param trigger_type: Type of trigger ('on_create', 'on_write', 'on_unlink')
        :raises ValidationError: If a rule with action_type='block' is triggered
        :raises UserError: If a rule with action_type='warning' is triggered
        """
        if not records:
            return

        # ADMIN BYPASS: Skip governance rule enforcement for Administrator and System Managers
        if self.env.su or self.env.user.has_group('base.group_system'):
            # Log admin override for audit trail
            try:
                for record in records:
                    self.env['ops.security.audit'].sudo().log_security_override(
                        model_name=record._name,
                        record_id=record.id,
                        reason=f'Admin bypass used to skip governance rule enforcement on {trigger_type}'
                    )
                _logger.info(
                    "Admin bypass used by %s on %s (trigger: %s)",
                    self.env.user.name,
                    model_name,
                    trigger_type
                )
            except Exception as e:
                _logger.warning("Failed to log admin override: %s", str(e))
            return

        # Get the model name
        model_name = self._name

        # Try to find governance rules, but gracefully handle ACL errors
        try:
            rules = self.env['ops.governance.rule'].search([
                ('active', '=', True),
                ('model_id.model', '=', model_name),
                ('trigger_type', '=', trigger_type),
            ])
        except Exception as e:
            # If user doesn't have access to governance rules, just skip enforcement
            _logger.debug(f"Governance rule enforcement skipped (ACL/access issue): {str(e)}")
            return

        if not rules:
            return

        # Evaluate each rule
        warnings = []
        for rule in rules:
            for record in records:
                res = self._apply_governance_rule(rule, trigger_type, record)
                if res and 'warning' in res:
                    warnings.append(res['warning']['message'])

        # Display accumulated warnings
        if warnings:
            warning_msg = '\n'.join(set(warnings))  # Remove duplicates
            raise UserError(
                f'Governance Warnings:\n{warning_msg}\n\n'
                f'Please review the above warnings before proceeding.'
            )

    def _apply_governance_rule(self, rule, trigger_type: str, record=None) -> Optional[Dict[str, Any]]:
        """Apply a governance rule and handle different action types."""
        if record is None:
            record = self
            
        # Evaluate condition
        try:
            if rule.condition_code:
                # Clean and validate the code
                code = rule.condition_code.strip()
                if not code:
                    return {}
                
                # Execute in safe context
                safe_locals = {
                    'self': record,
                    'record': record,
                    'user': record.env.user,
                    'env': record.env,
                }
                from odoo.tools.safe_eval import safe_eval
                result = safe_eval(code, safe_locals)
            elif rule.condition_domain:
                domain = rule._parse_domain_string(rule.condition_domain)
                result = bool(record.filtered_domain(domain))
            else:
                result = True
        except SyntaxError as e:
            # Log syntax errors but don't crash
            _logger.error(f"Syntax error in rule {rule.name}: {str(e)}")
            return {}
        except Exception as e:
            # For other errors, show user-friendly message
            raise UserError(f"Error evaluating rule '{rule.name}': {str(e)}")
        
        if result:
            # Rule triggered - take action based on action_type
            if rule.action_type == 'block':
                raise UserError(rule.error_message or f"Operation blocked by rule: {rule.name}")
            
            elif rule.action_type == 'warning':
                return {
                    'warning': {
                        'title': 'Governance Rule Warning',
                        'message': rule.error_message or f"Warning from rule: {rule.name}",
                    }
                }
            
            elif rule.action_type == 'require_approval':
                # ============================================================
                # FOUR-EYES PRINCIPLE (SEGREGATION OF DUTIES)
                # ============================================================
                # Prevent self-approval: A user cannot approve a transaction
                # they themselves created, even if they have the required Persona.
                # This implements the "Four-Eyes Principle" for fraud prevention.
                #
                # Enhanced with vertical escalation and Chatter notifications
                # Exception: System administrators bypass this for emergency situations
                # ============================================================
                if not self.env.user.has_group('base.group_system'):
                    # Check if create_uid exists and matches current user
                    if hasattr(record, 'create_uid') and record.create_uid and record.create_uid.id == self.env.user.id:
                        # Get user's primary persona
                        primary_persona = self.env.user.ops_persona_ids[:1] if self.env.user.ops_persona_ids else False
                        
                        if not primary_persona:
                            # No persona assigned - configuration error
                            _logger.error(
                                f"SoD Configuration Error: User {self.env.user.name} (ID: {self.env.user.id}) "
                                f"has no persona assigned. Record: {record._name} (ID: {record.id})"
                            )
                            raise UserError(
                                _("SoD Configuration Error: You have no persona assigned. "
                                  "Please contact your system administrator to configure your organizational role.")
                            )
                        
                        # Get parent persona for escalation
                        parent_persona = primary_persona.parent_id if primary_persona else False
                        
                        # Log the violation attempt
                        _logger.warning(
                            f"SoD Violation: User {self.env.user.name} (ID: {self.env.user.id}, Persona: {primary_persona.name}) "
                            f"attempted to approve their own record {record._name} (ID: {record.id}). "
                            f"Rule: {rule.name}"
                        )
                        
                        if parent_persona:
                            # Escalation path exists - post Chatter notification
                            if hasattr(record, 'message_post'):
                                try:
                                    # Find users with the parent persona for reference
                                    parent_users = self.env['res.users'].search([
                                        ('ops_persona_ids', 'in', parent_persona.id)
                                    ])
                                    
                                    escalation_body = _(
                                        "ðŸ”’ <strong>Segregation of Duties - Escalation Required</strong><br/><br/>"
                                        "Self-approval restricted. This request has been escalated to <strong>%s</strong> for secondary verification.<br/><br/>"
                                        "<em>User %s (Persona: %s) attempted to self-approve this transaction.</em>"
                                    ) % (parent_persona.name, self.env.user.name, primary_persona.name)
                                    
                                    if parent_users:
                                        escalation_body += _("<br/><br/>Authorized approvers: %s") % ', '.join(parent_users.mapped('name'))
                                    
                                    record.message_post(
                                        body=escalation_body,
                                        subject=_("Segregation of Duties - Escalation Required"),
                                        message_type='notification',
                                        subtype_xmlid='mail.mt_note',
                                    )
                                    _logger.info(
                                        f"SoD escalation posted to Chatter for {record._name} (ID: {record.id}), "
                                        f"escalated to {parent_persona.name}"
                                    )
                                except Exception as e:
                                    # Log but don't fail if Chatter posting fails
                                    _logger.warning(f"Failed to post escalation to Chatter: {str(e)}")
                            
                            # Raise error with escalation information
                            raise UserError(
                                _("SoD Violation: Self-approval is prohibited.\n\n"
                                  "This transaction must be reviewed by your supervisor (%s).\n\n"
                                  "An escalation notice has been logged.") % parent_persona.name
                            )
                        else:
                            # Executive deadlock - no parent authority
                            if hasattr(record, 'message_post'):
                                try:
                                    deadlock_body = _(
                                        "âš ï¸ <strong>Executive Deadlock Detected</strong><br/><br/>"
                                        "User <strong>%s</strong> (Persona: <strong>%s</strong>) attempted self-approval "
                                        "but has no higher authority in the organizational hierarchy.<br/><br/>"
                                        "<em>This transaction requires Superuser or Internal Audit override.</em>"
                                    ) % (self.env.user.name, primary_persona.name)
                                    
                                    record.message_post(
                                        body=deadlock_body,
                                        subject=_("Executive Deadlock - Override Required"),
                                        message_type='notification',
                                        subtype_xmlid='mail.mt_note',
                                    )
                                    _logger.info(
                                        f"Executive deadlock logged for {record._name} (ID: {record.id}), "
                                        f"Persona: {primary_persona.name}"
                                    )
                                except Exception as e:
                                    _logger.warning(f"Failed to post deadlock notice to Chatter: {str(e)}")
                            
                            # Raise error for executive deadlock
                            raise UserError(
                                _("Executive Deadlock: As a %s, you have no higher authority in the organizational structure.\n\n"
                                  "This transaction requires Superuser or Internal Audit override to proceed.") % primary_persona.name
                            )
                
                # Check if already has approved approval
                approved_approval = self.env['ops.approval.request'].search([
                    ('model_name', '=', record._name),
                    ('res_id', '=', record.id),
                    ('rule_id', '=', rule.id),
                    ('state', '=', 'approved'),
                ], limit=1)
                
                if approved_approval:
                    # Approval already granted - allow operation to proceed
                    _logger.info(f"Governance: Approval already granted for {record._name} ID {record.id}")
                    return {}
                
                # Check if already has pending approval
                existing_approval = self.env['ops.approval.request'].search([
                    ('model_name', '=', record._name),
                    ('res_id', '=', record.id),
                    ('rule_id', '=', rule.id),
                    ('state', '=', 'pending'),
                ], limit=1)
                
                if not existing_approval:
                    # Create approval request
                    approval = self.env['ops.approval.request'].create({
                        'rule_id': rule.id,
                        'model_name': record._name,
                        'res_id': record.id,
                        'notes': rule.error_message or f"Approval required by rule: {rule.name}",
                    })
                    
                    # Lock record if configured
                    if rule.lock_on_approval_request and hasattr(record, 'approval_locked'):
                        record.write({'approval_locked': True})
                    
                    # Notify approvers
                    if approval.approver_ids:
                        approval.message_subscribe(partner_ids=approval.approver_ids.mapped('partner_id').ids)
                        approval.message_post(
                            body=f"Approval requested by {record.env.user.name} for {record.display_name}",
                            subject="New Approval Request"
                        )
                    
                    _logger.info(f"Governance: Created approval request {approval.id} for {record._name} ID {record.id}")
                
                # BLOCK THE OPERATION - Approval is required but not yet granted
                raise UserError(
                    rule.error_message or
                    f"This operation requires approval.\n\n"
                    f"An approval request has been submitted to authorized approvers. "
                    f"You will be notified once the approval is granted.\n\n"
                    f"Rule: {rule.name}"
                )
        
        return {}

--- ops_matrix_core/models/ops_governance_rule.py ---
# -*- coding: utf-8 -*-

from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from odoo.tools.safe_eval import safe_eval
import logging

_logger = logging.getLogger(__name__)

TRIGGER_TYPES = [
    ('on_create', 'On Create'),
    ('on_write', 'On Write'),
    ('on_unlink', 'On Delete'),
]

ACTION_TYPES = [
    ('warning', 'Warning'),
    ('block', 'Block'),
    ('require_approval', 'Require Approval'),
]


class OpsGovernanceRule(models.Model):
    _name = 'ops.governance.rule'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _description = 'OPS Governance Rule - Dynamic Rule Engine with Matrix & Pricing Controls'
    _order = 'sequence, name'

    # --- CORE FIELDS ---
    name = fields.Char(
        string='Rule Name',
        required=True,
        tracking=True,
        help='Descriptive name for this governance rule. '
             'Use clear, action-oriented names that explain what the rule enforces. '
             'Examples: "Sales Order Discount Limit", "Margin Protection - Electronics", '
             '"Branch Selection Required", "High-Value Purchase Approval". '
             'Best Practice: Include the rule type and scope in the name for easy identification. '
             'This name appears in: approval requests, violation logs, compliance reports.'
    )
    code = fields.Char(string='Rule Code', required=True, copy=False, readonly=True,
                      default=lambda self: self.env['ir.sequence'].next_by_code('ops.governance.rule') or 'New')
    active = fields.Boolean(string='Active', default=True, tracking=True)
    sequence = fields.Integer(
        string='Sequence',
        default=10,
        help='Order in which rules are evaluated. Lower numbers = higher priority (evaluated first). '
             'Default is 10. Important: Rule evaluation stops at first blocking rule. '
             'Use Cases: '
             '- Critical validations (branch selection): sequence = 1 '
             '- Discount limits: sequence = 5 '
             '- Margin protection: sequence = 10 '
             '- Notifications: sequence = 20. '
             'Tip: Use increments of 5 to allow inserting rules between existing ones.'
    )
    description = fields.Text(string='Description', compute='_compute_description', store=True)
    
    # --- SCOPE & TARGETING ---
    model_id = fields.Many2one(
        'ir.model',
        string='Applies To Model',
        required=True,
        ondelete='cascade',
        help='The Odoo model (object type) this rule applies to. Required. '
             'Common models: '
             '- sale.order (Sales Orders) '
             '- sale.order.line (Sales Order Lines) '
             '- purchase.order (Purchase Orders) '
             '- account.move (Invoices/Bills) '
             '- stock.picking (Transfers). '
             'Scope: Rule only evaluates records of this model type. '
             'Example: Discount rule on "sale.order.line" validates each line item discount.'
    )
    company_id = fields.Many2one('res.company', string='Company', required=True,
                                default=lambda self: self.env.company)
    
    rule_type = fields.Selection([
        ('matrix_validation', 'Matrix Validation'),
        ('discount_limit', 'Discount Limit'),
        ('margin_protection', 'Margin Protection'),
        ('price_override', 'Price Override'),
        ('approval_workflow', 'Approval Workflow'),
        ('notification', 'Notification'),
        ('legacy', 'Legacy (Backward Compatibility)'),
    ], string='Rule Type',
       required=True,
       tracking=True,
       default='legacy',
       help='Category of governance control this rule enforces. '
            'Matrix Validation: Ensures branch/BU are selected and valid. '
            'Discount Limit: Controls maximum discounts by role/category. '
            'Margin Protection: Enforces minimum profit margins. '
            'Price Override: Limits price changes from list price. '
            'Approval Workflow: Routes transactions for approval. '
            'Notification: Sends alerts without blocking. '
            'Legacy: Custom rules using domain/code conditions. '
            'Each type has specific configuration fields that appear when selected.')
    
    # New unified trigger field
    trigger_event = fields.Selection([
        ('always', 'Always'),
        ('on_create', 'On Create'),
        ('on_write', 'On Write'),
        ('on_state_change', 'On State Change'),
    ], string='Trigger Event',
       default='always',
       tracking=True,
       help='When this rule should be evaluated. '
            'Always: Checks on every create and update operation. '
            'On Create: Only when record is first created. '
            'On Write: Only when record is modified (not on creation). '
            'On State Change: Only when status field changes (draftâ†’confirmed). '
            'Performance Tip: Use specific triggers instead of "Always" for better performance. '
            'Example: Discount validation on "On Write" since discounts can change after creation.')
    
    # New unified condition logic field - Changed to Char for domain widget
    condition_logic = fields.Char(
        string='Condition Logic',
        help='Optional filter to limit when this rule applies. Use the visual domain builder. '
             'Click "Add a filter" to build conditions without coding. '
             'Examples: '
             '- Apply only to orders > $10,000: [("amount_total", ">", 10000)] '
             '- Apply only to specific partner: [("partner_id", "=", 123)] '
             '- Apply to confirmed orders: [("state", "=", "sale")]. '
             'Leave empty to apply to all records of the selected model. '
             'Advanced: Supports Python domain syntax for complex conditions.'
    )
    
    # Computed field for domain widget anchor
    model_name = fields.Char(
        string='Model Name',
        related='model_id.model',
        store=True,
        readonly=True,
        help='Technical model name for domain widget'
    )
    
    # Legacy fields for backward compatibility
    trigger_condition = fields.Selection([
        ('always', 'Always'),
        ('on_create', 'On Create'),
        ('on_update', 'On Update'),
        ('on_state_change', 'On State Change'),
    ], string='Trigger Condition (Legacy)', default='always')
    
    state_condition = fields.Char(string='State Condition',
                                 help='Python expression for state evaluation. Example: state in ["draft", "sent"]')
    
    # --- MATRIX DIMENSION VALIDATION ---
    enforce_branch_bu = fields.Boolean(
        string='Enforce Branch/BU Selection',
        help='When enabled, validates that Branch and Business Unit are properly selected on transactions. '
             'Checks performed: '
             '- Branch field is filled (if "Branch Required" checked) '
             '- Business Unit field is filled (if "Business Unit Required" checked) '
             '- Selected BU operates in selected Branch (compatibility check). '
             'Use for: Ensuring matrix organization compliance, preventing unallocated transactions. '
             'Applies to: sale.order, purchase.order, account.move, stock.picking models. '
             'Related fields: "Allowed Branches", "Allowed Business Units" for additional restrictions.'
    )
    
    allowed_branch_ids = fields.Many2many('ops.branch', 'rule_branch_rel',
                                         string='Allowed Branches',
                                         help='Restrict to specific branches. Empty = all branches.')
    
    allowed_business_unit_ids = fields.Many2many('ops.business.unit', 'rule_bu_rel',
                                                string='Allowed Business Units',
                                                help='Restrict to specific BUs. Empty = all BUs.')
    
    branch_required = fields.Boolean(
        string='Branch Required',
        default=True,
        help='If enabled, transactions must have a branch selected. '
             'When to enable: Always (for matrix organizations). '
             'When to disable: For global/unallocated transactions, centralized purchasing. '
             'Validation: Blocks save if branch is empty. '
             'Default: Enabled (recommended for matrix compliance).'
    )
    bu_required = fields.Boolean(
        string='Business Unit Required',
        default=True,
        help='If enabled, transactions must have a business unit selected. '
             'When to enable: Always (for profit center tracking). '
             'When to disable: For corporate overhead, shared services, R&D. '
             'Validation: Blocks save if BU is empty. '
             'Default: Enabled (recommended for P&L tracking).'
    )
    
    # --- DISCOUNT CONTROL ---
    enforce_discount_limit = fields.Boolean(
        string='Enforce Discount Limit',
        help='When enabled, validates that discounts do not exceed authorized limits. '
             'How it works: '
             '1. System checks user\'s persona/role '
             '2. Looks up their discount authority (in Discount Limits section below) '
             '3. Compares transaction discount to their limit '
             '4. Blocks or requires approval if exceeded. '
             'Use for: Protecting margins, preventing unauthorized discounting. '
             'Configure: Add role-based limits in "Role-Based Discount Limits" tab. '
             'Related: Set "Global Discount Limit %" for default maximum.'
    )
    global_discount_limit = fields.Float(
        string='Global Discount Limit %',
        default=0.0,
        help='Default maximum discount percentage if no role-specific limit is defined. '
             'Applies to: All users who don\'t have a higher limit in Role-Based Discount Limits. '
             'Range: 0-100 (0 = no discounts allowed, 100 = any discount allowed). '
             'Examples: '
             '- Sales rep default = 5% '
             '- Manager can override up to 15% in discount limits '
             '- Executive can override up to 30% in discount limits. '
             'Leave at 0 if all users must have explicitly defined limits.'
    )
    
    discount_validation_level = fields.Selection([
        ('line', 'Per Line'),
        ('order', 'Per Order'),
        ('both', 'Both Line and Order'),
    ], string='Discount Validation Level', default='line')
    
    # --- MARGIN PROTECTION ---
    enforce_margin_protection = fields.Boolean(
        string='Enforce Margin Protection',
        help='When enabled, ensures profit margins meet minimum thresholds. '
             'How it works: '
             '1. Calculates margin: (Revenue - Cost) / Revenue Ã— 100 '
             '2. Compares to minimum margin rules (by product category, BU, branch) '
             '3. Blocks or requires approval if margin too low. '
             'Use for: Preventing unprofitable sales, protecting company margins. '
             'Configure: Set "Global Minimum Margin %" and add category-specific rules below. '
             'Calculation: Uses product standard cost vs. sale price.'
    )
    global_minimum_margin = fields.Float(
        string='Global Minimum Margin %',
        default=0.0,
        help='Default minimum profit margin percentage for all products. '
             'Applies unless category-specific rule exists (see Category-Specific Margin Rules). '
             'Range: 0-100 (e.g., 15.0 = 15% margin required). '
             'Examples: '
             '- Retail: 25% minimum '
             '- Wholesale: 10% minimum '
             '- Services: 40% minimum. '
             'Calculation: ((Sale Price - Cost) / Sale Price) Ã— 100 must be â‰¥ this value.'
    )
    warning_margin_threshold = fields.Float(string='Warning Margin Threshold %', default=5.0,
                                           help='Margin percentage that triggers warning')
    
    # --- PRICE OVERRIDE CONTROL ---
    enforce_price_override = fields.Boolean(string='Enforce Price Override Control')
    global_max_price_variance = fields.Float(string='Global Max Price Variance %', default=0.0)
    
    # --- APPROVAL CONFIGURATION ---
    require_approval = fields.Boolean(
        string='Require Approval',
        help='When enabled, violations trigger approval workflow instead of blocking. '
             'Behavior: '
             '- Unchecked: Violations block the transaction (hard stop) '
             '- Checked: Transaction allowed but approval request created. '
             'Use Cases: '
             '- Exceptions allowed with management approval '
             '- High-value transactions need review '
             '- Unusual discount requests. '
             'Workflow: System finds approvers based on branch/BU and routes request. '
             'Approvers: Configure in "Approval Users/Personas" or notification groups.'
    )
    approval_workflow_id = fields.Many2one('ops.approval.workflow', string='Approval Workflow')
    auto_create_approval = fields.Boolean(string='Auto-Create Approval Request', default=True)
    
    # --- NOTIFICATION ---
    notify_users = fields.Boolean(string='Notify Users')
    notify_template_id = fields.Many2one('mail.template', string='Notification Template')
    notify_groups = fields.Many2many('res.groups', string='Notify Groups')
    
    # --- RELATED RECORDS ---
    discount_limit_ids = fields.One2many('ops.governance.discount.limit', 'rule_id',
                                        string='Role-Based Discount Limits')
    
    margin_rule_ids = fields.One2many('ops.governance.margin.rule', 'rule_id',
                                     string='Category-Specific Margin Rules')
    
    price_authority_ids = fields.One2many('ops.governance.price.authority', 'rule_id',
                                         string='Role-Based Price Authority')
    
    # --- COMPUTED FIELDS ---
    violation_count = fields.Integer(string='Violation Count', compute='_compute_violation_count')
    active_approval_count = fields.Integer(string='Active Approvals', compute='_compute_approval_count')
    
    # --- LEGACY FIELDS (Backward Compatibility) ---
    trigger_type = fields.Selection(TRIGGER_TYPES, string='Trigger Event', default='on_write')
    condition_domain = fields.Text(string='Condition Domain')
    condition_code = fields.Text(string='Condition Code (Python)')
    action_type = fields.Selection(ACTION_TYPES, string='Action Type', default='warning')
    error_message = fields.Char(string='Error/Warning Message')
    approval_user_ids = fields.Many2many('res.users', 'rule_user_rel', string='Approval Users')
    approval_persona_ids = fields.Many2many('ops.persona', 'rule_approval_persona_rel',
                                           'rule_id', 'persona_id', string='Approval Personas')
    lock_on_approval_request = fields.Boolean(string='Lock During Approval', default=True)
    min_margin_percent = fields.Float(string='Minimum Margin %')
    max_discount_percent = fields.Float(string='Maximum Discount %')
    business_unit_id = fields.Many2one('ops.business.unit', string='Business Unit')
    
    # --- VALIDATION METHODS ---
    
    @api.constrains('allowed_branch_ids', 'company_id')
    def _check_branch_company(self):
        """Ensure allowed branches belong to rule's company."""
        for rule in self:
            invalid_branches = rule.allowed_branch_ids.filtered(
                lambda b: b.company_id != rule.company_id
            )
            if invalid_branches:
                raise ValidationError(
                    _("Branches %s do not belong to company %s") % (
                        ', '.join(invalid_branches.mapped('name')),
                        rule.company_id.name
                    )
                )
    
    @api.constrains('min_margin_percent', 'max_discount_percent')
    def _check_percentages(self):
        """Validate margin and discount percentages."""
        for record in self:
            if record.min_margin_percent and (record.min_margin_percent < 0 or record.min_margin_percent > 100):
                raise ValidationError(_('Minimum margin percentage must be between 0 and 100.'))
            if record.max_discount_percent and (record.max_discount_percent < 0 or record.max_discount_percent > 100):
                raise ValidationError(_('Maximum discount percentage must be between 0 and 100.'))
    
    # --- BUSINESS METHODS ---
    
    def validate_record(self, record, trigger_type='always'):
        """Validate record against this rule."""
        self.ensure_one()
        
        # ADMIN BYPASS: Skip validation for Administrator and System Managers
        if self.env.su or self.env.user.has_group('base.group_system'):
            return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
        
        # Check if rule applies to this trigger (use trigger_event if set, fallback to trigger_condition)
        active_trigger = self.trigger_event or self.trigger_condition
        if active_trigger != 'always' and active_trigger != trigger_type:
            return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
        
        # Evaluate new condition_logic field if specified
        if self.condition_logic:
            try:
                eval_context = {
                    'record': record,
                    'self': record,
                    'user': self.env.user,
                    'env': self.env,
                }
                # Add common fields to context
                for field in ['state', 'amount_total', 'amount_untaxed', 'partner_id', 'company_id']:
                    if hasattr(record, field):
                        eval_context[field] = getattr(record, field)
                
                condition_result = safe_eval(self.condition_logic, eval_context)
                if not condition_result:
                    return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
            except Exception as e:
                _logger.warning(f"Could not evaluate condition_logic for rule {self.name}: {e}")
                return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
        
        # Check legacy state condition if specified
        if self.state_condition:
            try:
                if not safe_eval(self.state_condition, {'record': record, 'state': record.state if hasattr(record, 'state') else None}):
                    return {'valid': True, 'warnings': [], 'errors': [], 'requires_approval': False}
            except Exception as e:
                _logger.warning(f"Could not evaluate state condition for rule {self.name}: {e}")
        
        errors = []
        warnings = []
        requires_approval = False
        
        # 1. MATRIX DIMENSION VALIDATION
        if self.enforce_branch_bu:
            matrix_result = self._validate_matrix_dimensions(record)
            errors.extend(matrix_result['errors'])
            warnings.extend(matrix_result['warnings'])
            requires_approval = requires_approval or matrix_result['requires_approval']
        
        # 2. DISCOUNT LIMIT VALIDATION
        if self.enforce_discount_limit:
            discount_result = self._validate_discount(record)
            errors.extend(discount_result['errors'])
            warnings.extend(discount_result['warnings'])
            requires_approval = requires_approval or discount_result['requires_approval']
        
        # 3. MARGIN PROTECTION VALIDATION
        if self.enforce_margin_protection:
            margin_result = self._validate_margin(record)
            errors.extend(margin_result['errors'])
            warnings.extend(margin_result['warnings'])
            requires_approval = requires_approval or margin_result['requires_approval']
        
        # 4. PRICE OVERRIDE VALIDATION
        if self.enforce_price_override:
            price_result = self._validate_price_override(record)
            errors.extend(price_result['errors'])
            warnings.extend(price_result['warnings'])
            requires_approval = requires_approval or price_result['requires_approval']
        
        # 5. LEGACY CONDITION VALIDATION
        if self.rule_type == 'legacy' and (self.condition_domain or self.condition_code):
            legacy_result = self._evaluate_legacy_condition(record)
            if not legacy_result:
                errors.extend([self.error_message or 'Legacy rule condition not met'])
        
        return {
            'valid': len(errors) == 0,
            'warnings': warnings,
            'errors': errors,
            'requires_approval': requires_approval,
        }
    
    def _validate_matrix_dimensions(self, record):
        """Validate matrix dimensions (Branch/BU)."""
        errors = []
        warnings = []
        requires_approval = False
        
        # Check if record has matrix fields
        has_branch = hasattr(record, 'ops_branch_id')
        has_bu = hasattr(record, 'ops_business_unit_id')
        
        # Branch validation
        if self.branch_required and has_branch:
            if not record.ops_branch_id:
                errors.append(_("Branch selection is required by governance rule '%s'") % self.name)
            elif self.allowed_branch_ids and record.ops_branch_id not in self.allowed_branch_ids:
                errors.append(
                    _("Branch '%s' is not allowed. Allowed branches: %s") % (
                        record.ops_branch_id.name,
                        ', '.join(self.allowed_branch_ids.mapped('name'))
                    )
                )
        
        # BU validation
        if self.bu_required and has_bu:
            if not record.ops_business_unit_id:
                errors.append(_("Business Unit selection is required by governance rule '%s'") % self.name)
            elif self.allowed_business_unit_ids and record.ops_business_unit_id not in self.allowed_business_unit_ids:
                errors.append(
                    _("Business Unit '%s' is not allowed. Allowed BUs: %s") % (
                        record.ops_business_unit_id.name,
                        ', '.join(self.allowed_business_unit_ids.mapped('name'))
                    )
                )
        
        # Cross-validation: Ensure BU operates in selected branch
        if has_branch and has_bu and record.ops_branch_id and record.ops_business_unit_id:
            if record.ops_branch_id not in record.ops_business_unit_id.branch_ids:
                errors.append(
                    _("Business Unit '%s' does not operate in branch '%s'") % (
                        record.ops_business_unit_id.name,
                        record.ops_branch_id.name
                    )
                )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _validate_discount(self, record):
        """Validate discount against limits."""
        errors = []
        warnings = []
        requires_approval = False
        
        # Get current user and their persona
        user = self.env.user
        user_personas = user.persona_ids if hasattr(user, 'persona_ids') else self.env['ops.persona']
        
        if record._name == 'sale.order.line':
            # Line-level discount validation
            discount = record.discount
            
            # Get user's discount limit from persona
            max_discount = self._get_user_discount_limit(user, user_personas, record)
            
            if discount > max_discount:
                # Check if approval is configured
                if self.require_approval:
                    requires_approval = True
                    warnings.append(
                        _("Discount %.2f%% exceeds your limit of %.2f%%. Approval will be requested.") % (
                            discount, max_discount
                        )
                    )
                else:
                    errors.append(
                        _("Discount %.2f%% exceeds maximum allowed %.2f%%.") % (discount, max_discount)
                    )
        
        elif record._name == 'sale.order':
            # Order-level discount validation
            if self.discount_validation_level in ['order', 'both']:
                order_discount = getattr(record, 'global_discount', 0.0) or 0.0
                max_discount = self._get_user_discount_limit(user, user_personas, record)
                
                if order_discount > max_discount:
                    if self.require_approval:
                        requires_approval = True
                        warnings.append(
                            _("Order discount %.2f%% exceeds your limit of %.2f%%. Approval will be requested.") % (
                                order_discount, max_discount
                            )
                        )
                    else:
                        errors.append(
                            _("Order discount %.2f%% exceeds maximum allowed %.2f%%.") % (order_discount, max_discount)
                        )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _validate_margin(self, record):
        """Validate margin against thresholds."""
        errors = []
        warnings = []
        requires_approval = False
        
        if record._name == 'sale.order.line':
            margin_percent = self._calculate_line_margin(record)
            min_margin = self._get_minimum_margin(
                record.product_id.categ_id,
                getattr(record, 'ops_business_unit_id', False),
                getattr(record, 'ops_branch_id', False)
            )
            
            if margin_percent < min_margin:
                if self.require_approval:
                    requires_approval = True
                    warnings.append(
                        _("Margin %.2f%% is below minimum %.2f%%. Approval will be requested.") % (
                            margin_percent, min_margin
                        )
                    )
                else:
                    errors.append(
                        _("Margin %.2f%% is below minimum required %.2f%%.") % (margin_percent, min_margin)
                    )
            elif margin_percent < (min_margin + self.warning_margin_threshold):
                warnings.append(
                    _("Margin %.2f%% is close to minimum threshold %.2f%%.") % (margin_percent, min_margin)
                )
        
        elif record._name == 'sale.order':
            # Calculate order-level margin
            order_margin = self._calculate_order_margin(record)
            # Use lowest margin requirement from order lines
            min_margins = [
                self._get_minimum_margin(
                    line.product_id.categ_id,
                    getattr(line, 'ops_business_unit_id', False),
                    getattr(line, 'ops_branch_id', False)
                )
                for line in record.order_line if line.product_id
            ]
            min_margin = min(min_margins) if min_margins else self.global_minimum_margin
            
            if order_margin < min_margin:
                if self.require_approval:
                    requires_approval = True
                    warnings.append(
                        _("Order margin %.2f%% is below minimum %.2f%%. Approval will be requested.") % (
                            order_margin, min_margin
                        )
                    )
                else:
                    errors.append(
                        _("Order margin %.2f%% is below minimum required %.2f%%.") % (order_margin, min_margin)
                    )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _validate_price_override(self, record):
        """Validate price override against authorized limits."""
        errors = []
        warnings = []
        requires_approval = False
        
        if record._name == 'sale.order.line':
            # Get product list price
            list_price = record.product_id.list_price
            current_price = record.price_unit
            
            if list_price > 0:
                variance_percent = abs((current_price - list_price) / list_price * 100)
                max_variance = self._get_user_price_variance_limit(self.env.user, record)
                
                if variance_percent > max_variance:
                    if self.require_approval:
                        requires_approval = True
                        warnings.append(
                            _("Price variance %.2f%% exceeds your limit of %.2f%%. Approval will be requested.") % (
                                variance_percent, max_variance
                            )
                        )
                    else:
                        errors.append(
                            _("Price variance %.2f%% exceeds maximum allowed %.2f%%.") % (variance_percent, max_variance)
                        )
        
        return {'errors': errors, 'warnings': warnings, 'requires_approval': requires_approval}
    
    def _evaluate_legacy_condition(self, record):
        """Evaluate legacy condition (backward compatibility)."""
        try:
            # Try domain first if available
            if self.condition_domain:
                domain = self._parse_domain_string(self.condition_domain)
                matches = record.filtered_domain(domain)
                if not matches:
                    return False
            
            # Try Python code if available
            if self.condition_code:
                safe_locals = {
                    'self': record,
                    'record': record,
                    'user': record.env.user,
                    'env': record.env,
                }
                result = safe_eval(self.condition_code, safe_locals)
                return bool(result)
            
            return True
        except Exception as e:
            _logger.error(f'Error evaluating legacy rule condition: {e}')
            return False
    
    def _parse_domain_string(self, domain_str):
        """Parse a domain string into a list."""
        try:
            import ast
            return ast.literal_eval(domain_str)
        except (ValueError, SyntaxError) as e:
            raise ValidationError(_('Invalid domain syntax: %s') % str(e))
    
    def _get_user_discount_limit(self, user, personas, record=None):
        """Get maximum discount percentage for user based on role/persona."""
        max_discount = self.global_discount_limit
        
        # Get context for scope restrictions
        branch_id = getattr(record, 'ops_branch_id', False)
        bu_id = getattr(record, 'ops_business_unit_id', False)
        category_id = False
        if record._name == 'sale.order.line' and hasattr(record, 'product_id'):
            category_id = record.product_id.categ_id.id
        
        # Check persona-based limits
        for persona in personas:
            limit_rules = self.discount_limit_ids.filtered(lambda r: r.persona_id == persona)
            for limit_rule in limit_rules:
                applicable_limit = limit_rule.get_applicable_limit(
                    user,
                    branch_id.id if branch_id else False,
                    bu_id.id if bu_id else False,
                    category_id
                )
                if applicable_limit > 0:
                    max_discount = max(max_discount, applicable_limit)
        
        # Check group-based limits
        for limit_rule in self.discount_limit_ids.filtered(lambda r: r.user_group_id):
            try:
                if user.has_group(limit_rule.user_group_id.xml_id or 'base.group_user'):
                    applicable_limit = limit_rule.get_applicable_limit(
                        user,
                        branch_id.id if branch_id else False,
                        bu_id.id if bu_id else False,
                        category_id
                    )
                    if applicable_limit > 0:
                        max_discount = max(max_discount, applicable_limit)
            except Exception:
                pass
        
        return max_discount
    
    def _calculate_line_margin(self, order_line):
        """Calculate margin percentage for a sale order line."""
        if order_line.price_subtotal == 0:
            return 0.0
        
        # Get product cost
        cost = order_line.product_id.standard_price * order_line.product_uom_qty
        revenue = order_line.price_subtotal
        margin = revenue - cost
        margin_percent = (margin / revenue) * 100 if revenue else 0.0
        
        return margin_percent
    
    def _calculate_order_margin(self, order):
        """Calculate margin percentage for entire order."""
        total_revenue = order.amount_untaxed
        if total_revenue == 0:
            return 0.0
        
        total_cost = sum(
            line.product_id.standard_price * line.product_uom_qty
            for line in order.order_line if line.product_id
        )
        total_margin = total_revenue - total_cost
        margin_percent = (total_margin / total_revenue) * 100
        
        return margin_percent
    
    def _get_minimum_margin(self, category, business_unit, branch):
        """Get minimum margin for product category, BU, and branch."""
        if not category:
            return self.global_minimum_margin
        
        # First try specific rule (category + BU + branch)
        if business_unit and branch:
            margin_rule = self.margin_rule_ids.filtered(
                lambda r: r.product_category_id == category and
                         r.business_unit_id == business_unit and
                         r.branch_id == branch
            )
            if margin_rule:
                return margin_rule[0].minimum_margin_percent
        
        # Try category + BU
        if business_unit:
            margin_rule = self.margin_rule_ids.filtered(
                lambda r: r.product_category_id == category and
                         r.business_unit_id == business_unit and
                         not r.branch_id
            )
            if margin_rule:
                return margin_rule[0].minimum_margin_percent
        
        # Try category + branch
        if branch:
            margin_rule = self.margin_rule_ids.filtered(
                lambda r: r.product_category_id == category and
                         not r.business_unit_id and
                         r.branch_id == branch
            )
            if margin_rule:
                return margin_rule[0].minimum_margin_percent
        
        # Try category only
        margin_rule = self.margin_rule_ids.filtered(
            lambda r: r.product_category_id == category and
                     not r.business_unit_id and
                     not r.branch_id
        )
        if margin_rule:
            return margin_rule[0].minimum_margin_percent
        
        # Fallback to global minimum
        return self.global_minimum_margin
    
    def _get_user_price_variance_limit(self, user, record=None):
        """Get user's price variance authority."""
        max_variance = self.global_max_price_variance
        personas = user.persona_ids if hasattr(user, 'persona_ids') else self.env['ops.persona']
        
        # Get context for scope restrictions
        branch_id = getattr(record, 'ops_branch_id', False)
        bu_id = getattr(record, 'ops_business_unit_id', False)
        category_id = False
        if record and record._name == 'sale.order.line' and hasattr(record, 'product_id'):
            category_id = record.product_id.categ_id.id
        
        # Check persona-based limits
        for persona in personas:
            auth_rules = self.price_authority_ids.filtered(lambda r: r.persona_id == persona)
            for auth_rule in auth_rules:
                authority = auth_rule.get_applicable_authority(
                    user,
                    branch_id.id if branch_id else False,
                    bu_id.id if bu_id else False,
                    category_id
                )
                if authority['max_variance'] > 0:
                    max_variance = max(max_variance, authority['max_variance'])
        
        return max_variance
    
    def action_create_approval_request(self, record, violation_type, violation_details):
        """Create approval request for governance violation."""
        self.ensure_one()
        
        if not self.require_approval:
            return False
        
        # Find approvers based on matrix dimensions
        approvers = self._find_approvers(record, violation_type)
        
        if not approvers:
            _logger.warning(f"No approvers found for rule {self.name}")
            return False
        
        # Create approval request
        approval = self.env['ops.approval.request'].create({
            'name': _("Governance Approval: %s - %s") % (violation_type, record.name or record._name),
            'rule_id': self.id,
            'model_name': record._name,
            'res_id': record.id,
            'notes': violation_details,
            'approver_ids': [(6, 0, approvers.ids)],
            'requested_by': self.env.user.id,
        })
        
        # Send notifications
        if self.notify_users:
            try:
                approval.message_post(
                    body=_("Governance approval requested: %s") % violation_details,
                    partner_ids=approvers.mapped('partner_id').ids,
                )
            except Exception as e:
                _logger.warning(f"Could not send notification: {e}")
        
        return approval
    
    def _find_approvers(self, record, violation_type):
        """Find approvers based on matrix dimensions and violation type."""
        approvers = self.env['res.users']
        
        # Get personas that can approve for this branch/BU
        Persona = self.env['ops.persona']
        domain = [
            ('company_id', '=', record.company_id.id if hasattr(record, 'company_id') else self.env.company.id),
            ('active', '=', True),
        ]
        
        # Add matrix dimension filters
        if hasattr(record, 'ops_branch_id') and record.ops_branch_id:
            domain.append(('branch_ids', 'in', record.ops_branch_id.id))
        
        if hasattr(record, 'ops_business_unit_id') and record.ops_business_unit_id:
            domain.append(('business_unit_ids', 'in', record.ops_business_unit_id.id))
        
        # Add approval authority filters based on violation type
        if violation_type == 'discount':
            domain.append(('can_approve_discounts', '=', True))
        elif violation_type == 'margin':
            domain.append(('can_approve_margin_exceptions', '=', True))
        elif violation_type == 'price':
            domain.append(('can_approve_price_overrides', '=', True))
        elif violation_type == 'matrix':
            domain.append(('can_approve_matrix_exceptions', '=', True))
        
        # Get personas and extract users
        try:
            personas = Persona.search(domain)
            approvers |= personas.mapped('user_id')
        except Exception as e:
            _logger.warning(f"Error finding persona approvers: {e}")
        
        # Also check group-based approvers
        if self.notify_groups:
            group_users = self.env['res.users'].search([
                ('groups_id', 'in', self.notify_groups.ids),
                ('company_id', 'in', [self.company_id.id, False]),
            ])
            approvers |= group_users
        
        # Fallback to approval_user_ids if no approvers found
        if not approvers and self.approval_user_ids:
            approvers = self.approval_user_ids
        
        return approvers
    
    # --- LEGACY METHODS (Backward Compatibility) ---
    
    def _trigger_approval_if_needed(self, record):
        """Check if record matches this rule and trigger approval workflow if needed."""
        self.ensure_one()
        
        # Only process if rule is active
        if not self.active:
            return False
        
        # For new rule types, use validate_record
        if self.rule_type != 'legacy':
            result = self.validate_record(record)
            if not result['valid'] or result['requires_approval']:
                violation_details = '\n'.join(result['errors'] + result['warnings'])
                return self.action_create_approval_request(record, self.rule_type, violation_details)
            return False
        
        # Legacy logic
        if not self._evaluate_legacy_condition(record):
            return False
        
        # Action: Warning (log and continue)
        if self.action_type == 'warning':
            try:
                record.message_post(
                    body=_('<strong>Governance Alert:</strong> %s') % self.error_message,
                    message_type='notification'
                )
            except Exception:
                pass
            return False
        
        # Action: Block (prevent operation)
        if self.action_type == 'block':
            raise ValidationError(_('Governance Rule Blocked: %s') % self.error_message)
        
        # Action: Require Approval
        if self.action_type == 'require_approval':
            approvers = self.approval_user_ids | self.env['res.users'].search([
                ('persona_ids', 'in', self.approval_persona_ids.ids)
            ])
            
            try:
                approval = self.env['ops.approval.request'].create({
                    'name': _('Approval Required: %s') % self.name,
                    'rule_id': self.id,
                    'model_name': record._name,
                    'res_id': record.id,
                    'notes': self.error_message,
                    'approver_ids': [(6, 0, approvers.ids)],
                })
                
                # Lock record if configured
                if self.lock_on_approval_request and hasattr(record, 'active'):
                    try:
                        record.write({'active': False})
                    except Exception:
                        pass
                
                return True
            except Exception as e:
                _logger.error(f"Error creating approval request: {e}")
                return False
        
        return False
    
    @api.model
    def evaluate_rules_for_record(self, record, trigger_type='on_write'):
        """Evaluate all applicable rules for a record."""
        # ADMIN BYPASS: Skip all rule evaluation for Administrator and System Managers
        if self.env.su or self.env.user.has_group('base.group_system'):
            return
        
        rules = self.search([
            ('active', '=', True),
            ('model_id.model', '=', record._name),
            '|',
            ('trigger_type', '=', trigger_type),
            ('trigger_condition', '=', 'always')
        ], order='sequence ASC')
        
        for rule in rules:
            rule._trigger_approval_if_needed(record)
    
    # --- COMPUTED METHODS ---
    
    @api.depends('rule_type', 'enforce_branch_bu', 'enforce_discount_limit', 
                 'enforce_margin_protection', 'enforce_price_override')
    def _compute_description(self):
        """Generate rule description based on configuration."""
        for rule in self:
            parts = []
            
            if rule.enforce_branch_bu:
                parts.append(_("Enforces Branch/BU selection"))
            
            if rule.enforce_discount_limit:
                parts.append(_("Discount limit: %.2f%%") % rule.global_discount_limit)
            
            if rule.enforce_margin_protection:
                parts.append(_("Minimum margin: %.2f%%") % rule.global_minimum_margin)
            
            if rule.enforce_price_override:
                parts.append(_("Max price variance: %.2f%%") % rule.global_max_price_variance)
            
            if rule.require_approval:
                parts.append(_("Requires approval"))
            
            rule.description = " | ".join(parts) if parts else _("No validations configured")
    
    def _compute_violation_count(self):
        """Count violations for this rule."""
        for rule in self:
            rule.violation_count = self.env['ops.approval.request'].search_count([
                ('rule_id', '=', rule.id),
                ('state', 'in', ['pending', 'approved', 'rejected']),
            ])
    
    def _compute_approval_count(self):
        """Count active approval requests."""
        for rule in self:
            rule.active_approval_count = self.env['ops.approval.request'].search_count([
                ('rule_id', '=', rule.id),
                ('state', '=', 'pending'),
            ])
    
    def action_check_compliance(self):
        """Manual compliance check action - shows statistics for this rule."""
        self.ensure_one()
        
        # Refresh computed fields
        self._compute_violation_count()
        self._compute_approval_count()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Compliance Check'),
                'message': _(
                    'Rule: %s\n'
                    'Active: %s\n'
                    'Total Violations: %d\n'
                    'Pending Approvals: %d'
                ) % (
                    self.name,
                    _('Yes') if self.active else _('No'),
                    self.violation_count,
                    self.active_approval_count
                ),
                'type': 'info',
                'sticky': False,
            }
        }
    
    @api.model_create_multi
    def create(self, vals_list):
        """Generate code if not provided."""
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.governance.rule') or 'GR0001'
        return super().create(vals_list)

--- ops_matrix_core/models/ops_inter_branch_transfer.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError

class OpsInterBranchTransfer(models.Model):
    _name = 'ops.inter.branch.transfer'
    _description = 'Inter-Branch Transfer'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'create_date desc, id desc'
    _rec_name = 'reference'

    # =========================================================================
    # Fields
    # =========================================================================
    
    reference = fields.Char(
        string='Reference',
        required=True,
        copy=False,
        readonly=True,
        default=lambda self: _('New'),
        tracking=True
    )
    
    source_branch_id = fields.Many2one(
        'ops.branch',
        string='Source Branch',
        required=True,
        tracking=True,
        help="Branch sending the items"
    )
    
    dest_branch_id = fields.Many2one(
        'ops.branch',
        string='Destination Branch',
        required=True,
        tracking=True,
        help="Branch receiving the items"
    )
    
    source_warehouse_id = fields.Many2one(
        'stock.warehouse',
        string='Source Warehouse',
        required=True,
        tracking=True,
        domain="[('ops_branch_id', '=', source_branch_id)]",
        help="Warehouse in source branch where items will be picked"
    )
    
    dest_warehouse_id = fields.Many2one(
        'stock.warehouse',
        string='Destination Warehouse',
        required=True,
        tracking=True,
        domain="[('ops_branch_id', '=', dest_branch_id)]",
        help="Warehouse in destination branch where items will be received"
    )
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        related='source_branch_id.company_id',
        store=True,
        readonly=True,
        help='Company of the source branch'
    )
    
    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirmed', 'Confirmed'),
        ('in_transit', 'In Transit'),
        ('received', 'Received'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', required=True, tracking=True, copy=False)
    
    transfer_date = fields.Date(
        string='Transfer Date',
        required=True,
        default=fields.Date.context_today,
        tracking=True
    )
    
    expected_arrival_date = fields.Date(
        string='Expected Arrival',
        tracking=True
    )
    
    actual_arrival_date = fields.Date(
        string='Actual Arrival',
        readonly=True,
        tracking=True
    )
    
    user_id = fields.Many2one(
        'res.users',
        string='Responsible',
        default=lambda self: self.env.user,
        required=True,
        tracking=True
    )
    
    notes = fields.Text(
        string='Notes'
    )
    
    active = fields.Boolean(
        default=True
    )
    
    # Computed fields for UI
    can_confirm = fields.Boolean(
        compute='_compute_can_actions',
        string='Can Confirm'
    )
    
    can_receive = fields.Boolean(
        compute='_compute_can_actions',
        string='Can Receive'
    )
    
    can_cancel = fields.Boolean(
        compute='_compute_can_actions',
        string='Can Cancel'
    )

    # =========================================================================
    # Computed Methods
    # =========================================================================
    
    @api.depends('state', 'source_branch_id', 'dest_branch_id')
    def _compute_can_actions(self):
        """Compute what actions the current user can perform."""
        for record in self:
            user = self.env.user
            
            # Get user's allowed branches
            user_branches = self.env['ops.branch']
            if hasattr(user, 'ops_allowed_branch_ids'):
                user_branches = user.ops_allowed_branch_ids
            elif hasattr(user, 'get_effective_matrix_access'):
                access = user.get_effective_matrix_access()
                user_branches = access.get('branches', self.env['ops.branch'])
            
            # Admin bypass
            is_admin = user.has_group('base.group_system')
            
            # Can confirm if draft and user has access to source branch
            record.can_confirm = (
                record.state == 'draft' and
                (is_admin or record.source_branch_id in user_branches)
            )
            
            # Can receive if in_transit and user has access to destination branch
            record.can_receive = (
                record.state == 'in_transit' and
                (is_admin or record.dest_branch_id in user_branches)
            )
            
            # Can cancel if not yet received or already cancelled
            record.can_cancel = record.state not in ('received', 'cancelled')

    # =========================================================================
    # Constraints
    # =========================================================================
    
    @api.constrains('source_branch_id', 'dest_branch_id')
    def _check_different_branches(self):
        """Ensure source and destination are different."""
        for record in self:
            if record.source_branch_id == record.dest_branch_id:
                raise ValidationError(_(
                    "Source and destination branches must be different."
                ))
    
    @api.constrains('transfer_date', 'expected_arrival_date')
    def _check_dates(self):
        """Validate date logic."""
        for record in self:
            if record.expected_arrival_date and record.transfer_date:
                if record.expected_arrival_date < record.transfer_date:
                    raise ValidationError(_(
                        "Expected arrival date cannot be before transfer date."
                    ))
    
    @api.constrains('source_warehouse_id', 'source_branch_id')
    def _check_source_warehouse_branch(self):
        """Ensure source warehouse belongs to source branch."""
        for record in self:
            if record.source_warehouse_id and record.source_branch_id:
                # Check if warehouse has ops_branch_id field
                if hasattr(record.source_warehouse_id, 'ops_branch_id'):
                    if record.source_warehouse_id.ops_branch_id != record.source_branch_id:
                        raise ValidationError(_(
                            "Source warehouse '%s' does not belong to source branch '%s'."
                        ) % (
                            record.source_warehouse_id.name,
                            record.source_branch_id.name
                        ))
    
    @api.constrains('dest_warehouse_id', 'dest_branch_id')
    def _check_dest_warehouse_branch(self):
        """Ensure destination warehouse belongs to destination branch."""
        for record in self:
            if record.dest_warehouse_id and record.dest_branch_id:
                # Check if warehouse has ops_branch_id field
                if hasattr(record.dest_warehouse_id, 'ops_branch_id'):
                    if record.dest_warehouse_id.ops_branch_id != record.dest_branch_id:
                        raise ValidationError(_(
                            "Destination warehouse '%s' does not belong to destination branch '%s'."
                        ) % (
                            record.dest_warehouse_id.name,
                            record.dest_branch_id.name
                        ))

    # =========================================================================
    # CRUD Methods
    # =========================================================================
    
    @api.model_create_multi
    def create(self, vals_list):
        """Generate sequence for reference on create."""
        for vals in vals_list:
            if vals.get('reference', _('New')) == _('New'):
                vals['reference'] = self.env['ir.sequence'].next_by_code(
                    'ops.inter.branch.transfer'
                ) or _('New')
        
        records = super().create(vals_list)
        
        # Log creation
        for record in records:
            record.message_post(
                body=_('Inter-branch transfer created from %s to %s') % (
                    record.source_branch_id.name,
                    record.dest_branch_id.name
                )
            )
        
        return records
    
    def write(self, vals):
        """Track state changes."""
        # Track state changes
        if 'state' in vals:
            for record in self:
                old_state = record.state
                new_state = vals['state']
                if old_state != new_state:
                    record.message_post(
                        body=_('Status changed from %s to %s') % (
                            dict(self._fields['state'].selection).get(old_state),
                            dict(self._fields['state'].selection).get(new_state)
                        )
                    )
        
        return super().write(vals)

    # =========================================================================
    # Action Methods
    # =========================================================================
    
    def action_confirm(self):
        """Confirm the transfer - moves to 'confirmed' state."""
        self.ensure_one()
        
        if self.state != 'draft':
            raise UserError(_("Only draft transfers can be confirmed."))
        
        # Check user has access to source branch
        user = self.env.user
        if not user.has_group('base.group_system'):
            # Get user's allowed branches
            user_branches = self.env['ops.branch']
            if hasattr(user, 'ops_allowed_branch_ids'):
                user_branches = user.ops_allowed_branch_ids
            elif hasattr(user, 'get_effective_matrix_access'):
                access = user.get_effective_matrix_access()
                user_branches = access.get('branches', self.env['ops.branch'])
            
            if self.source_branch_id not in user_branches:
                raise UserError(_(
                    "You don't have permission to confirm transfers from %s"
                ) % self.source_branch_id.name)
        
        self.write({'state': 'confirmed'})
        
        self.message_post(
            body=_('Transfer confirmed by %s') % user.name,
            subject=_('Transfer Confirmed')
        )
        
        return True
    
    def action_send(self):
        """Mark as in transit."""
        self.ensure_one()
        
        if self.state not in ('draft', 'confirmed'):
            raise UserError(_("Only draft or confirmed transfers can be sent."))
        
        self.write({'state': 'in_transit'})
        
        self.message_post(
            body=_('Transfer marked as in transit'),
            subject=_('In Transit')
        )
        
        return True
    
    def action_receive(self):
        """Receive the transfer at destination."""
        self.ensure_one()
        
        if self.state != 'in_transit':
            raise UserError(_("Only in-transit transfers can be received."))
        
        # Check user has access to destination branch
        user = self.env.user
        if not user.has_group('base.group_system'):
            # Get user's allowed branches
            user_branches = self.env['ops.branch']
            if hasattr(user, 'ops_allowed_branch_ids'):
                user_branches = user.ops_allowed_branch_ids
            elif hasattr(user, 'get_effective_matrix_access'):
                access = user.get_effective_matrix_access()
                user_branches = access.get('branches', self.env['ops.branch'])
            
            if self.dest_branch_id not in user_branches:
                raise UserError(_(
                    "You don't have permission to receive transfers at %s"
                ) % self.dest_branch_id.name)
        
        self.write({
            'state': 'received',
            'actual_arrival_date': fields.Date.context_today(self)
        })
        
        self.message_post(
            body=_('Transfer received by %s') % user.name,
            subject=_('Transfer Received')
        )
        
        return True
    
    def action_cancel(self):
        """Cancel the transfer."""
        self.ensure_one()
        
        if self.state == 'received':
            raise UserError(_("Cannot cancel a received transfer."))
        
        if self.state == 'cancelled':
            raise UserError(_("Transfer is already cancelled."))
        
        self.write({'state': 'cancelled'})
        
        self.message_post(
            body=_('Transfer cancelled'),
            subject=_('Transfer Cancelled')
        )
        
        return True
    
    def action_set_to_draft(self):
        """Reset to draft (for corrections)."""
        self.ensure_one()
        
        if self.state == 'received':
            raise UserError(_("Cannot reset a received transfer to draft."))
        
        self.write({'state': 'draft'})
        
        self.message_post(
            body=_('Transfer reset to draft'),
            subject=_('Reset to Draft')
        )
        
        return True

    # =========================================================================
    # Business Methods
    # =========================================================================
    
    def name_get(self):
        """Custom display name."""
        result = []
        for record in self:
            name = '%s: %s â†’ %s' % (
                record.reference,
                record.source_branch_id.name,
                record.dest_branch_id.name
            )
            result.append((record.id, name))
        return result
    
    @api.model
    def get_transfers_for_branch(self, branch_id, direction='both'):
        """
        Get all transfers for a specific branch.
        
        :param branch_id: ID of the branch
        :param direction: 'outgoing', 'incoming', or 'both'
        :return: recordset of transfers
        """
        domain = []
        
        if direction == 'outgoing':
            domain = [('source_branch_id', '=', branch_id)]
        elif direction == 'incoming':
            domain = [('dest_branch_id', '=', branch_id)]
        else:  # both
            domain = ['|',
                     ('source_branch_id', '=', branch_id),
                     ('dest_branch_id', '=', branch_id)]
        
        return self.search(domain)

--- ops_matrix_core/models/ops_matrix_config.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError

class OpsMatrixConfig(models.Model):
    """
    OPS Matrix Framework Configuration
    
    Centralized configuration for the matrix framework, including
    analytic distribution weights, default behaviors, and system-wide settings.
    """
    _name = 'ops.matrix.config'
    _description = 'OPS Matrix Configuration'
    _rec_name = 'company_id'
    
    # =========================================================================
    # Basic Fields
    # =========================================================================
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company,
        help='Company this configuration applies to'
    )
    
    active = fields.Boolean(
        default=True,
        help='Set to False to disable this configuration'
    )
    
    # =========================================================================
    # Analytic Distribution Configuration
    # =========================================================================
    branch_weight = fields.Float(
        string='Branch Analytic Weight (%)',
        default=50.0,
        help='Percentage of analytic distribution allocated to Branch dimension (0-100)'
    )
    
    business_unit_weight = fields.Float(
        string='Business Unit Analytic Weight (%)',
        default=50.0,
        help='Percentage of analytic distribution allocated to Business Unit dimension (0-100)'
    )
    
    enforce_balanced_distribution = fields.Boolean(
        string='Enforce Balanced Distribution',
        default=True,
        help='If enabled, Branch + BU weights must equal 100%'
    )
    
    allow_single_dimension = fields.Boolean(
        string='Allow Single Dimension',
        default=True,
        help='Allow transactions with only Branch OR BU (not both)'
    )
    
    single_dimension_weight = fields.Float(
        string='Single Dimension Weight (%)',
        default=100.0,
        help='Weight to assign when only one dimension is present'
    )
    
    # =========================================================================
    # Matrix Behavior Configuration
    # =========================================================================
    require_branch_on_transactions = fields.Boolean(
        string='Require Branch on Transactions',
        default=True,
        help='Make Branch field required on sale orders, invoices, etc.'
    )
    
    require_bu_on_transactions = fields.Boolean(
        string='Require BU on Transactions',
        default=True,
        help='Make Business Unit field required on sale orders, invoices, etc.'
    )
    
    auto_propagate_dimensions = fields.Boolean(
        string='Auto-propagate Dimensions',
        default=True,
        help='Automatically copy Branch/BU from source document to related records'
    )
    
    validate_bu_branch_compatibility = fields.Boolean(
        string='Validate BU-Branch Compatibility',
        default=True,
        help='Ensure selected BU operates in selected Branch'
    )
    
    # =========================================================================
    # Reporting Configuration
    # =========================================================================
    default_reporting_dimension = fields.Selection([
        ('branch', 'Branch'),
        ('business_unit', 'Business Unit'),
        ('matrix', 'Matrix (Branch Ã— BU)'),
    ], string='Default Reporting Dimension',
       default='matrix',
       help='Default dimension for reports and dashboards')
    
    enable_cross_branch_bu_access = fields.Boolean(
        string='Enable Cross-Branch BU Access',
        default=True,
        help='Allow BU leaders to see their BU data across all branches'
    )
    
    # =========================================================================
    # Industry Template
    # =========================================================================
    industry_template = fields.Selection([
        ('retail', 'Retail & Distribution'),
        ('manufacturing', 'Manufacturing'),
        ('services', 'Professional Services'),
        ('hospitality', 'Hospitality & F&B'),
        ('healthcare', 'Healthcare'),
        ('construction', 'Construction & Real Estate'),
        ('custom', 'Custom Configuration'),
    ], string='Industry Template',
       help='Pre-configured settings for specific industries')
    
    # =========================================================================
    # Constraints
    # =========================================================================
    @api.constrains('branch_weight', 'business_unit_weight', 'enforce_balanced_distribution')
    def _check_analytic_weights(self):
        """Validate analytic weight distribution."""
        for config in self:
            # Check valid range
            if not (0 <= config.branch_weight <= 100):
                raise ValidationError(_(
                    'Branch weight must be between 0 and 100. Current value: %.2f'
                ) % config.branch_weight)
            
            if not (0 <= config.business_unit_weight <= 100):
                raise ValidationError(_(
                    'Business Unit weight must be between 0 and 100. Current value: %.2f'
                ) % config.business_unit_weight)
            
            # Check balanced distribution if enforced
            if config.enforce_balanced_distribution:
                total = config.branch_weight + config.business_unit_weight
                if abs(total - 100.0) > 0.01:  # Allow tiny floating point errors
                    raise ValidationError(_(
                        'Branch weight (%.2f%%) + Business Unit weight (%.2f%%) must equal 100%%. '
                        'Current total: %.2f%%'
                    ) % (config.branch_weight, config.business_unit_weight, total))
    
    @api.constrains('single_dimension_weight')
    def _check_single_dimension_weight(self):
        """Validate single dimension weight."""
        for config in self:
            if not (0 <= config.single_dimension_weight <= 100):
                raise ValidationError(_(
                    'Single dimension weight must be between 0 and 100. Current value: %.2f'
                ) % config.single_dimension_weight)
    
    _sql_constraints = [
        ('company_unique', 'UNIQUE(company_id)',
         'Only one configuration record per company is allowed!')
    ]
    
    # =========================================================================
    # Helper Methods
    # =========================================================================
    @api.model
    def get_config(self, company_id=None):
        """
        Get configuration for the specified company (or current company).
        Creates default configuration if none exists.
        
        :param company_id: ID of the company (optional)
        :return: ops.matrix.config record
        """
        if not company_id:
            company_id = self.env.company.id
        
        config = self.search([('company_id', '=', company_id)], limit=1)
        
        if not config:
            config = self.create({
                'company_id': company_id,
                'branch_weight': 50.0,
                'business_unit_weight': 50.0,
            })
        
        return config
    
    def get_analytic_distribution(self, branch_id=None, bu_id=None):
        """
        Calculate analytic distribution based on configuration.
        
        :param branch_id: Branch analytic account ID
        :param bu_id: Business Unit analytic account ID
        :return: Dictionary {analytic_account_id: weight}
        """
        self.ensure_one()
        distribution = {}
        
        # Both dimensions present
        if branch_id and bu_id:
            if self.branch_weight > 0:
                distribution[str(branch_id)] = self.branch_weight
            if self.business_unit_weight > 0:
                distribution[str(bu_id)] = self.business_unit_weight
        
        # Only branch
        elif branch_id and self.allow_single_dimension:
            distribution[str(branch_id)] = self.single_dimension_weight
        
        # Only BU
        elif bu_id and self.allow_single_dimension:
            distribution[str(bu_id)] = self.single_dimension_weight
        
        return distribution if distribution else False
    
    # =========================================================================
    # Industry Template Application
    # =========================================================================
    def apply_industry_template(self):
        """Apply industry-specific configuration settings."""
        self.ensure_one()
        
        templates = {
            'retail': {
                'branch_weight': 60.0,
                'business_unit_weight': 40.0,
                'require_branch_on_transactions': True,
                'require_bu_on_transactions': True,
                'default_reporting_dimension': 'branch',
            },
            'manufacturing': {
                'branch_weight': 40.0,
                'business_unit_weight': 60.0,
                'require_branch_on_transactions': True,
                'require_bu_on_transactions': True,
                'default_reporting_dimension': 'business_unit',
            },
            'services': {
                'branch_weight': 50.0,
                'business_unit_weight': 50.0,
                'require_branch_on_transactions': True,
                'require_bu_on_transactions': True,
                'default_reporting_dimension': 'matrix',
            },
            'hospitality': {
                'branch_weight': 70.0,
                'business_unit_weight': 30.0,
                'require_branch_on_transactions': True,
                'require_bu_on_transactions': False,
                'default_reporting_dimension': 'branch',
            },
            'healthcare': {
                'branch_weight': 50.0,
                'business_unit_weight': 50.0,
                'require_branch_on_transactions': True,
                'require_bu_on_transactions': True,
                'default_reporting_dimension': 'matrix',
            },
            'construction': {
                'branch_weight': 30.0,
                'business_unit_weight': 70.0,
                'require_branch_on_transactions': True,
                'require_bu_on_transactions': True,
                'default_reporting_dimension': 'business_unit',
            },
        }
        
        if self.industry_template and self.industry_template in templates:
            template_values = templates[self.industry_template]
            self.write(template_values)
            
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _('Template Applied'),
                    'message': _('Industry template "%s" has been applied successfully.') % 
                              dict(self._fields['industry_template'].selection).get(self.industry_template),
                    'type': 'success',
                    'sticky': False,
                }
            }
    
    # =========================================================================
    # Action Methods
    # =========================================================================
    def action_reset_to_defaults(self):
        """Reset configuration to default values."""
        self.ensure_one()
        self.write({
            'branch_weight': 50.0,
            'business_unit_weight': 50.0,
            'enforce_balanced_distribution': True,
            'allow_single_dimension': True,
            'single_dimension_weight': 100.0,
            'require_branch_on_transactions': True,
            'require_bu_on_transactions': True,
            'auto_propagate_dimensions': True,
            'validate_bu_branch_compatibility': True,
            'default_reporting_dimension': 'matrix',
            'enable_cross_branch_bu_access': True,
        })
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Configuration Reset'),
                'message': _('Configuration has been reset to default values.'),
                'type': 'info',
                'sticky': False,
            }
        }

--- ops_matrix_core/models/ops_matrix_mixin.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api

class OpsMatrixMixin(models.AbstractModel):
    """
    OPS Matrix Dimension Propagation Mixin
    
    This mixin provides matrix dimension tracking (Branch + Business Unit) for all transaction models.
    It automatically:
    - Tracks which branch and business unit a transaction belongs to
    - Computes the legal entity (company) from the branch
    - Generates analytic distribution for dual-dimension reporting
    - Provides default values from user's persona
    - Propagates dimensions to related records
    
    Usage:
        class SaleOrder(models.Model):
            _inherit = ['sale.order', 'ops.matrix.mixin']
            _name = 'sale.order'
    """
    _name = 'ops.matrix.mixin'
    _description = 'OPS Matrix Dimension Propagation Mixin'

    # =========================================================================
    # Matrix Dimension Fields
    # =========================================================================
    
    ops_company_id = fields.Many2one(
        'res.company',
        string='Legal Entity',
        compute='_compute_ops_company',
        store=True,
        help="Legal entity computed from branch"
    )
    
    ops_branch_id = fields.Many2one(
        'ops.branch',
        string='Branch',
        required=False,  # Made optional for compatibility
        tracking=True,
        default=lambda self: self._get_default_ops_branch(),
        help="Operational branch where this transaction occurs"
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,  # Made optional for compatibility
        tracking=True,
        default=lambda self: self._get_default_ops_business_unit(),
        help="Business unit responsible for this transaction"
    )
    
    # Analytic Distribution (Odoo 19 format - JSON field)
    ops_analytic_distribution = fields.Json(
        string='Matrix Analytic Distribution',
        compute='_compute_analytic_distribution',
        store=True,
        help="Analytic distribution for dual-dimension tracking (Branch + BU)"
    )

    # =========================================================================
    # Computed Methods
    # =========================================================================
    
    @api.depends('ops_branch_id')
    def _compute_ops_company(self):
        """
        Compute the legal entity (company) from the selected branch.
        """
        for record in self:
            if record.ops_branch_id:
                record.ops_company_id = record.ops_branch_id.company_id
            else:
                record.ops_company_id = False
    
    @api.depends('ops_branch_id', 'ops_business_unit_id')
    def _compute_analytic_distribution(self):
        """
        Compute analytic distribution for dual-dimension tracking using configurable weights.
        
        Format for Odoo 19: {'analytic_account_id': percentage}
        Example: {'123': 60, '456': 40} means 60% to Branch analytic account,
                                              40% to BU analytic account
        
        Weights are retrieved from ops.matrix.config for flexibility.
        """
        # Get configuration for weight calculation
        config = self.env['ops.matrix.config'].get_config()
        
        for record in self:
            # Get analytic account IDs
            branch_analytic_id = None
            bu_analytic_id = None
            
            # Extract branch analytic account
            if record.ops_branch_id:
                if hasattr(record.ops_branch_id, 'ops_analytic_account_id') and record.ops_branch_id.ops_analytic_account_id:
                    branch_analytic_id = record.ops_branch_id.ops_analytic_account_id.id
                elif hasattr(record.ops_branch_id, 'analytic_account_id') and record.ops_branch_id.analytic_account_id:
                    branch_analytic_id = record.ops_branch_id.analytic_account_id.id
            
            # Extract BU analytic account
            if record.ops_business_unit_id and record.ops_business_unit_id.analytic_account_id:
                bu_analytic_id = record.ops_business_unit_id.analytic_account_id.id
            
            # Use config to calculate distribution
            distribution = config.get_analytic_distribution(
                branch_id=branch_analytic_id,
                bu_id=bu_analytic_id
            )
            
            record.ops_analytic_distribution = distribution

    # =========================================================================
    # Default Value Methods
    # =========================================================================
    
    def _get_default_ops_branch(self):
        """
        Get default branch from user's persona or company.
        
        Priority:
        1. User's persona default branch
        2. User's default branch (if field exists)
        3. First branch of user's current company
        4. User's current company (fallback)
        """
        user = self.env.user
        
        # Try to get from persona
        if hasattr(user, 'persona_id') and user.persona_id:
            if hasattr(user.persona_id, 'default_branch_id') and user.persona_id.default_branch_id:
                return user.persona_id.default_branch_id.id
        
        # Try to get from user's default branch
        if hasattr(user, 'default_branch_id') and user.default_branch_id:
            return user.default_branch_id.id
        
        # Fallback: Try to get first branch of user's company
        # When ops.branch is implemented:
        # branch = self.env['ops.branch'].search([('company_id', '=', user.company_id.id)], limit=1)
        # For now, return current company
        return user.company_id.id if user.company_id else False
    
    def _get_default_ops_business_unit(self):
        """
        Get default business unit from user's persona.
        
        Priority:
        1. User's persona default business unit
        2. User's default business unit (if field exists)
        3. False (no default)
        """
        user = self.env.user
        
        # Try to get from persona
        if hasattr(user, 'persona_id') and user.persona_id:
            if hasattr(user.persona_id, 'default_business_unit_id') and user.persona_id.default_business_unit_id:
                return user.persona_id.default_business_unit_id.id
        
        # Try to get from user's default BU
        if hasattr(user, 'default_business_unit_id') and user.default_business_unit_id:
            return user.default_business_unit_id.id
        
        return False

    # =========================================================================
    # Propagation Helper Methods
    # =========================================================================
    
    def _propagate_matrix_to_lines(self, line_field='order_line'):
        """
        Propagate matrix dimensions to related line items.
        
        Args:
            line_field: Name of the One2many field containing lines (default: 'order_line')
        
        Usage:
            order._propagate_matrix_to_lines('order_line')
            invoice._propagate_matrix_to_lines('invoice_line_ids')
        """
        for record in self:
            if hasattr(record, line_field):
                lines = record[line_field]
                if lines:
                    lines.write({
                        'ops_branch_id': record.ops_branch_id.id if record.ops_branch_id else False,
                        'ops_business_unit_id': record.ops_business_unit_id.id if record.ops_business_unit_id else False,
                    })
    
    def _prepare_invoice_vals(self, **kwargs):
        """
        Helper to prepare invoice values with matrix dimensions.
        Override this in models that create invoices.
        
        Returns:
            dict: Invoice values including matrix dimensions
        """
        vals = {}
        if hasattr(self, 'ops_branch_id') and self.ops_branch_id:
            vals['ops_branch_id'] = self.ops_branch_id.id
        if hasattr(self, 'ops_business_unit_id') and self.ops_business_unit_id:
            vals['ops_business_unit_id'] = self.ops_business_unit_id.id
        vals.update(kwargs)
        return vals
    
    def _prepare_picking_vals(self, **kwargs):
        """
        Helper to prepare stock picking values with matrix dimensions.
        Override this in models that create pickings.
        
        Returns:
            dict: Picking values including matrix dimensions
        """
        vals = {}
        if hasattr(self, 'ops_branch_id') and self.ops_branch_id:
            vals['ops_branch_id'] = self.ops_branch_id.id
        if hasattr(self, 'ops_business_unit_id') and self.ops_business_unit_id:
            vals['ops_business_unit_id'] = self.ops_business_unit_id.id
        vals.update(kwargs)
        return vals
    
    def get_matrix_domain(self):
        """
        Get domain filter for matrix dimensions.
        Useful for filtering related records.
        
        Returns:
            list: Domain for searching records with same matrix dimensions
        """
        self.ensure_one()
        domain = []
        if self.ops_branch_id:
            domain.append(('ops_branch_id', '=', self.ops_branch_id.id))
        if self.ops_business_unit_id:
            domain.append(('ops_business_unit_id', '=', self.ops_business_unit_id.id))
        return domain
    
    def validate_matrix_dimensions(self):
        """
        Validate that required matrix dimensions are set.
        Override this in specific models to enforce requirements.
        
        Returns:
            bool: True if valid
        
        Raises:
            ValidationError: If required dimensions are missing
        """
        for record in self:
            # Basic validation - can be overridden
            if not record.ops_branch_id:
                # Warning only, not blocking for compatibility
                pass
            if not record.ops_business_unit_id:
                # Warning only, not blocking for compatibility
                pass
        return True

    # =========================================================================
    # Onchange Methods for UI
    # =========================================================================
    
    @api.onchange('ops_branch_id')
    def _onchange_branch_id(self):
        """
        Clear business unit when branch changes to ensure valid combinations.
        Also applies domain filter to BU selection based on selected branch.
        """
        for record in self:
            if record.ops_branch_id:
                # If BU is set and doesn't belong to new branch, clear it
                if record.ops_business_unit_id:
                    if record.ops_branch_id not in record.ops_business_unit_id.branch_ids:
                        record.ops_business_unit_id = False
                
                # Return domain to filter BU selection
                return {
                    'domain': {
                        'ops_business_unit_id': [
                            ('branch_ids', '=', record.ops_branch_id.id),
                            ('active', '=', True)
                        ]
                    }
                }
            else:
                # No branch selected, clear BU
                record.ops_business_unit_id = False
    
    @api.onchange('ops_branch_id', 'ops_business_unit_id')
    def _onchange_matrix_dimensions(self):
        """
        Trigger when matrix dimensions change in the UI.
        Can be overridden to add model-specific behavior.
        """
        # This is a hook for subclasses to implement
        pass
    
    # =========================================================================
    # Branch Access Control Methods
    # =========================================================================
    
    def _get_branch_domain(self):
        """
        Get domain filter for user's allowed branches.
        
        Returns domain that limits records to branches the current user can access.
        System administrators (base.group_system) bypass all restrictions.
        Cross-branch BU leaders get special handling.
        
        Returns:
            list: Odoo domain for branch filtering
        
        Usage:
            domain = self._get_branch_domain()
            records = self.env['sale.order'].search(domain)
        """
        user = self.env.user
        
        # Admin bypass: System administrators can access all branches
        if user.has_group('base.group_system'):
            return []
        
        # Get user's allowed branches from res.users
        allowed_branch_ids = []
        
        # Direct branch assignments
        if hasattr(user, 'ops_allowed_branch_ids') and user.ops_allowed_branch_ids:
            allowed_branch_ids = user.ops_allowed_branch_ids.ids
        
        # Legacy field support
        elif hasattr(user, 'allowed_branch_ids') and user.allowed_branch_ids:
            allowed_branch_ids = user.allowed_branch_ids.ids
        
        # Cross-branch BU leader: Get branches where their BUs operate
        if user.has_group('ops_matrix_core.group_ops_cross_branch_bu_leader'):
            allowed_bus = user.ops_allowed_business_unit_ids if hasattr(user, 'ops_allowed_business_unit_ids') else self.env['ops.business.unit']
            if allowed_bus:
                bu_branch_ids = allowed_bus.mapped('branch_ids').ids
                allowed_branch_ids = list(set(allowed_branch_ids + bu_branch_ids))
        
        # If no branches defined, return domain that matches nothing
        if not allowed_branch_ids:
            return [('id', '=', False)]
        
        return [('ops_branch_id', 'in', allowed_branch_ids)]
    
    def _apply_branch_filter(self, domain):
        """
        Apply branch access filter to an existing domain.
        
        Combines the provided domain with branch access restrictions.
        Useful for extending search domains with security filters.
        
        Args:
            domain (list): Existing Odoo domain to enhance
        
        Returns:
            list: Combined domain with branch filter applied
        
        Usage:
            base_domain = [('state', '=', 'draft')]
            filtered_domain = self._apply_branch_filter(base_domain)
            records = self.env['sale.order'].search(filtered_domain)
        """
        branch_domain = self._get_branch_domain()
        
        if not branch_domain:
            # No filter needed (admin bypass)
            return domain
        
        # Combine domains with AND logic
        if domain:
            return ['&'] + branch_domain + domain
        else:
            return branch_domain
    
    def _check_branch_access(self):
        """
        Verify that current user has access to this record's branch.
        
        Validates user permissions against the record's ops_branch_id.
        System administrators always have access.
        Raises ValidationError if user lacks access rights.
        
        Returns:
            bool: True if user has access
        
        Raises:
            ValidationError: If user cannot access the branch
        
        Usage:
            # In a model method
            self._check_branch_access()
            # Proceed with operation...
        """
        from odoo.exceptions import ValidationError
        
        for record in self:
            user = self.env.user
            
            # Admin bypass: System administrators can access all branches
            if user.has_group('base.group_system'):
                continue
            
            # If no branch set on record, allow (for backward compatibility)
            if not record.ops_branch_id:
                continue
            
            # Get user's allowed branches
            allowed_branch_ids = []
            
            if hasattr(user, 'ops_allowed_branch_ids') and user.ops_allowed_branch_ids:
                allowed_branch_ids = user.ops_allowed_branch_ids.ids
            elif hasattr(user, 'allowed_branch_ids') and user.allowed_branch_ids:
                allowed_branch_ids = user.allowed_branch_ids.ids
            
            # Cross-branch BU leader special handling
            if user.has_group('ops_matrix_core.group_ops_cross_branch_bu_leader'):
                allowed_bus = user.ops_allowed_business_unit_ids if hasattr(user, 'ops_allowed_business_unit_ids') else self.env['ops.business.unit']
                if allowed_bus:
                    bu_branch_ids = allowed_bus.mapped('branch_ids').ids
                    allowed_branch_ids = list(set(allowed_branch_ids + bu_branch_ids))
            
            # Check access
            if record.ops_branch_id.id not in allowed_branch_ids:
                raise ValidationError(
                    f"Access Denied: You do not have access to branch '{record.ops_branch_id.name}'. "
                    f"Contact your system administrator to request access."
                )
        
        return True
    
    def _get_allowed_branches(self):
        """
        Get recordset of branches that current user can access.
        
        Returns:
            recordset: ops.branch records the user can access
        
        Usage:
            allowed_branches = self._get_allowed_branches()
            for branch in allowed_branches:
                print(branch.name)
        """
        user = self.env.user
        
        # Admin bypass: return all branches
        if user.has_group('base.group_system'):
            return self.env['ops.branch'].search([('active', '=', True)])
        
        # Get user's allowed branches
        allowed_branches = self.env['ops.branch']
        
        if hasattr(user, 'ops_allowed_branch_ids') and user.ops_allowed_branch_ids:
            allowed_branches = user.ops_allowed_branch_ids
        elif hasattr(user, 'allowed_branch_ids') and user.allowed_branch_ids:
            allowed_branches = user.allowed_branch_ids
        
        # Add branches for cross-branch BU leaders
        if user.has_group('ops_matrix_core.group_ops_cross_branch_bu_leader'):
            allowed_bus = user.ops_allowed_business_unit_ids if hasattr(user, 'ops_allowed_business_unit_ids') else self.env['ops.business.unit']
            if allowed_bus:
                bu_branches = allowed_bus.mapped('branch_ids')
                allowed_branches |= bu_branches
        
        return allowed_branches

--- ops_matrix_core/models/ops_mixin.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api

class OpsMatrixMixin(models.AbstractModel):
    """
    Gold Standard Mixin for Matrix Awareness.
    Inherit this in Sale Order, Move, Picking, etc. to make them 'Matrix Aware'.
    """
    _name = 'ops.matrix.mixin'
    _description = 'Matrix Operations Mixin'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        index=True,
        tracking=True,
        check_company=True,
        help="Physical or Geographic Operational Entity"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        index=True,
        tracking=True,
        check_company=True,
        help="Strategic or Logical Operational Entity"
    )

    # ---------------------------------------------------------
    # Default Generation Logic (Optional hook for downstream)
    # ---------------------------------------------------------
    def _get_default_ops_branch(self):
        """ Hook to fetch default branch from user context or settings """
        return self.env.user.employee_id.branch_id if hasattr(self.env.user, 'employee_id') else False
--- ops_matrix_core/models/ops_performance_indexes.py ---
# -*- coding: utf-8 -*-
"""
Performance Optimization: Database Indexes
This module adds critical indexes to improve query performance for the OPS Matrix framework.
"""
from odoo import models, tools, _
import logging

_logger = logging.getLogger(__name__)


class OpsPerformanceIndexes(models.AbstractModel):
    """Add performance indexes to critical OPS Matrix fields."""
    _name = 'ops.performance.indexes'
    _description = 'OPS Performance Index Management'
    
    def _auto_init(self):
        """Create indexes on critical fields for performance optimization."""
        res = super()._auto_init()
        
        # Define indexes to create
        # Format: (table_name, column_name, index_name)
        indexes = [
            # Sale Order indexes
            ('sale_order', 'ops_branch_id', 'idx_sale_order_ops_branch'),
            ('sale_order', 'ops_business_unit_id', 'idx_sale_order_ops_bu'),
            ('sale_order', 'date_order', 'idx_sale_order_date'),
            ('sale_order', 'state', 'idx_sale_order_state'),
            
            # Sale Order Line indexes
            ('sale_order_line', 'ops_branch_id', 'idx_sol_ops_branch'),
            ('sale_order_line', 'ops_business_unit_id', 'idx_sol_ops_bu'),
            ('sale_order_line', 'product_id', 'idx_sol_product'),
            
            # Purchase Order indexes
            ('purchase_order', 'ops_branch_id', 'idx_po_ops_branch'),
            ('purchase_order', 'ops_business_unit_id', 'idx_po_ops_bu'),
            ('purchase_order', 'date_order', 'idx_po_date_order'),
            ('purchase_order', 'state', 'idx_po_state'),
            
            # Account Move (Invoice) indexes
            ('account_move', 'ops_branch_id', 'idx_account_move_ops_branch'),
            ('account_move', 'ops_business_unit_id', 'idx_account_move_ops_bu'),
            ('account_move', 'date', 'idx_account_move_date'),
            ('account_move', 'invoice_date', 'idx_account_move_invoice_date'),
            ('account_move', 'move_type', 'idx_account_move_type'),
            ('account_move', 'state', 'idx_account_move_state'),
            
            # Account Move Line indexes
            ('account_move_line', 'ops_branch_id', 'idx_aml_ops_branch'),
            ('account_move_line', 'ops_business_unit_id', 'idx_aml_ops_bu'),
            ('account_move_line', 'date', 'idx_aml_date'),
            ('account_move_line', 'account_id', 'idx_aml_account'),
            ('account_move_line', 'product_id', 'idx_aml_product'),
            
            # Stock Picking indexes
            ('stock_picking', 'ops_branch_id', 'idx_stock_picking_ops_branch'),
            ('stock_picking', 'scheduled_date', 'idx_stock_picking_scheduled_date'),
            ('stock_picking', 'state', 'idx_stock_picking_state'),
            ('stock_picking', 'picking_type_id', 'idx_stock_picking_type'),
            
            # Stock Move indexes
            ('stock_move', 'ops_branch_id', 'idx_stock_move_ops_branch'),
            ('stock_move', 'product_id', 'idx_stock_move_product'),
            ('stock_move', 'location_id', 'idx_stock_move_location'),
            ('stock_move', 'location_dest_id', 'idx_stock_move_location_dest'),
            ('stock_move', 'state', 'idx_stock_move_state'),
            
            # Stock Quant indexes
            ('stock_quant', 'location_id', 'idx_stock_quant_location'),
            ('stock_quant', 'product_id', 'idx_stock_quant_product'),
            ('stock_quant', 'ops_business_unit_id', 'idx_stock_quant_ops_bu'),
            
            # Product Template indexes
            ('product_template', 'business_unit_id', 'idx_product_template_bu'),
            ('product_template', 'categ_id', 'idx_product_template_categ'),
            
            # Product Product indexes
            ('product_product', 'default_code', 'idx_product_product_default_code'),
            
            # OPS Branch indexes
            ('ops_branch', 'code', 'idx_ops_branch_code'),
            ('ops_branch', 'active', 'idx_ops_branch_active'),
            
            # OPS Business Unit indexes
            ('ops_business_unit', 'code', 'idx_ops_bu_code'),
            ('ops_business_unit', 'active', 'idx_ops_bu_active'),
            
            # OPS Approval Request indexes
            ('ops_approval_request', 'branch_id', 'idx_approval_branch'),
            ('ops_approval_request', 'business_unit_id', 'idx_approval_bu'),
            ('ops_approval_request', 'state', 'idx_approval_state'),
            ('ops_approval_request', 'requested_date', 'idx_approval_date'),
            
            # OPS Governance Rule indexes
            ('ops_governance_rule', 'ops_branch_id', 'idx_gov_rule_branch'),
            ('ops_governance_rule', 'ops_business_unit_id', 'idx_gov_rule_bu'),
            ('ops_governance_rule', 'active', 'idx_gov_rule_active'),
            
            # OPS Persona indexes
            ('ops_persona', 'user_id', 'idx_persona_user'),
            ('ops_persona', 'active', 'idx_persona_active'),
            
            # Composite indexes disabled - create manually after installation if needed
            # ('sale_order', 'ops_branch_id, ops_business_unit_id', 'idx_so_branch_bu_composite'),
            # ('sale_order', 'date_order, state', 'idx_so_date_state_composite'),
            # ('purchase_order', 'ops_branch_id, ops_business_unit_id', 'idx_po_branch_bu_composite'),
            # ('account_move', 'ops_branch_id, ops_business_unit_id', 'idx_am_branch_bu_composite'),
            # ('account_move', 'date, state', 'idx_am_date_state_composite'),
        ]
        
        cr = self.env.cr
        
        for table, column, index_name in indexes:
            try:
                # Check if table exists
                cr.execute("""
                    SELECT EXISTS (
                        SELECT FROM information_schema.tables 
                        WHERE table_schema = 'public' 
                        AND table_name = %s
                    );
                """, (table,))
                
                if not cr.fetchone()[0]:
                    _logger.debug(f"Table {table} does not exist, skipping index {index_name}")
                    continue
                
                # Check if column exists (for composite indexes, skip this check)
                if ',' not in column:
                    cr.execute("""
                        SELECT EXISTS (
                            SELECT FROM information_schema.columns 
                            WHERE table_schema = 'public' 
                            AND table_name = %s 
                            AND column_name = %s
                        );
                    """, (table, column))
                    
                    if not cr.fetchone()[0]:
                        _logger.debug(f"Column {column} does not exist in table {table}, skipping index {index_name}")
                        continue
                
                # Check if index already exists
                cr.execute("""
                    SELECT EXISTS (
                        SELECT FROM pg_indexes 
                        WHERE schemaname = 'public' 
                        AND tablename = %s 
                        AND indexname = %s
                    );
                """, (table, index_name))
                
                if cr.fetchone()[0]:
                    _logger.debug(f"Index {index_name} already exists on {table}.{column}")
                    continue
                
                # Create index
                query = f"CREATE INDEX CONCURRENTLY IF NOT EXISTS {index_name} ON {table} ({column})"
                _logger.info(f"Creating index: {query}")
                
                # Note: CONCURRENTLY requires being outside a transaction block
                # In module installation, we can't use CONCURRENTLY, so we use regular CREATE INDEX
                query = f"CREATE INDEX IF NOT EXISTS {index_name} ON {table} ({column})"
                cr.execute(query)
                _logger.info(f"Successfully created index {index_name} on {table}.{column}")
                
            except Exception as e:
                _logger.warning(f"Failed to create index {index_name} on {table}.{column}: {e}")
                # Continue with other indexes even if one fails
                continue
        
        return res


class SaleOrder(models.Model):
    """Add index hints to sale.order model."""
    _inherit = 'sale.order'
    
    def init(self):
        """Ensure indexes exist on sale.order."""
        super().init()
        # Indexes are created by OpsPerformanceIndexes


class PurchaseOrder(models.Model):
    """Add index hints to purchase.order model."""
    _inherit = 'purchase.order'
    
    def init(self):
        """Ensure indexes exist on purchase.order."""
        super().init()
        # Indexes are created by OpsPerformanceIndexes


class AccountMove(models.Model):
    """Add index hints to account.move model."""
    _inherit = 'account.move'
    
    def init(self):
        """Ensure indexes exist on account.move."""
        super().init()
        # Indexes are created by OpsPerformanceIndexes


class StockPicking(models.Model):
    """Add index hints to stock.picking model."""
    _inherit = 'stock.picking'
    
    def init(self):
        """Ensure indexes exist on stock.picking."""
        super().init()
        # Indexes are created by OpsPerformanceIndexes

--- ops_matrix_core/models/ops_persona.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)

class OpsPersona(models.Model):
    _name = 'ops.persona'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _description = 'OPS Persona - Role Assignment with Matrix Dimensions'
    _order = 'sequence, name'
    
    # ============================================
    # BASIC IDENTIFICATION FIELDS
    # ============================================
    name = fields.Char(
        string='Persona Name',
        required=True,
        tracking=True,
        help='Display name for this persona/role assignment. '
             'Format: "[Location] [Role]" or "[Role] - [BusinessUnit]". '
             'Examples: "Seattle Store Manager", "Retail Director - Electronics", "Regional VP - North". '
             'This name appears in: approval requests, delegation records, user dashboards, reports. '
             'Best Practice: Use clear, descriptive names that immediately identify the role and scope. '
             'A persona combines a user with specific matrix access (branches + business units).'
    )
    
    code = fields.Char(
        string='Persona Code',
        required=True,
        copy=False,
        default='New',
        help='Unique identifier for this persona across all companies. '
             'Auto-generated on save (format: PRS-XXXX). '
             'Cannot be changed after creation. '
             'Used in: Audit logs, approval workflows, reporting, API integrations. '
             'Example: PRS-001, PRS-MGR-SEA, PRS-DIR-RETAIL.'
    )
    
    description = fields.Text(
        string='Description',
        help='Detailed description of this persona\'s role, responsibilities, and scope of authority. '
             'Include: Key responsibilities, decision-making authority, reporting structure, coverage areas. '
             'Example: "Manages all retail operations for Seattle branch including sales, inventory, and staff. '
             'Approval authority up to $50K. Reports to Regional Director. Covers Electronics and Appliances BUs." '
             'Use Cases: Onboarding new users, defining role boundaries, documenting approval limits. '
             'Best Practice: Update when responsibilities change.'
    )
    
    # ============================================
    # USER ASSIGNMENT
    # ============================================
    user_id = fields.Many2one(
        'res.users',
        string='Assigned User',
        required=False,  # Can be empty for draft personas
        ondelete='cascade',
        tracking=True,
        help='The Odoo user who is assigned to this persona/role. '
             'This user inherits all matrix access (branches, business units) defined in this persona. '
             'A user can have multiple personas (e.g., Store Manager + Regional Backup). '
             'Can be empty for template personas or during setup. '
             'When assigned: User automatically gains access to the specified branches and BUs. '
             'Important: Changing the user immediately updates their system access. '
             'Related: User can delegate this persona to another user temporarily.'
    )
    
    # Multi-user support (optional - for future use)
    secondary_user_ids = fields.Many2many(
        'res.users',
        'persona_secondary_users_rel',
        'persona_id',
        'user_id',
        string='Secondary Users',
        help='Additional backup users who can act under this persona when the primary user is unavailable. '
             'Use Cases: Vacation coverage, peak period support, cross-training, emergency backup. '
             'Secondary users have the same access as the primary user for this persona. '
             'Example: Primary = Store Manager, Secondary = Assistant Manager (can cover during manager absence). '
             'Note: For temporary coverage, use the Delegation system instead.'
    )
    
    # Legacy HR integration
    employee_id = fields.Many2one(
        'hr.employee',
        string='Related Employee',
        tracking=True,
        help="The HR Employee record (for hierarchy and department logic)"
    )
    
    # ============================================
    # MATRIX DIMENSION ASSIGNMENTS
    # ============================================
    
    # Company assignment
    company_id = fields.Many2one(
        'res.company',
        string='Primary Company',
        required=True,
        default=lambda self: self.env.company,
        tracking=True,
        help='The legal entity (company) this persona belongs to. Required. '
             'All assigned branches must belong to this company. '
             'Used for: Financial reporting, legal compliance, multi-company access control. '
             'Important: Cannot be changed if persona has historical transactions. '
             'Multi-Company Note: A user can have different personas in different companies.'
    )
    
    # Branch assignments (multi-branch support) - NEW OPS.BRANCH MODEL
    branch_ids = fields.Many2many(
        'ops.branch',
        'persona_branch_rel',
        'persona_id',
        'branch_id',
        string='Assigned Branches',
        domain="[('company_id', '=', company_id)]",
        help='Branches (locations) where this persona can operate and access data. '
             'The user assigned to this persona will see transactions only from these branches. '
             'Examples: '
             '- Single-branch persona: Manager of Seattle Store â†’ [Seattle] '
             '- Multi-branch persona: Regional Director â†’ [Seattle, Portland, Vancouver] '
             '- Nationwide persona: VP Sales â†’ [All retail branches]. '
             'Access Control: User can view/create transactions only in assigned branches. '
             'Reporting: Reports can be filtered by these branches. '
             'Must be from the same company as the persona.'
    )
    
    # Business Unit assignments (multi-BU support)
    business_unit_ids = fields.Many2many(
        'ops.business.unit',
        'persona_business_unit_rel',
        'persona_id',
        'unit_id',
        string='Assigned Business Units',
        help='Business Units (product lines/divisions) this persona can access and manage. '
             'Combined with branch access, this defines the complete matrix scope. '
             'Examples: '
             '- "Seattle Store Manager" â†’ Branches:[Seattle], BUs:[Retail Electronics, Retail Appliances] '
             '- "Wholesale Director" â†’ Branches:[All], BUs:[Wholesale] '
             '- "Electronics VP" â†’ Branches:[All retail], BUs:[Electronics only]. '
             'Access Control: User sees only products and transactions for these BUs in their branches. '
             'Matrix Rule: User access = Intersection of (Assigned Branches) Ã— (Assigned BUs). '
             'Validation: Selected BUs must operate in at least one assigned branch.'
    )
    
    # ============================================
    # DEFAULT SELECTIONS FOR TRANSACTIONS
    # ============================================
    default_branch_id = fields.Many2one(
        'ops.branch',
        string='Default Branch',
        domain="[('id', 'in', branch_ids)]",
        help='The branch that is automatically pre-selected when user creates new transactions. '
             'Must be one of the assigned branches above. '
             'Used when creating: Sales orders, purchase orders, invoices, stock transfers. '
             'User can change to other assigned branches if needed. '
             'Example: Regional manager has 10 branches but defaults to headquarters branch. '
             'Best Practice: Set to the user\'s primary work location. '
             'Leave empty for multi-branch users without a primary location.'
    )
    
    default_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Default Business Unit',
        domain="[('id', 'in', business_unit_ids)]",
        help='The Business Unit that is automatically pre-selected when user creates new transactions. '
             'Must be one of the assigned BUs above. '
             'Used when creating: Sales orders, products, quotations, reports. '
             'User can change to other assigned BUs if needed. '
             'Example: Manager handles Retail and Wholesale but defaults to Retail (higher volume). '
             'Best Practice: Set to the BU the user works with most frequently. '
             'Leave empty for users without a primary BU focus.'
    )
    
    # ============================================
    # LEGACY FIELDS FOR BACKWARD COMPATIBILITY
    # ============================================
    # These fields map to res.company for compatibility with existing code
    branch_id = fields.Many2one(
        'res.company',
        string='Primary Branch (Legacy)',
        compute='_compute_legacy_branch',
        store=True,
        readonly=False,
        tracking=True,
        help="Legacy field - maps to default_branch_id.company_id"
    )
    
    primary_branch_id = fields.Many2one(
        'res.company',
        string='Primary Branch (Access)',
        related='branch_id',
        store=True,
        readonly=False,
        help="Primary company/branch for access control rules"
    )
    
    allowed_branch_ids = fields.Many2many(
        'res.company',
        'persona_branch_allowed_rel',
        'persona_id',
        'branch_id',
        string='Allowed Branches (Legacy)',
        compute='_compute_legacy_allowed_branches',
        store=True,
        readonly=False
    )
    
    allowed_business_unit_ids = fields.Many2many(
        'ops.business.unit',
        'persona_bu_allowed_rel',
        'persona_id',
        'unit_id',
        string='Allowed Business Units (Legacy)',
        compute='_compute_legacy_allowed_bus',
        store=True,
        readonly=False
    )
    
    # ============================================
    # ROLE INDICATORS AND AUTHORITIES
    # ============================================
    is_branch_manager = fields.Boolean(
        string='Branch Manager',
        default=False,
        help='This persona has branch management authority'
    )
    
    is_bu_leader = fields.Boolean(
        string='Business Unit Leader',
        default=False,
        help='This persona has BU leadership authority'
    )
    
    is_cross_branch = fields.Boolean(
        string='Cross-Branch Authority',
        default=False,
        help='Can access same BU across multiple branches'
    )
    
    is_matrix_administrator = fields.Boolean(
        string='Matrix Administrator',
        default=False,
        help='Can configure matrix structure and rules'
    )
    
    is_approver = fields.Boolean(
        string='Approver Role',
        default=False,
        help='Can approve transactions and requests'
    )
    
    # Approval limits
    approval_limit = fields.Monetary(
        string='Approval Limit Amount',
        currency_field='currency_id',
        help='Maximum amount this persona can approve'
    )
    
    currency_id = fields.Many2one(
        'res.currency',
        string='Currency',
        related='company_id.currency_id',
        store=True
    )
    
    # Legacy approval flags
    can_approve_orders = fields.Boolean(
        string='Can Approve Orders',
        default=False,
        help='Computed from is_approver for backward compatibility'
    )
    
    can_approve_expenses = fields.Boolean(
        string='Can Approve Expenses',
        default=False,
        help='Computed from is_approver for backward compatibility'
    )
    
    can_approve_leave = fields.Boolean(
        string='Can Approve Leave',
        default=False,
        help='Computed from is_approver for backward compatibility'
    )
    
    can_manage_team = fields.Boolean(
        string='Can Manage Team',
        default=False,
        help='Computed from is_branch_manager or is_bu_leader'
    )
    
    # ============================================
    # SEGREGATION OF DUTIES (SoD) AUTHORITY FLAGS
    # ============================================
    can_modify_product_master = fields.Boolean(
        string='Can Modify Product Master',
        default=False,
        help='Authority to modify product cost and supplier information. '
             'Restricted to Procurement and Finance roles to prevent cost manipulation.'
    )
    
    can_access_cost_prices = fields.Boolean(
        string='Can Access Cost Prices',
        default=False,
        help='Authority to view product cost prices. '
             'Restricted from Sales to maintain margin confidentiality.'
    )
    
    can_validate_invoices = fields.Boolean(
        string='Can Validate Invoices',
        default=False,
        help='Authority to validate and post customer/vendor invoices. '
             'Restricted to Accountant level and above.'
    )
    
    can_post_journal_entries = fields.Boolean(
        string='Can Post Journal Entries',
        default=False,
        help='Authority to post accounting journal entries. '
             'Restricted to Accountant/CFO only to prevent financial manipulation.'
    )
    
    can_execute_payments = fields.Boolean(
        string='Can Execute Payments',
        default=False,
        help='Authority to execute vendor payments and transfers. '
             'Restricted to Treasury role only for financial control.'
    )
    
    can_adjust_inventory = fields.Boolean(
        string='Can Adjust Inventory',
        default=False,
        help='Authority to post inventory adjustments (write-offs, corrections). '
             'Restricted to Inventory Manager to prevent stock manipulation.'
    )
    
    can_manage_pdc = fields.Boolean(
        string='Can Manage PDC',
        default=False,
        help='Authority to post and deposit Post Dated Checks. '
             'Restricted to authorized Treasury/Finance personnel.'
    )
    
    # ============================================
    # DELEGATION SYSTEM INTEGRATION
    # ============================================
    can_be_delegated = fields.Boolean(
        string='Allow Delegation',
        default=True,
        help='Whether this persona can be delegated'
    )
    
    # Delegation Records
    delegation_ids = fields.One2many(
        'ops.persona.delegation',
        'persona_id',
        string='Delegations',
        help='All delegation records for this persona'
    )
    
    active_delegation_id = fields.Many2one(
        'ops.persona.delegation',
        string='Active Delegation',
        compute='_compute_active_delegation',
        store=False,
        help='Currently active delegation record, if any'
    )
    
    # Legacy delegation fields (computed from delegation records)
    delegate_id = fields.Many2one(
        'res.users',
        string='Current Delegate',
        compute='_compute_active_delegation',
        store=False,
        help='User temporarily acting as this persona'
    )
    
    delegation_start = fields.Datetime(
        string='Delegation Start',
        compute='_compute_active_delegation',
        store=False
    )
    
    delegation_end = fields.Datetime(
        string='Delegation End',
        compute='_compute_active_delegation',
        store=False
    )
    
    is_delegated = fields.Boolean(
        string='Is Delegated',
        compute='_compute_active_delegation',
        store=True,
        help='Active delegation is in effect'
    )
    
    effective_user_id = fields.Many2one(
        'res.users',
        string='Effective User',
        compute='_compute_effective_user',
        store=True,
        help='User who currently holds this persona\'s power'
    )
    
    # Delegation history
    delegation_history_ids = fields.One2many(
        'ops.persona.delegation',
        'persona_id',
        string='Delegation History',
        help='Historical record of delegations'
    )
    
    # ============================================
    # COMPUTED FIELDS FOR UI DISPLAY
    # ============================================
    branch_count = fields.Integer(
        compute='_compute_counts',
        string='Branch Count',
        store=True
    )
    
    bu_count = fields.Integer(
        compute='_compute_counts',
        string='Business Unit Count',
        store=True
    )
    
    matrix_access_summary = fields.Char(
        compute='_compute_matrix_access_summary',
        string='Matrix Access Summary',
        store=True,
        help='Summary of matrix access rights'
    )
    
    # ============================================
    # HIERARCHY & JOB FUNCTION
    # ============================================
    parent_id = fields.Many2one(
        'ops.persona',
        string='Parent Persona',
        help='Reporting line'
    )
    
    child_ids = fields.One2many(
        'ops.persona',
        'parent_id',
        string='Direct Reports'
    )
    
    job_level = fields.Selection([
        ('entry', 'Entry Level'),
        ('junior', 'Junior'),
        ('mid', 'Mid-Level'),
        ('senior', 'Senior'),
        ('lead', 'Team Lead'),
        ('manager', 'Manager'),
        ('director', 'Director'),
        ('executive', 'Executive'),
    ], string='Job Level', default='mid', tracking=True)
    
    # ============================================
    # SECURITY GROUPS
    # ============================================
    access_group_ids = fields.Many2many(
        'res.groups',
        'ops_persona_groups_rel',
        'persona_id',
        'group_id',
        string='Odoo Security Groups'
    )
    
    # ============================================
    # STATUS AND VALIDITY
    # ============================================
    active = fields.Boolean(
        string='Active',
        default=True,
        tracking=True,
        help='Active personas are available for assignment'
    )
    
    sequence = fields.Integer(
        string='Sequence',
        default=10,
        help='Controls the display order of personas in lists and selection menus. '
             'Lower numbers appear first. Default is 10. '
             'Use Cases: Prioritize frequently-used personas, group by hierarchy, order by importance. '
             'Example: CEO = 1, Directors = 5, Managers = 10, Staff = 20. '
             'Tip: Use increments of 5 to allow easy reordering without affecting other personas.'
    )
    
    start_date = fields.Date(
        string='Start Date',
        default=fields.Date.today,
        help='The date when this persona assignment becomes effective and user gains access. '
             'Use Cases: '
             '- Future assignments: Create persona in advance, starts on employee join date '
             '- Promotions: Schedule new role to start on promotion date '
             '- Reorganizations: Coordinate role changes with org structure changes. '
             'Default: Today\'s date (immediate effect). '
             'Important: User will not have access until this date arrives. '
             'System checks this date when determining active personas.'
    )
    
    end_date = fields.Date(
        string='End Date',
        help='Optional date when this persona assignment expires and access is automatically revoked. '
             'Leave empty for permanent assignments. '
             'Use Cases: '
             '- Temporary assignments: Project managers, interim coverage, seasonal roles '
             '- Contract employees: Set to contract end date '
             '- Planned departures: Set when resignation notice is received. '
             'Auto-Deactivation: System automatically deactivates persona after this date (via scheduled job). '
             'User loses access on the day after the end date. '
             'Example: Temporary holiday season manager from Nov 1 to Jan 15.'
    )
    
    is_active_today = fields.Boolean(
        compute='_compute_is_active_today',
        string='Currently Active',
        store=True,
        help='Persona is active today based on start/end dates'
    )
    
    # Audit fields
    last_sync_date = fields.Datetime(
        string='Last Sync Date',
        readonly=True,
        help='When persona was last synced to user access'
    )
    
    # Legacy user count
    user_count = fields.Integer(
        compute='_compute_user_count',
        string='User Count'
    )
    
    user_ids = fields.One2many(
        'res.users',
        'persona_id',
        string='Assigned Users'
    )
    
    # ============================================
    # COMPUTED METHODS
    # ============================================
    
    @api.depends('branch_ids', 'business_unit_ids')
    def _compute_counts(self):
        """Compute counts of branches and business units."""
        for persona in self:
            persona.branch_count = len(persona.branch_ids)
            persona.bu_count = len(persona.business_unit_ids)
    
    @api.depends('delegation_ids', 'delegation_ids.active', 
                 'delegation_ids.start_date', 'delegation_ids.end_date')
    def _compute_active_delegation(self):
        """Compute currently active delegation and related fields."""
        now = fields.Datetime.now()
        for persona in self:
            # Find active delegation
            active_delegation = self.env['ops.persona.delegation'].search([
                ('persona_id', '=', persona.id),
                ('active', '=', True),
                ('start_date', '<=', now),
                ('end_date', '>=', now)
            ], limit=1, order='start_date desc')
            
            # Set computed fields
            persona.active_delegation_id = active_delegation
            persona.is_delegated = bool(active_delegation)
            persona.delegate_id = active_delegation.delegate_id if active_delegation else False
            persona.delegation_start = active_delegation.start_date if active_delegation else False
            persona.delegation_end = active_delegation.end_date if active_delegation else False
    
    @api.depends('user_id', 'delegation_ids', 'delegation_ids.active',
                 'delegation_ids.start_date', 'delegation_ids.end_date')
    def _compute_effective_user(self):
        """Determine who holds the power right now."""
        now = fields.Datetime.now()
        for persona in self:
            # Check for active delegation
            active_delegation = self.env['ops.persona.delegation'].search([
                ('persona_id', '=', persona.id),
                ('active', '=', True),
                ('start_date', '<=', now),
                ('end_date', '>=', now)
            ], limit=1)
            
            if active_delegation:
                persona.effective_user_id = active_delegation.delegate_id
            else:
                persona.effective_user_id = persona.user_id
    
    @api.depends('branch_ids', 'business_unit_ids', 'is_branch_manager', 
                 'is_bu_leader', 'is_cross_branch', 'is_matrix_administrator')
    def _compute_matrix_access_summary(self):
        """Compute human-readable summary of matrix access."""
        for persona in self:
            parts = []
            
            # Branch access summary
            if persona.branch_ids:
                if persona.branch_count <= 3:
                    branch_names = persona.branch_ids.mapped('code')
                    parts.append(f"Branches: {', '.join(branch_names)}")
                else:
                    parts.append(f"Branches: {persona.branch_count}")
            
            # BU access summary
            if persona.business_unit_ids:
                if persona.bu_count <= 3:
                    bu_names = persona.business_unit_ids.mapped('code')
                    parts.append(f"BUs: {', '.join(bu_names)}")
                else:
                    parts.append(f"BUs: {persona.bu_count}")
            
            # Role indicators
            if persona.is_branch_manager:
                parts.append("Branch Manager")
            if persona.is_bu_leader:
                parts.append("BU Leader")
            if persona.is_cross_branch:
                parts.append("Cross-Branch")
            if persona.is_matrix_administrator:
                parts.append("Matrix Admin")
            if persona.is_approver:
                parts.append("Approver")
            
            persona.matrix_access_summary = " | ".join(parts) if parts else "No matrix access"
    
    @api.depends('active', 'start_date', 'end_date')
    def _compute_is_active_today(self):
        """Determine if persona is active today based on dates."""
        today = fields.Date.today()
        for persona in self:
            active_by_date = True
            if persona.start_date and persona.start_date > today:
                active_by_date = False
            if persona.end_date and persona.end_date < today:
                active_by_date = False
            
            persona.is_active_today = persona.active and active_by_date
    
    @api.depends('default_branch_id', 'default_branch_id.company_id')
    def _compute_legacy_branch(self):
        """Compute legacy branch_id from default_branch_id."""
        for persona in self:
            if persona.default_branch_id:
                persona.branch_id = persona.default_branch_id.company_id
            elif persona.branch_ids:
                persona.branch_id = persona.branch_ids[0].company_id
            else:
                persona.branch_id = False
    
    @api.depends('branch_ids', 'branch_ids.company_id')
    def _compute_legacy_allowed_branches(self):
        """Compute legacy allowed_branch_ids from branch_ids."""
        for persona in self:
            persona.allowed_branch_ids = [(6, 0, persona.branch_ids.mapped('company_id').ids)]
    
    @api.depends('business_unit_ids')
    def _compute_legacy_allowed_bus(self):
        """Compute legacy allowed business units."""
        for persona in self:
            persona.allowed_business_unit_ids = [(6, 0, persona.business_unit_ids.ids)]
    
    def _compute_user_count(self):
        """Compute count of users assigned to this persona."""
        for record in self:
            record.user_count = self.env['res.users'].search_count([
                ('persona_id', '=', record.id)
            ])
    
    # ============================================
    # CONSTRAINT METHODS
    # ============================================
    
    @api.constrains('branch_ids', 'company_id')
    def _check_branch_company(self):
        """Ensure all branches belong to persona's company."""
        for persona in self:
            invalid_branches = persona.branch_ids.filtered(
                lambda b: b.company_id != persona.company_id
            )
            if invalid_branches:
                raise ValidationError(_(
                    "Branches %(branch_names)s do not belong to company %(company_name)s. "
                    "Please select branches from the correct company."
                ) % {
                    'branch_names': ', '.join(invalid_branches.mapped('name')),
                    'company_name': persona.company_id.name
                })
    
    @api.constrains('business_unit_ids', 'branch_ids')
    def _check_bu_branch_compatibility(self):
        """Ensure BUs operate in assigned branches."""
        for persona in self:
            for bu in persona.business_unit_ids:
                # Check if BU operates in at least one of persona's branches
                compatible_branches = bu.branch_ids & persona.branch_ids
                if not compatible_branches:
                    raise ValidationError(_(
                        "Business Unit '%(bu_name)s' does not operate in any of "
                        "persona's assigned branches. Please assign compatible branches."
                    ) % {'bu_name': bu.name})
    
    @api.constrains('default_branch_id', 'branch_ids')
    def _check_default_branch(self):
        """Ensure default branch is in assigned branches."""
        for persona in self:
            if (persona.default_branch_id and 
                persona.default_branch_id not in persona.branch_ids):
                raise ValidationError(_(
                    "Default branch '%(branch_name)s' must be in persona's assigned branches."
                ) % {'branch_name': persona.default_branch_id.name})
    
    @api.constrains('default_business_unit_id', 'business_unit_ids')
    def _check_default_bu(self):
        """Ensure default BU is in assigned BUs."""
        for persona in self:
            if (persona.default_business_unit_id and 
                persona.default_business_unit_id not in persona.business_unit_ids):
                raise ValidationError(_(
                    "Default business unit '%(bu_name)s' must be in persona's assigned business units."
                ) % {'bu_name': persona.default_business_unit_id.name})
    
    @api.constrains('parent_id')
    def _check_parent_recursion(self):
        """Prevent circular parent relationships."""
        if not self._check_recursion():
            raise ValidationError(_('Error! You cannot create recursive persona hierarchies.'))
    
    # ============================================
    # CRUD METHODS
    # ============================================
    
    @api.model_create_multi
    def create(self, vals_list):
        """Override create to generate code and sync with user."""
        # Generate codes
        for vals in vals_list:
            if vals.get('code', 'New') == 'New':
                vals['code'] = self.env['ir.sequence'].next_by_code('ops.persona.code') or 'PRS0001'
        
        personas = super().create(vals_list)
        
        # Sync to user access
        personas._sync_user_access()
        
        # Log creation
        for persona in personas:
            _logger.info(f"Persona created: {persona.name} (ID: {persona.id}) for user {persona.user_id.name if persona.user_id else 'N/A'}")
            persona.message_post(
                body=_('Persona created with access to %d branches and %d business units.') % (
                    persona.branch_count, persona.bu_count
                )
            )
        
        return personas
    
    def write(self, vals):
        """Override write to sync changes to user access."""
        # Track changes for logging
        changes = {}
        matrix_fields = ['branch_ids', 'business_unit_ids', 'default_branch_id', 
                        'default_business_unit_id', 'user_id', 'active',
                        'is_branch_manager', 'is_bu_leader', 'is_cross_branch']
        
        for field in matrix_fields:
            if field in vals:
                changes[field] = {
                    'old': str(self.mapped(field)),
                    'new': str(vals[field])
                }
        
        # Perform write
        result = super().write(vals)
        
        # Sync to user if matrix fields changed
        sync_fields = ['branch_ids', 'business_unit_ids', 'default_branch_id', 
                      'default_business_unit_id', 'user_id', 'active',
                      'is_branch_manager', 'is_bu_leader', 'is_cross_branch',
                      'is_matrix_administrator']
        
        if any(field in vals for field in sync_fields):
            self._sync_user_access()
            self.last_sync_date = fields.Datetime.now()
        
        # Log changes
        for field, change in changes.items():
            if change['old'] != change['new']:
                for persona in self:
                    persona.message_post(
                        body=_('Persona field updated: %(field)s changed.') % {
                            'field': field
                        }
                    )
        
        return result
    
    def unlink(self):
        """Override unlink to remove user access before deletion."""
        # Store user references for cleanup
        user_persona_map = {}
        for persona in self:
            if persona.user_id:
                user_id = persona.user_id.id
                if user_id not in user_persona_map:
                    user_persona_map[user_id] = []
                user_persona_map[user_id].append(persona.id)
        
        # Remove access before deletion
        for persona in self:
            persona._remove_user_access()
        
        # Perform deletion
        result = super().unlink()
        
        # Log deletion
        for user_id, persona_ids in user_persona_map.items():
            _logger.info(f"Personas {persona_ids} deleted for user {user_id}")
        
        return result
    
    # ============================================
    # SYNC METHODS FOR USER ACCESS
    # ============================================
    
    def _sync_user_access(self):
        """Sync persona access to the assigned user."""
        for persona in self.filtered(lambda p: p.is_active_today and p.user_id):
            user = persona.user_id
            
            # Get all active personas for this user
            active_personas = self.search([
                ('user_id', '=', user.id),
                ('is_active_today', '=', True),
            ])
            
            # Collect all access from all active personas
            all_branches = self.env['ops.branch']
            all_bus = self.env['ops.business.unit']
            all_companies = self.env['res.company']
            
            has_branch_manager = False
            has_bu_leader = False
            has_cross_branch = False
            has_matrix_admin = False
            
            for active_persona in active_personas:
                all_branches |= active_persona.branch_ids
                all_bus |= active_persona.business_unit_ids
                all_companies |= active_persona.branch_ids.mapped('company_id')
                
                if active_persona.is_branch_manager:
                    has_branch_manager = True
                if active_persona.is_bu_leader:
                    has_bu_leader = True
                if active_persona.is_cross_branch:
                    has_cross_branch = True
                if active_persona.is_matrix_administrator:
                    has_matrix_admin = True
            
            # Determine defaults (prefer this persona's defaults)
            default_branch_obj = persona.default_branch_id or (all_branches[0] if all_branches else False)
            default_company = default_branch_obj.company_id if default_branch_obj else (all_companies[0] if all_companies else False)
            default_bu = persona.default_business_unit_id or (all_bus[0] if all_bus else False)
            
            # Update user access (if user has matrix fields)
            user_vals = {}
            if hasattr(user, 'allowed_branch_ids'):
                user_vals['allowed_branch_ids'] = [(6, 0, all_companies.ids)]
            if hasattr(user, 'allowed_business_unit_ids'):
                user_vals['allowed_business_unit_ids'] = [(6, 0, all_bus.ids)]
            if hasattr(user, 'default_branch_id'):
                user_vals['default_branch_id'] = default_company.id if default_company else False
            if hasattr(user, 'default_business_unit_id'):
                user_vals['default_business_unit_id'] = default_bu.id if default_bu else False
            if hasattr(user, 'is_cross_branch_bu_leader'):
                user_vals['is_cross_branch_bu_leader'] = has_cross_branch
            
            if user_vals:
                user.write(user_vals)
            
            # Update group membership for roles
            self._sync_user_groups(user, {
                'is_branch_manager': has_branch_manager,
                'is_bu_leader': has_bu_leader,
                'is_matrix_administrator': has_matrix_admin,
            })
            
            _logger.debug(f"Synced persona {persona.name} access to user {user.name}")
    
    def _remove_user_access(self):
        """Remove persona access from user."""
        for persona in self:
            if not persona.user_id:
                continue
                
            user = persona.user_id
            
            # Check if user has other active personas
            other_active_personas = self.search([
                ('id', '!=', persona.id),
                ('user_id', '=', user.id),
                ('is_active_today', '=', True),
            ])
            
            if other_active_personas:
                # User has other personas, resync based on remaining personas
                other_active_personas._sync_user_access()
            else:
                # No other active personas, clear matrix access
                user_vals = {}
                if hasattr(user, 'allowed_branch_ids'):
                    user_vals['allowed_branch_ids'] = [(5, 0, 0)]
                if hasattr(user, 'allowed_business_unit_ids'):
                    user_vals['allowed_business_unit_ids'] = [(5, 0, 0)]
                if hasattr(user, 'default_branch_id'):
                    user_vals['default_branch_id'] = False
                if hasattr(user, 'default_business_unit_id'):
                    user_vals['default_business_unit_id'] = False
                if hasattr(user, 'is_cross_branch_bu_leader'):
                    user_vals['is_cross_branch_bu_leader'] = False
                
                if user_vals:
                    user.write(user_vals)
                
                # Clear role groups
                self._sync_user_groups(user, {
                    'is_branch_manager': False,
                    'is_bu_leader': False,
                    'is_matrix_administrator': False,
                })
    
    def _sync_user_groups(self, user, role_flags):
        """Sync user group membership based on role flags."""
        group_refs = {
            'is_branch_manager': 'ops_matrix_core.group_ops_branch_manager',
            'is_bu_leader': 'ops_matrix_core.group_ops_bu_leader',
            'is_matrix_administrator': 'ops_matrix_core.group_ops_matrix_administrator',
        }
        
        for role_field, group_ref in group_refs.items():
            try:
                group = self.env.ref(group_ref, False)
                if group:
                    if role_flags.get(role_field, False):
                        # Add to group if not already member
                        if group not in user.groups_id:
                            user.groups_id = [(4, group.id)]
                    else:
                        # Remove from group if member
                        if group in user.groups_id:
                            user.groups_id = [(3, group.id)]
            except Exception as e:
                _logger.warning(f"Failed to sync group {group_ref}: {e}")
    
    # ============================================
    # DELEGATION METHODS
    # ============================================
    
    def action_delegate_persona(self):
        """Open wizard to create a new delegation."""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('Create Delegation'),
            'res_model': 'ops.persona.delegation',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_persona_id': self.id,
                'default_delegator_id': self.user_id.id if self.user_id else False,
            }
        }
    
    def action_revoke_delegation(self):
        """Revoke active delegation."""
        self.ensure_one()
        
        active_delegation = self.env['ops.persona.delegation'].get_active_delegation_for_persona(self.id)
        
        if not active_delegation:
            raise UserError(_("No active delegation to revoke."))
        
        # Deactivate delegation
        active_delegation.write({'active': False})
        
        # Resync user access
        self._sync_user_access()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Delegation Revoked'),
                'message': _('Delegation for persona %s has been revoked.') % self.name,
                'type': 'warning',
                'sticky': False,
            }
        }
    
    def action_view_delegations(self):
        """View all delegations for this persona."""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('Delegations'),
            'res_model': 'ops.persona.delegation',
            'view_mode': 'tree,form',
            'domain': [('persona_id', '=', self.id)],
            'context': {
                'default_persona_id': self.id,
            }
        }
    
    def get_effective_user(self):
        """Helper method to get the effective user (considering delegation)."""
        self.ensure_one()
        now = fields.Datetime.now()
        
        # Check for active delegation
        active_delegation = self.env['ops.persona.delegation'].search([
            ('persona_id', '=', self.id),
            ('active', '=', True),
            ('start_date', '<=', now),
            ('end_date', '>=', now)
        ], limit=1)
        
        if active_delegation:
            return active_delegation.delegate_id
        
        return self.user_id
    
    def _get_active_user(self):
        """Legacy method - kept for backward compatibility."""
        return self.get_effective_user()
    
    @api.model
    def get_active_persona_for_user(self, user_id):
        """Find which Persona a specific User ID is currently acting as."""
        if isinstance(user_id, int):
            user_id = self.env['res.users'].browse(user_id)
        
        now = fields.Datetime.now()
        
        # 1. Check if user is a delegate for any persona
        active_delegations = self.env['ops.persona.delegation'].search([
            ('delegate_id', '=', user_id.id),
            ('active', '=', True),
            ('start_date', '<=', now),
            ('end_date', '>=', now)
        ], order='start_date desc', limit=1)
        
        if active_delegations:
            return active_delegations.persona_id
        
        # 2. Check user's own persona
        owned_personas = self.search([
            ('user_id', '=', user_id.id),
            ('active', '=', True),
            ('is_active_today', '=', True)
        ], limit=1)
        
        return owned_personas if owned_personas else self.browse()
    
    def get_active_delegation(self):
        """Get the currently active delegation for this persona, if any."""
        self.ensure_one()
        return self.env['ops.persona.delegation'].get_active_delegation_for_persona(self.id)
    
    def has_active_delegation(self):
        """Check if this persona has an active delegation."""
        self.ensure_one()
        return bool(self.get_active_delegation())
    
    # ============================================
    # BUSINESS METHODS
    # ============================================
    
    def action_view_user_access(self):
        """Open view of user's current access."""
        self.ensure_one()
        return {
            'name': _('User Access Details'),
            'type': 'ir.actions.act_window',
            'res_model': 'res.users',
            'view_mode': 'form',
            'res_id': self.user_id.id if self.user_id else False,
            'views': [(False, 'form')],
            'target': 'current',
        }
    
    def action_view_branches(self):
        """Open view of assigned branches."""
        self.ensure_one()
        return {
            'name': _('Assigned Branches'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.branch',
            'view_mode': 'tree,form',
            'domain': [('id', 'in', self.branch_ids.ids)],
            'context': {
                'search_default_active': 1,
                'default_company_id': self.company_id.id,
            }
        }
    
    def action_view_business_units(self):
        """Open view of assigned business units."""
        self.ensure_one()
        return {
            'name': _('Assigned Business Units'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.business.unit',
            'view_mode': 'tree,form',
            'domain': [('id', 'in', self.business_unit_ids.ids)],
            'context': {
                'search_default_active': 1,
                'default_company_id': self.company_id.id,
            }
        }
    
    def action_force_sync(self):
        """Force sync of persona access to user."""
        self.ensure_one()
        self._sync_user_access()
        self.last_sync_date = fields.Datetime.now()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Sync Complete'),
                'message': _('Persona access synced to user %s.') % (self.user_id.name if self.user_id else 'N/A'),
                'type': 'success',
                'sticky': False,
            }
        }
    
    def action_check_access_compliance(self):
        """Check if persona access complies with security rules."""
        self.ensure_one()
        
        issues = []
        
        # Check branch assignments
        if not self.branch_ids:
            issues.append(_("No branches assigned."))
        
        # Check BU assignments
        if not self.business_unit_ids:
            issues.append(_("No business units assigned."))
        
        # Check compatibility
        for bu in self.business_unit_ids:
            compatible_branches = bu.branch_ids & self.branch_ids
            if not compatible_branches:
                issues.append(_(
                    "Business Unit '%(bu_name)s' is not compatible with assigned branches."
                ) % {'bu_name': bu.name})
        
        # Check role assignments
        if self.is_branch_manager and len(self.branch_ids) > 1:
            issues.append(_(
                "Branch manager role assigned to multiple branches. "
                "Typically a branch manager manages only one branch."
            ))
        
        if self.is_cross_branch and not self.is_bu_leader:
            issues.append(_(
                "Cross-branch authority requires BU leader role."
            ))
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Access Compliance Check'),
                'message': '\n'.join(issues) if issues else _('No compliance issues found.'),
                'type': 'warning' if issues else 'success',
                'sticky': True,
            }
        }
    
    # ============================================
    # CRON/SCHEDULED ACTIONS
    # ============================================
    
    @api.model
    def cron_sync_all_personas(self):
        """Scheduled job to sync all active personas."""
        active_personas = self.search([('is_active_today', '=', True)])
        
        synced_count = 0
        for persona in active_personas:
            try:
                persona._sync_user_access()
                persona.last_sync_date = fields.Datetime.now()
                synced_count += 1
            except Exception as e:
                _logger.error(f"Failed to sync persona {persona.id}: {e}")
                persona.message_post(
                    body=_('Auto-sync failed: %s') % str(e),
                    subject=_('Sync Error')
                )
        
        _logger.info(f"Auto-synced {synced_count} personas out of {len(active_personas)}")
    
    @api.model
    def cron_check_delegation_expiry(self):
        """Check for expired delegations and revoke them."""
        now = fields.Datetime.now()
        
        # Find expired delegations
        expired_delegations = self.env['ops.persona.delegation'].search([
            ('active', '=', True),
            ('end_date', '!=', False),
            ('end_date', '<=', now),
        ])
        
        for delegation in expired_delegations:
            try:
                delegation.write({'active': False})
                delegation.persona_id._sync_user_access()
                _logger.info(f"Auto-revoked expired delegation {delegation.id} for persona {delegation.persona_id.id}")
            except Exception as e:
                _logger.error(f"Failed to auto-revoke delegation {delegation.id}: {e}")

--- ops_matrix_core/models/ops_persona_delegation.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from datetime import datetime

class OpsPersonaDelegation(models.Model):
    """Model to track persona delegation history."""
    _name = 'ops.persona.delegation'
    _description = 'OPS Persona Delegation History'
    _order = 'create_date desc'
    _rec_name = 'display_name'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    
    # ============================================
    # BASIC INFORMATION
    # ============================================
    persona_id = fields.Many2one(
        'ops.persona',
        string='Persona',
        required=True,
        ondelete='cascade',
        tracking=True,
        help="The persona being delegated"
    )
    
    delegator_id = fields.Many2one(
        'res.users',
        string='Delegator',
        required=True,
        tracking=True,
        help='User who delegated the persona'
    )
    
    delegate_id = fields.Many2one(
        'res.users',
        string='Delegate',
        required=True,
        tracking=True,
        help='User who received the delegation'
    )
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        related='persona_id.company_id',
        store=True,
        readonly=True,
        help='Company from the persona'
    )
    
    # ============================================
    # DATE RANGE
    # ============================================
    start_date = fields.Datetime(
        string='Start Date',
        required=True,
        default=fields.Datetime.now,
        tracking=True,
        help="When the delegation becomes active"
    )
    
    end_date = fields.Datetime(
        string='End Date',
        required=True,
        tracking=True,
        help="When the delegation expires"
    )
    
    revoked_date = fields.Datetime(
        string='Revoked Date',
        tracking=True,
        help='When delegation was manually revoked'
    )
    
    # ============================================
    # STATUS
    # ============================================
    active = fields.Boolean(
        string='Active',
        default=True,
        tracking=True,
        help="Set to False to cancel the delegation"
    )
    
    state = fields.Selection([
        ('draft', 'Draft'),
        ('pending', 'Pending'),
        ('active', 'Active'),
        ('expired', 'Expired'),
        ('revoked', 'Revoked'),
        ('cancelled', 'Cancelled'),
    ], string='Status', compute='_compute_state', store=True, tracking=True)
    
    # ============================================
    # DETAILS
    # ============================================
    reason = fields.Text(
        string='Reason for Delegation',
        tracking=True,
        help='Why this delegation was created (e.g., vacation, training)'
    )
    
    notes = fields.Text(
        string='Additional Notes',
        help='Additional notes about the delegation'
    )
    
    # ============================================
    # COMPUTED FIELDS
    # ============================================
    display_name = fields.Char(
        compute='_compute_display_name',
        string='Display Name',
        store=True
    )
    
    duration_days = fields.Integer(
        compute='_compute_duration',
        string='Duration (Days)',
        store=True,
        help='Total delegation duration in days'
    )
    
    is_current = fields.Boolean(
        string='Is Currently Active',
        compute='_compute_is_current',
        store=True,
        help="True if this delegation is currently in effect"
    )
    
    remaining_days = fields.Integer(
        compute='_compute_remaining_days',
        string='Remaining Days',
        help='Days remaining until delegation expires'
    )
    
    # ============================================
    # ADDITIONAL TRACKING FIELDS
    # ============================================
    approval_required = fields.Boolean(
        string='Approval Required',
        default=False,
        help='Whether this delegation requires approval'
    )
    
    approved_by = fields.Many2one(
        'res.users',
        string='Approved By',
        tracking=True,
        help='User who approved the delegation'
    )
    
    approval_date = fields.Datetime(
        string='Approval Date',
        tracking=True,
        help='When the delegation was approved'
    )
    
    # Audit fields
    create_uid = fields.Many2one(
        'res.users',
        string='Created By',
        readonly=True
    )
    
    create_date = fields.Datetime(
        string='Created On',
        readonly=True
    )
    
    write_uid = fields.Many2one(
        'res.users',
        string='Last Updated By',
        readonly=True
    )
    
    write_date = fields.Datetime(
        string='Last Updated On',
        readonly=True
    )
    
    # ============================================
    # COMPUTED METHODS
    # ============================================
    
    @api.depends('delegator_id', 'delegate_id', 'start_date', 'persona_id')
    def _compute_display_name(self):
        """Compute display name for delegation record."""
        for record in self:
            if record.delegator_id and record.delegate_id:
                record.display_name = _("%(delegator)s â†’ %(delegate)s (%(persona)s)") % {
                    'delegator': record.delegator_id.name,
                    'delegate': record.delegate_id.name,
                    'persona': record.persona_id.name if record.persona_id else _('N/A')
                }
            else:
                record.display_name = _('Delegation #%s') % record.id
    
    @api.depends('start_date', 'end_date')
    def _compute_duration(self):
        """Calculate delegation duration in days."""
        for record in self:
            if record.start_date and record.end_date:
                delta = record.end_date - record.start_date
                record.duration_days = delta.days
            else:
                record.duration_days = 0
    
    @api.depends('start_date', 'end_date', 'active', 'state')
    def _compute_is_current(self):
        """Check if delegation is currently in effect."""
        now = fields.Datetime.now()
        for record in self:
            record.is_current = (
                record.active and
                record.start_date and
                record.end_date and
                record.start_date <= now <= record.end_date
            )
    
    @api.depends('end_date')
    def _compute_remaining_days(self):
        """Calculate remaining days until delegation expires."""
        now = fields.Datetime.now()
        for record in self:
            if record.end_date and record.is_current:
                delta = record.end_date - now
                record.remaining_days = max(0, delta.days)
            else:
                record.remaining_days = 0
    
    @api.depends('start_date', 'end_date', 'active', 'revoked_date')
    def _compute_state(self):
        """Compute the delegation state based on dates and active flag."""
        now = fields.Datetime.now()
        for record in self:
            if record.revoked_date:
                record.state = 'revoked'
            elif not record.active:
                record.state = 'cancelled'
            elif not record.start_date or not record.end_date:
                record.state = 'draft'
            elif record.end_date < now:
                record.state = 'expired'
            elif record.start_date <= now <= record.end_date:
                record.state = 'active'
            elif record.start_date > now:
                record.state = 'pending'
            else:
                record.state = 'draft'
    
    # ============================================
    # CONSTRAINTS & VALIDATION
    # ============================================
    
    @api.constrains('delegator_id', 'delegate_id')
    def _check_self_delegation(self):
        """Prevent delegating to yourself."""
        for record in self:
            if record.delegator_id and record.delegator_id == record.delegate_id:
                raise ValidationError(_("You cannot delegate to yourself."))
    
    @api.constrains('start_date', 'end_date')
    def _check_dates(self):
        """Validate date range."""
        for record in self:
            if record.start_date and record.end_date:
                if record.end_date <= record.start_date:
                    raise ValidationError(_("End date must be after start date."))
    
    @api.constrains('persona_id', 'start_date', 'end_date', 'active')
    def _check_overlapping_delegations(self):
        """Prevent overlapping delegations for the same persona."""
        for record in self:
            if not record.active or not record.start_date or not record.end_date:
                continue
                
            overlapping = self.search([
                ('id', '!=', record.id),
                ('persona_id', '=', record.persona_id.id),
                ('active', '=', True),
                ('start_date', '<=', record.end_date),
                ('end_date', '>=', record.start_date)
            ])
            
            if overlapping:
                raise ValidationError(_(
                    "This delegation overlaps with another active delegation for the same persona. "
                    "Please adjust the dates or cancel the conflicting delegation."
                ))
    
    @api.constrains('persona_id', 'delegate_id')
    def _check_delegate_capabilities(self):
        """Validate that delegate has sufficient capabilities."""
        for record in self:
            if not record.persona_id or not record.delegate_id:
                continue
            
            # Ensure delegate is an active user
            if not record.delegate_id.active:
                raise ValidationError(_(
                    "Cannot delegate to an inactive user."
                ))
            
            # Ensure the persona allows delegation
            persona = record.persona_id
            if not persona.can_be_delegated:
                raise ValidationError(_(
                    "The persona '%s' does not allow delegation."
                ) % persona.name)
    
    # ============================================
    # CRUD METHODS
    # ============================================
    
    @api.model_create_multi
    def create(self, vals_list):
        """Override create to log delegation creation."""
        delegations = super().create(vals_list)
        
        for delegation in delegations:
            # Send notification to delegate
            delegation._notify_delegation_created()
            
            # Log creation
            delegation.message_post(
                body=_('Delegation created: %(delegator)s delegated persona %(persona)s to %(delegate)s.') % {
                    'delegator': delegation.delegator_id.name,
                    'persona': delegation.persona_id.name,
                    'delegate': delegation.delegate_id.name
                }
            )
        
        return delegations
    
    def write(self, vals):
        """Override write to track changes."""
        result = super().write(vals)
        
        # If dates changed, log it
        if 'start_date' in vals or 'end_date' in vals:
            for delegation in self:
                delegation.message_post(
                    body=_('Delegation dates updated.')
                )
        
        # If revoked, notify
        if 'active' in vals and not vals['active']:
            for delegation in self:
                delegation.write({'revoked_date': fields.Datetime.now()})
                delegation._notify_delegation_revoked()
        
        return result
    
    # ============================================
    # BUSINESS METHODS
    # ============================================
    
    def action_activate(self):
        """Manually activate a delegation."""
        self.ensure_one()
        self.write({'active': True, 'revoked_date': False})
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Delegation Activated'),
                'message': _('Delegation has been activated.'),
                'type': 'success',
            }
        }
    
    def action_cancel(self):
        """Cancel a delegation."""
        self.ensure_one()
        self.write({'active': False, 'revoked_date': fields.Datetime.now()})
        
        # Notify both parties
        self._notify_delegation_revoked()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Delegation Cancelled'),
                'message': _('Delegation has been cancelled.'),
                'type': 'warning',
            }
        }
    
    def action_extend(self):
        """Open wizard to extend delegation end date."""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'name': _('Extend Delegation'),
            'res_model': 'ops.persona.delegation',
            'view_mode': 'form',
            'res_id': self.id,
            'target': 'new',
            'context': {
                'default_end_date': self.end_date,
            }
        }
    
    def action_approve(self):
        """Approve the delegation."""
        self.ensure_one()
        self.write({
            'approved_by': self.env.user.id,
            'approval_date': fields.Datetime.now(),
        })
        
        self.message_post(
            body=_('Delegation approved by %s.') % self.env.user.name
        )
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Delegation Approved'),
                'message': _('Delegation has been approved.'),
                'type': 'success',
            }
        }
    
    def action_view_persona(self):
        """Open the associated persona."""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'res_model': 'ops.persona',
            'view_mode': 'form',
            'res_id': self.persona_id.id,
            'target': 'current',
        }
    
    def action_view_delegate(self):
        """Open the delegate user."""
        self.ensure_one()
        return {
            'type': 'ir.actions.act_window',
            'res_model': 'res.users',
            'view_mode': 'form',
            'res_id': self.delegate_id.id,
            'target': 'current',
        }
    
    # ============================================
    # UTILITY METHODS
    # ============================================
    
    @api.model
    def get_active_delegation_for_persona(self, persona_id):
        """Get the currently active delegation for a persona, if any."""
        now = fields.Datetime.now()
        return self.search([
            ('persona_id', '=', persona_id),
            ('active', '=', True),
            ('start_date', '<=', now),
            ('end_date', '>=', now)
        ], limit=1)
    
    @api.model
    def get_delegations_for_user(self, user_id, only_active=True):
        """Get all delegations where the user is the delegate."""
        domain = [('delegate_id', '=', user_id)]
        if only_active:
            now = fields.Datetime.now()
            domain += [
                ('active', '=', True),
                ('start_date', '<=', now),
                ('end_date', '>=', now)
            ]
        return self.search(domain)
    
    @api.model
    def get_expiring_delegations(self, days=7):
        """Get delegations expiring within specified days."""
        now = fields.Datetime.now()
        end_date = now + timedelta(days=days)
        
        return self.search([
            ('active', '=', True),
            ('end_date', '>=', now),
            ('end_date', '<=', end_date)
        ])
    
    # ============================================
    # NOTIFICATION METHODS
    # ============================================
    
    def _notify_delegation_created(self):
        """Send notification when delegation is created."""
        self.ensure_one()
        
        # Notify delegator
        if self.delegator_id:
            self.message_post(
                body=_('Persona %(persona)s delegated to %(delegate)s from %(start)s to %(end)s.') % {
                    'persona': self.persona_id.name,
                    'delegate': self.delegate_id.name,
                    'start': self.start_date,
                    'end': self.end_date
                },
                partner_ids=[self.delegator_id.partner_id.id],
                subject=_('Persona Delegation Created')
            )
        
        # Notify delegate
        if self.delegate_id:
            self.message_post(
                body=_(
                    'You have been delegated persona %(persona)s by %(delegator)s. '
                    'Effective: %(start)s to %(end)s. Reason: %(reason)s'
                ) % {
                    'persona': self.persona_id.name,
                    'delegator': self.delegator_id.name,
                    'start': self.start_date,
                    'end': self.end_date,
                    'reason': self.reason or _('No reason provided')
                },
                partner_ids=[self.delegate_id.partner_id.id],
                subject=_('Persona Delegation Assignment')
            )
    
    def _notify_delegation_revoked(self):
        """Send notification when delegation is revoked."""
        self.ensure_one()
        
        # Notify both parties
        partner_ids = []
        if self.delegator_id:
            partner_ids.append(self.delegator_id.partner_id.id)
        if self.delegate_id:
            partner_ids.append(self.delegate_id.partner_id.id)
        
        if partner_ids:
            self.message_post(
                body=_('Delegation for persona %(persona)s has been revoked.') % {
                    'persona': self.persona_id.name
                },
                partner_ids=partner_ids,
                subject=_('Delegation Revoked')
            )
    
    def _notify_delegation_expiring(self):
        """Send notification when delegation is about to expire."""
        self.ensure_one()
        
        partner_ids = []
        if self.delegator_id:
            partner_ids.append(self.delegator_id.partner_id.id)
        if self.delegate_id:
            partner_ids.append(self.delegate_id.partner_id.id)
        
        if partner_ids:
            self.message_post(
                body=_('Delegation for persona %(persona)s expires on %(end_date)s (%(days)d days remaining).') % {
                    'persona': self.persona_id.name,
                    'end_date': self.end_date,
                    'days': self.remaining_days
                },
                partner_ids=partner_ids,
                subject=_('Delegation Expiring Soon')
            )
    
    # ============================================
    # SCHEDULED ACTIONS
    # ============================================
    
    @api.model
    def cron_check_expiring_delegations(self):
        """Notify users of delegations expiring soon."""
        expiring_delegations = self.get_expiring_delegations(days=3)
        
        for delegation in expiring_delegations:
            try:
                delegation._notify_delegation_expiring()
            except Exception as e:
                _logger.error(f"Failed to notify expiring delegation {delegation.id}: {e}")
    
    @api.model
    def cron_expire_delegations(self):
        """Deactivate expired delegations."""
        now = fields.Datetime.now()
        
        expired_delegations = self.search([
            ('active', '=', True),
            ('end_date', '!=', False),
            ('end_date', '<', now),
        ])
        
        for delegation in expired_delegations:
            try:
                delegation.write({
                    'active': False,
                    'state': 'expired'
                })
                _logger.info(f"Auto-expired delegation {delegation.id}")
            except Exception as e:
                _logger.error(f"Failed to expire delegation {delegation.id}: {e}")

--- ops_matrix_core/models/ops_product_request.py ---
from odoo import _, models, fields, api
from odoo.exceptions import ValidationError, UserError
from datetime import datetime
from typing import List, Dict, Any

class OpsProductRequest(models.Model):
    _name = 'ops.product.request'
    _description = 'Product Request - Request Products for Procurement'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'id DESC'
    _check_company_auto = True
    
    # Basic Fields
    name = fields.Char(
        string='Request Number',
        required=True,
        copy=False,
        readonly=True,
        default='New'
    )
    code = fields.Char(
        string='Request Code',
        copy=False
    )
    description = fields.Text(
        string='Description',
        help='Additional details about the product request'
    )
    
    # Request Metadata
    request_date = fields.Datetime(
        string='Request Date',
        default=lambda self: fields.Datetime.now(),
        readonly=True
    )
    requester_id = fields.Many2one(
        'res.users',
        string='Requested By',
        default=lambda self: self.env.user,
        readonly=True,
        tracking=True
    )
    
    # Product Information
    product_id = fields.Many2one(
        'product.product',
        string='Product',
        required=True,
        help='The product being requested',
        tracking=True
    )
    part_number = fields.Char(
        string='Part Number',
        related='product_id.default_code',
        readonly=True,
        store=True
    )
    quantity = fields.Float(
        string='Quantity Requested',
        required=True,
        default=1.0,
        tracking=True
    )
    uom_id = fields.Many2one(
        'uom.uom',
        string='Unit of Measure',
        related='product_id.uom_id',
        readonly=True,
        store=False
    )
    
    # Scheduling
    required_date = fields.Date(
        string='Required By Date',
        required=True,
        help='Date when the product is needed'
    )
    priority = fields.Selection([
        ('low', 'Low'),
        ('normal', 'Normal'),
        ('high', 'High'),
        ('urgent', 'Urgent')
    ], string='Priority', default='normal', tracking=True)
    
    # Organization & Access Control
    branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=True,
        help='Branch requesting the product'
    )
    business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        help='Business Unit for the request'
    )
    
    # Status & Workflow
    state = fields.Selection([
        ('draft', 'Draft'),
        ('submitted', 'Submitted'),
        ('approved', 'Approved'),
        ('in_progress', 'In Progress'),
        ('received', 'Received'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', tracking=True, index=True)
    
    # Approval Chain
    approver_ids = fields.Many2many(
        'res.users',
        'product_request_approver_rel',
        'request_id',
        'user_id',
        string='Approvers'
    )
    approval_notes = fields.Text(
        string='Approval Notes',
        help='Notes from the approval process'
    )
    
    # Linked Records
    purchase_order_line_id = fields.Many2one(
        'purchase.order.line',
        string='Purchase Order Line',
        readonly=True,
        help='Linked purchase order line if created'
    )
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company,
        index=True
    )
    
    # Constraints
    @api.constrains('quantity', 'required_date')
    def _check_request_validity(self) -> None:
        """Validate quantity and required date"""
        for record in self:
            if record.quantity <= 0:
                raise ValidationError(_('Quantity must be greater than 0'))
            
            if record.required_date < fields.Date.today():
                raise ValidationError(_('Required date cannot be in the past'))
    
    # CRUD Methods
    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'OpsProductRequest':
        """Generate request number on creation"""
        for vals in vals_list:
            if vals.get('name', 'New') == 'New':
                vals['name'] = self.env['ir.sequence'].next_by_code('ops.product.request') or 'REQ0001'
        
        return super().create(vals_list)
     
    # Workflow State Transitions
    def action_submit(self) -> bool:
        """Submit the product request for approval"""
        for record in self:
            if record.state != 'draft':
                raise UserError(_('Only draft requests can be submitted'))
            record.write({'state': 'submitted'})
            record.message_post(body='Product request submitted for approval')
        return True
    
    def action_approve(self) -> bool:
        """Approve the product request"""
        for record in self:
            if record.state != 'submitted':
                raise UserError(_('Only submitted requests can be approved'))
            record.write({'state': 'approved'})
            record.message_post(body='Product request approved')
        return True
    
    def action_start(self) -> bool:
        """Mark request as in progress"""
        for record in self:
            if record.state not in ['approved', 'submitted']:
                raise UserError(_('Request must be approved before starting'))
            record.write({'state': 'in_progress'})
            record.message_post(body='Product request marked as in progress')
        return True
    
    def action_receive(self) -> bool:
        """Mark request as received"""
        for record in self:
            if record.state != 'in_progress':
                raise UserError(_('Request must be in progress before marking as received'))
            record.write({'state': 'received'})
            record.message_post(body='Product received')
        return True
    
    def action_cancel(self) -> bool:
        """Cancel the product request"""
        for record in self:
            if record.state == 'received':
                raise UserError(_('Cannot cancel a received request'))
            record.write({'state': 'cancelled'})
            record.message_post(body='Product request cancelled')
        return True
    
    def action_reset_to_draft(self) -> bool:
        """Reset request back to draft state"""
        for record in self:
            if record.state == 'received':
                raise UserError(_('Cannot reset a received request'))
            record.write({'state': 'draft'})
            record.message_post(body='Product request reset to draft')
        return True
    
    # Helper Methods
    def _assign_default_approvers(self) -> None:
        """Assign approvers based on branch manager or business unit lead"""
        for record in self:
            approvers = set()
            
            # Add branch manager if assigned
            if record.branch_id.manager_id:
                approvers.add(record.branch_id.manager_id.id)
            
            # Add business unit lead if assigned
            if record.business_unit_id:
                # Try to find business unit lead (would need to be added to ops.business_unit)
                pass
            
            if approvers:
                record.write({'approver_ids': [(6, 0, list(approvers))]})
     
    @api.onchange('branch_id')
    def _onchange_branch_id(self) -> None:
        """Set business unit based on branch if applicable"""
        # Could auto-set business unit if branch has a primary unit
        pass
     
    @api.onchange('product_id')
    def _onchange_product_id(self) -> None:
        """Update product details when product changes"""
        if self.product_id:
            self.uom_id = self.product_id.uom_id.id
            # Auto-set business unit from product if product has silo assignment
            if self.product_id.business_unit_id:
                self.business_unit_id = self.product_id.business_unit_id.id

--- ops_matrix_core/models/ops_security_audit.py ---
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)

class OpsSecurityAudit(models.Model):
    """Log security-related events for audit purposes."""
    _name = 'ops.security.audit'
    _description = 'OPS Security Audit Log'
    _order = 'timestamp desc'
    _rec_name = 'event_type'
    
    # ========================================================================
    # FIELDS
    # ========================================================================
    
    timestamp = fields.Datetime(
        string='Timestamp',
        default=fields.Datetime.now,
        required=True,
        readonly=True
    )
    
    user_id = fields.Many2one(
        'res.users',
        string='User',
        required=True,
        readonly=True,
        ondelete='restrict'
    )
    
    event_type = fields.Selection([
        ('access_denied', 'Access Denied'),
        ('rule_violation', 'Rule Violation'),
        ('matrix_change', 'Matrix Access Change'),
        ('delegation_change', 'Delegation Change'),
        ('override_used', 'Security Override Used'),
        ('login_attempt', 'Login Attempt'),
        ('permission_escalation', 'Permission Escalation'),
    ], string='Event Type', required=True, readonly=True)
    
    model_name = fields.Char(
        string='Model',
        readonly=True
    )
    
    record_id = fields.Integer(
        string='Record ID',
        readonly=True
    )
    
    record_name = fields.Char(
        string='Record Name',
        readonly=True
    )
    
    details = fields.Text(
        string='Event Details',
        readonly=True
    )
    
    ip_address = fields.Char(
        string='IP Address',
        readonly=True
    )
    
    session_id = fields.Char(
        string='Session ID',
        readonly=True
    )
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        readonly=True
    )
    
    branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        readonly=True
    )
    
    business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        readonly=True
    )
    
    severity = fields.Selection([
        ('info', 'Information'),
        ('warning', 'Warning'),
        ('critical', 'Critical'),
    ], string='Severity', default='info', readonly=True)
    
    # ========================================================================
    # LOGGING METHODS
    # ========================================================================
    
    @api.model
    def log_access_denied(self, model_name, record_id, details=None):
        """Log when access is denied to a record."""
        try:
            record = self.env[model_name].sudo().browse(record_id)
            record_name = record.display_name if record.exists() else f"ID: {record_id}"
            
            self.sudo().create({
                'user_id': self.env.user.id,
                'event_type': 'access_denied',
                'model_name': model_name,
                'record_id': record_id,
                'record_name': record_name,
                'details': details or f"Access denied to {model_name} {record_name}",
                'ip_address': self._get_client_ip(),
                'session_id': self._get_session_id(),
                'company_id': self.env.company.id,
                'severity': 'warning',
            })
            
            _logger.warning(
                f"Access denied: User {self.env.user.name} (ID: {self.env.user.id}) "
                f"attempted to access {model_name} {record_name}"
            )
        except Exception as e:
            _logger.error(f"Failed to log access denial: {str(e)}")
    
    @api.model
    def log_matrix_change(self, target_user_id, details=None):
        """Log when matrix access rights change for a user."""
        try:
            target_user = self.env['res.users'].sudo().browse(target_user_id)
            
            self.sudo().create({
                'user_id': self.env.user.id,
                'event_type': 'matrix_change',
                'model_name': 'res.users',
                'record_id': target_user_id,
                'record_name': target_user.name,
                'details': details or f"Matrix access changed for user {target_user.name}",
                'ip_address': self._get_client_ip(),
                'session_id': self._get_session_id(),
                'company_id': self.env.company.id,
                'severity': 'info',
            })
            
            _logger.info(
                f"Matrix change: User {self.env.user.name} modified access for {target_user.name}"
            )
        except Exception as e:
            _logger.error(f"Failed to log matrix change: {str(e)}")
    
    @api.model
    def log_delegation_change(self, delegation_id, action, details=None):
        """Log delegation creation, modification, or deletion."""
        try:
            delegation = self.env['ops.persona.delegation'].sudo().browse(delegation_id)
            
            self.sudo().create({
                'user_id': self.env.user.id,
                'event_type': 'delegation_change',
                'model_name': 'ops.persona.delegation',
                'record_id': delegation_id,
                'record_name': delegation.display_name if delegation.exists() else f"ID: {delegation_id}",
                'details': details or f"Delegation {action}: {delegation.display_name}",
                'ip_address': self._get_client_ip(),
                'session_id': self._get_session_id(),
                'company_id': self.env.company.id,
                'severity': 'info',
            })
            
            _logger.info(
                f"Delegation {action}: User {self.env.user.name} performed {action} on delegation {delegation_id}"
            )
        except Exception as e:
            _logger.error(f"Failed to log delegation change: {str(e)}")
    
    @api.model
    def log_security_override(self, model_name, record_id, reason):
        """Log when a security override is used."""
        try:
            record = self.env[model_name].sudo().browse(record_id)
            
            self.sudo().create({
                'user_id': self.env.user.id,
                'event_type': 'override_used',
                'model_name': model_name,
                'record_id': record_id,
                'record_name': record.display_name if record.exists() else f"ID: {record_id}",
                'details': f"Security override used: {reason}",
                'ip_address': self._get_client_ip(),
                'session_id': self._get_session_id(),
                'company_id': self.env.company.id,
                'severity': 'critical',
            })
            
            _logger.warning(
                f"Security override: User {self.env.user.name} used override on {model_name} {record_id}"
            )
        except Exception as e:
            _logger.error(f"Failed to log security override: {str(e)}")
    
    @api.model
    def log_rule_violation(self, rule_name, details):
        """Log when a security rule is violated."""
        try:
            self.sudo().create({
                'user_id': self.env.user.id,
                'event_type': 'rule_violation',
                'details': f"Rule violation: {rule_name} - {details}",
                'ip_address': self._get_client_ip(),
                'session_id': self._get_session_id(),
                'company_id': self.env.company.id,
                'severity': 'critical',
            })
            
            _logger.error(
                f"Rule violation: User {self.env.user.name} violated rule {rule_name}"
            )
        except Exception as e:
            _logger.error(f"Failed to log rule violation: {str(e)}")
    
    # ========================================================================
    # HELPER METHODS
    # ========================================================================
    
    @api.model
    def _get_client_ip(self):
        """Get client IP address from context or request."""
        # Try to get from context
        ip = self.env.context.get('remote_addr', 'Unknown')
        
        # Try to get from HTTP request
        try:
            from odoo.http import request
            if request and hasattr(request, 'httprequest'):
                ip = request.httprequest.environ.get('REMOTE_ADDR', ip)
        except:
            pass
        
        return ip
    
    @api.model
    def _get_session_id(self):
        """Get session ID from context or request."""
        # Try to get from HTTP request
        try:
            from odoo.http import request
            if request and hasattr(request, 'session'):
                return request.session.sid
        except:
            pass
        
        return 'CLI'
    
    # ========================================================================
    # REPORTING METHODS
    # ========================================================================
    
    @api.model
    def get_access_denied_summary(self, days=30):
        """Get summary of access denials in last N days."""
        date_from = fields.Datetime.now() - fields.timedelta(days=days)
        
        denials = self.search([
            ('event_type', '=', 'access_denied'),
            ('timestamp', '>=', date_from)
        ])
        
        summary = {
            'total': len(denials),
            'by_user': {},
            'by_model': {},
            'by_day': {},
        }
        
        for denial in denials:
            # By user
            user_name = denial.user_id.name
            summary['by_user'][user_name] = summary['by_user'].get(user_name, 0) + 1
            
            # By model
            model = denial.model_name or 'Unknown'
            summary['by_model'][model] = summary['by_model'].get(model, 0) + 1
            
            # By day
            day = denial.timestamp.date().isoformat()
            summary['by_day'][day] = summary['by_day'].get(day, 0) + 1
        
        return summary
    
    @api.model
    def get_critical_events(self, days=7):
        """Get critical security events in last N days."""
        date_from = fields.Datetime.now() - fields.timedelta(days=days)
        
        return self.search([
            ('severity', '=', 'critical'),
            ('timestamp', '>=', date_from)
        ], order='timestamp desc')
    
    @api.model
    def cleanup_old_logs(self, days=90):
        """Clean up audit logs older than N days."""
        date_threshold = fields.Datetime.now() - fields.timedelta(days=days)
        
        old_logs = self.search([
            ('timestamp', '<', date_threshold),
            ('severity', '!=', 'critical')  # Keep critical logs
        ])
        
        count = len(old_logs)
        # Use context flag to allow unlink during cleanup
        old_logs.with_context(audit_cleanup_mode=True).unlink()
        
        _logger.info(f"Cleaned up {count} old security audit logs")
        return count
    
    # ========================================================================
    # IMMUTABILITY ENFORCEMENT
    # ========================================================================
    
    def write(self, vals):
        """Override write to make audit logs immutable."""
        raise UserError(_("Audit log entries cannot be modified after creation."))
    
    def unlink(self):
        """Override unlink to make audit logs immutable except via cleanup."""
        # Allow unlinking only when called from cleanup_old_logs method
        # Check if we're in the cleanup context
        if not self.env.context.get('audit_cleanup_mode'):
            raise UserError(_("Audit log entries cannot be deleted manually. Use the automated cleanup process."))
        return super(OpsSecurityAudit, self).unlink()

--- ops_matrix_core/models/ops_security_rules.py ---
from odoo import models, fields, api, _
from odoo.exceptions import AccessError
import logging

_logger = logging.getLogger(__name__)

class OpsSecurityRules(models.AbstractModel):
    """Additional security logic for complex matrix rules."""
    _name = 'ops.security.rules'
    _description = 'OPS Security Rule Engine'
    
    @api.model
    def _check_record_access(self, model_name, record_id, operation='read'):
        """
        Check if current user can access a specific record.
        Used for custom security checks beyond standard rules.
        
        Args:
            model_name: Name of the model
            record_id: ID of the record
            operation: Operation type ('read', 'write', 'create', 'unlink')
            
        Returns:
            bool: True if access allowed
        """
        user = self.env.user
        
        # System administrators bypass all checks
        if user.has_group('base.group_system'):
            return True
        
        # Get the record
        record = self.env[model_name].browse(record_id)
        if not record.exists():
            return False
        
        # Model-specific checks
        if model_name == 'sale.order':
            # Check branch and BU access
            if record.ops_branch_id and record.ops_business_unit_id:
                branch_access = user.can_access_branch(record.ops_branch_id.id)
                bu_access = user.can_access_business_unit(record.ops_business_unit_id.id)
                return branch_access and bu_access
            return True  # Legacy records
        
        elif model_name == 'account.move':
            # Similar check for invoices
            if record.move_type in ['out_invoice', 'in_invoice', 'out_refund', 'in_refund']:
                if record.ops_branch_id and record.ops_business_unit_id:
                    branch_access = user.can_access_branch(record.ops_branch_id.id)
                    bu_access = user.can_access_business_unit(record.ops_business_unit_id.id)
                    return branch_access and bu_access
            return True
        
        elif model_name == 'stock.picking':
            # Check branch access
            if record.ops_branch_id:
                return user.can_access_branch(record.ops_branch_id.id)
            return True
        
        elif model_name == 'purchase.order':
            # Check branch and BU access
            if record.ops_branch_id and record.ops_business_unit_id:
                branch_access = user.can_access_branch(record.ops_branch_id.id)
                bu_access = user.can_access_business_unit(record.ops_business_unit_id.id)
                return branch_access and bu_access
            return True
        
        # Default: use standard rules
        return True
    
    @api.model
    def _get_accessible_records(self, model_name, domain=None):
        """
        Get records accessible to current user.
        Used for reports and dashboards.
        
        Args:
            model_name: Name of the model
            domain: Optional additional domain filter
            
        Returns:
            RecordSet: Accessible records
        """
        user = self.env.user
        
        # System administrators see everything
        if user.has_group('base.group_system'):
            return self.env[model_name].search(domain or [])
        
        # Apply matrix filters
        accessible_domain = self._get_matrix_domain(model_name)
        if domain:
            accessible_domain = ['&'] + accessible_domain + domain
        
        return self.env[model_name].search(accessible_domain)
    
    @api.model
    def _get_matrix_domain(self, model_name):
        """
        Generate domain for matrix access based on model.
        
        Args:
            model_name: Name of the model
            
        Returns:
            list: Domain filter for matrix access
        """
        user = self.env.user
        
        if model_name == 'sale.order':
            return ['|', '|',
                ('ops_branch_id', '=', False),
                ('company_id', 'in', user.company_ids.ids),
                '&',
                    ('ops_branch_id', 'in', user.ops_allowed_branch_ids.ids),
                    ('ops_business_unit_id', 'in', user.ops_allowed_business_unit_ids.ids)
            ]
        
        elif model_name == 'account.move':
            return ['|', '|', '|',
                ('ops_branch_id', '=', False),
                ('company_id', 'in', user.company_ids.ids),
                ('move_type', 'not in', ['out_invoice', 'in_invoice', 'out_refund', 'in_refund']),
                '&',
                    ('ops_branch_id', 'in', user.ops_allowed_branch_ids.ids),
                    ('ops_business_unit_id', 'in', user.ops_allowed_business_unit_ids.ids)
            ]
        
        elif model_name == 'stock.picking':
            return ['|', '|',
                ('ops_branch_id', '=', False),
                ('company_id', 'in', user.company_ids.ids),
                ('ops_branch_id', 'in', user.ops_allowed_branch_ids.ids)
            ]
        
        elif model_name == 'purchase.order':
            return ['|', '|',
                ('ops_branch_id', '=', False),
                ('company_id', 'in', user.company_ids.ids),
                '&',
                    ('ops_branch_id', 'in', user.ops_allowed_branch_ids.ids),
                    ('ops_business_unit_id', 'in', user.ops_allowed_business_unit_ids.ids)
            ]
        
        elif model_name == 'ops.business.unit':
            return [('id', 'in', user.ops_allowed_business_unit_ids.ids)]
        
        # Default: company restriction only
        return [('company_id', 'in', user.company_ids.ids)]
    
    @api.model
    def check_matrix_access_raise(self, model_name, record_id, operation='read'):
        """
        Check access and raise AccessError if denied.
        
        Args:
            model_name: Name of the model
            record_id: ID of the record
            operation: Operation type
            
        Raises:
            AccessError: If access is denied
        """
        if not self._check_record_access(model_name, record_id, operation):
            # Log the denial
            audit_model = self.env['ops.security.audit'].sudo()
            record = self.env[model_name].sudo().browse(record_id)
            
            audit_model.log_access_denied(
                model_name,
                record_id,
                f"User {self.env.user.name} denied {operation} access to {record.display_name}"
            )
            
            raise AccessError(_(
                "You do not have permission to %(operation)s this %(model)s record. "
                "Contact your administrator for matrix access rights."
            ) % {
                'operation': operation,
                'model': model_name
            })
    
    @api.model
    def get_user_accessible_branches(self):
        """Get branches accessible to current user."""
        user = self.env.user
        
        if user.has_group('base.group_system'):
            return self.env['res.company'].search([])
        
        return user.ops_allowed_branch_ids
    
    @api.model
    def get_user_accessible_business_units(self):
        """Get business units accessible to current user."""
        user = self.env.user
        
        if user.has_group('base.group_system'):
            return self.env['ops.business.unit'].search([])
        
        return user.ops_allowed_business_unit_ids
    
    @api.model
    def get_matrix_access_summary(self):
        """
        Get a summary of current user's matrix access.
        
        Returns:
            dict: Summary of access rights
        """
        user = self.env.user
        
        return {
            'user_id': user.id,
            'user_name': user.name,
            'is_system_admin': user.has_group('base.group_system'),
            'is_matrix_admin': user.is_matrix_administrator,
            'is_cross_branch_leader': user.is_cross_branch_bu_leader,
            'allowed_branches': user.ops_allowed_branch_ids.ids,
            'allowed_business_units': user.ops_allowed_business_unit_ids.ids,
            'branch_count': len(user.ops_allowed_branch_ids),
            'bu_count': len(user.ops_allowed_business_unit_ids),
            'companies': user.company_ids.ids,
        }

--- ops_matrix_core/models/ops_sla_instance.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from datetime import datetime, timedelta
import pytz
import logging

_logger = logging.getLogger(__name__)

class OpsSlaInstance(models.Model):
    _name = 'ops.sla.instance'
    _description = 'SLA Instance'
    _order = 'deadline asc'

    template_id = fields.Many2one('ops.sla.template', string='Template', required=True, ondelete='cascade')
    res_model = fields.Char(string='Related Model', related='template_id.model_id.model', store=True, readonly=True)
    res_id = fields.Integer(string='Related Record ID', required=True, index=True)
    
    start_datetime = fields.Datetime(string='Start Date', default=fields.Datetime.now, required=True)
    deadline = fields.Datetime(string='Deadline', compute='_compute_deadline', store=True)
    
    status = fields.Selection([
        ('running', 'Running'),
        ('warning', 'Warning'),
        ('critical', 'Critical'),
        ('violated', 'Violated'),
        ('completed', 'Completed')
    ], string='Status', default='running', required=True, compute='_compute_status', store=True)
    
    progress = fields.Float(string='Progress (%)', compute='_compute_progress')

    @api.depends('start_datetime', 'template_id', 'template_id.target_duration', 'template_id.calendar_id')
    def _compute_deadline(self):
        """Compute SLA deadline with proper timezone handling.
        
        This method calculates the deadline considering:
        - Company timezone (not UTC)
        - Business days if template has calendar configured
        - DST (Daylight Saving Time) transitions
        """
        for record in self:
            if not record.template_id or not record.start_datetime:
                record.deadline = False
                continue
            
            try:
                # Get company and timezone
                company = record.template_id.company_id or self.env.company
                tz_name = company.partner_id.tz or 'UTC'
                tz = pytz.timezone(tz_name)
                
                # Convert start time to company timezone
                start_utc = pytz.utc.localize(record.start_datetime)
                start_local = start_utc.astimezone(tz)
                
                # Get target duration from template
                if hasattr(record.template_id, 'target_days'):
                    target_days = record.template_id.target_days
                elif hasattr(record.template_id, 'target_duration'):
                    # Convert hours to days if duration is in hours
                    target_days = record.template_id.target_duration / 24.0
                else:
                    _logger.warning(
                        f"SLA template {record.template_id.id} has no target duration"
                    )
                    record.deadline = False
                    continue
                
                # Calculate deadline based on calendar
                calendar = company.resource_calendar_id
                use_business_days = (
                    hasattr(record.template_id, 'use_business_days') and
                    record.template_id.use_business_days
                )
                
                if calendar and use_business_days:
                    # Use business days calculation
                    deadline_local = self._add_business_days(
                        start_local,
                        int(target_days),
                        calendar,
                        tz
                    )
                else:
                    # Simple day addition (calendar days)
                    deadline_local = start_local + timedelta(days=target_days)
                
                # Convert back to UTC for storage
                deadline_utc = deadline_local.astimezone(pytz.utc)
                record.deadline = deadline_utc.replace(tzinfo=None)
                
            except Exception as e:
                _logger.error(
                    f"Error computing SLA deadline for instance {record.id}: {e}",
                    exc_info=True
                )
                record.deadline = False
    
    def _add_business_days(self, start_date, days, calendar, tz):
        """Add business days respecting company calendar.
        
        Args:
            start_date: Starting datetime (timezone-aware)
            days: Number of business days to add
            calendar: Company resource calendar
            tz: Timezone object
            
        Returns:
            datetime: Deadline in company timezone
        """
        current = start_date
        days_added = 0
        
        # Safety limit to prevent infinite loops
        max_iterations = days * 3  # Allow for weekends/holidays
        iterations = 0
        
        while days_added < days and iterations < max_iterations:
            current += timedelta(days=1)
            iterations += 1
            
            # Check if current date is a work day
            work_date = current.date()
            
            # Use calendar's work day check if available
            try:
                if hasattr(calendar, '_work_days_data_compute'):
                    work_data = calendar._work_days_data_compute(
                        work_date, work_date
                    )
                    if work_data.get(work_date):
                        days_added += 1
                elif hasattr(calendar, 'resource_id'):
                    # Fallback: check if it's a weekday (Mon-Fri)
                    if current.weekday() < 5:
                        days_added += 1
                else:
                    # No calendar method, assume Mon-Fri
                    if current.weekday() < 5:
                        days_added += 1
            except Exception as e:
                _logger.warning(
                    f"Error checking work day in calendar: {e}. "
                    f"Falling back to Mon-Fri."
                )
                if current.weekday() < 5:
                    days_added += 1
        
        if iterations >= max_iterations:
            _logger.warning(
                f"Business day calculation hit iteration limit. "
                f"Requested {days} days, added {days_added}"
            )
        
        return current

    @api.depends('deadline', 'status')
    def _compute_status(self):
        now = fields.Datetime.now()
        for record in self:
            if record.status == 'completed':
                continue
            
            if not record.deadline:
                record.status = 'running'
                continue

            if now > record.deadline:
                record.status = 'violated'
            else:
                # Calculate time elapsed percentage
                total_time = (record.deadline - record.start_datetime).total_seconds()
                if total_time > 0:
                    elapsed_time = (now - record.start_datetime).total_seconds()
                    percent = (elapsed_time / total_time) * 100.0
                    
                    if percent > 90:
                        record.status = 'critical'
                    elif percent > 75:
                        record.status = 'warning'
                    else:
                        record.status = 'running'
                else:
                    record.status = 'violated'

    def _compute_progress(self):
        now = fields.Datetime.now()
        for record in self:
            if record.status == 'completed':
                record.progress = 100.0
                continue
            
            if not record.deadline or not record.start_datetime:
                record.progress = 0.0
                continue
            
            total_time = (record.deadline - record.start_datetime).total_seconds()
            if total_time <= 0:
                record.progress = 100.0
                continue
                
            elapsed_time = (now - record.start_datetime).total_seconds()
            record.progress = min(100.0, max(0.0, (elapsed_time / total_time) * 100.0))

    def action_complete(self):
        self.write({'status': 'completed'})

    @api.model
    def _cron_check_sla_status(self):
        """
        Cron job to re-evaluate SLA statuses and notify chatter on changes.
        """
        instances = self.search([('status', 'in', ['running', 'warning', 'critical'])])
        for rec in instances:
            old_status = rec.status
            rec._compute_status()
            if rec.status != old_status:
                # Notify related document chatter
                try:
                    target_record = self.env[rec.res_model].browse(rec.res_id)
                    if target_record.exists() and hasattr(target_record, 'message_post'):
                        target_record.message_post(
                            body=f"SLA Status Change: {old_status.capitalize()} â†’ {rec.status.capitalize()} (Template: {rec.template_id.name})",
                            subtype_xmlid='mail.mt_note'
                        )
                except Exception:
                    continue

--- ops_matrix_core/models/ops_sla_mixin.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api

class OpsSlaMixin(models.AbstractModel):
    _name = 'ops.sla.mixin'
    _inherit = ['mail.thread']
    _description = 'SLA Mixin'

    @classmethod
    def _valid_field_parameter(cls, field, name):
        # Add 'auto_join' to valid parameters
        return name == 'auto_join' or models.BaseModel._valid_field_parameter(cls, field, name)

    sla_instance_ids = fields.One2many(
        'ops.sla.instance', 
        'res_id', 
        string='SLA Instances',
        domain=lambda self: [('res_model', '=', self._name)],
        auto_join=True
    )

    def _initiate_sla(self, template_xml_id):
        """
        Helper method to search for a template and create an instance for the current record.
        """
        self.ensure_one()
        template = self.env.ref(template_xml_id, raise_if_not_found=False)
        if not template or template._name != 'ops.sla.template':
            return False
        
        return self.env['ops.sla.instance'].create({
            'template_id': template.id,
            'res_id': self.id,
            'start_datetime': fields.Datetime.now(),
        })

--- ops_matrix_core/models/ops_sla_template.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api
from datetime import datetime

class OpsSlaTemplate(models.Model):
    _name = 'ops.sla.template'
    _description = 'SLA Template'

    name = fields.Char(
        string='Name',
        required=True,
        help='Descriptive name for this SLA (Service Level Agreement) template. '
             'Use clear names that explain what is being measured and the time expectation. '
             'Examples: "Approval Response - 24 Hours", "Quote Processing - 2 Business Days", '
             '"Customer Support Ticket - 4 Hours", "Order Fulfillment - 48 Hours". '
             'Best Practice: Include both the activity and the time frame in the name. '
             'This name appears in: SLA reports, deadline notifications, dashboard views.'
    )
    model_id = fields.Many2one(
        'ir.model',
        string='Target Model',
        required=True,
        ondelete='cascade',
        help='The Odoo model (object type) this SLA applies to. Required. '
             'Common models: '
             '- ops.approval.request (Approval Requests) '
             '- helpdesk.ticket (Support Tickets) '
             '- sale.order (Sales Orders) '
             '- project.task (Project Tasks). '
             'Scope: SLA instances are created automatically for records of this model type. '
             'Example: SLA on "sale.order" tracks how long from order creation to confirmation.'
    )
    calendar_id = fields.Many2one(
        'resource.calendar',
        string='Working Calendar',
        required=True,
        default=lambda self: self.env.company.resource_calendar_id,
        help='Working calendar that defines business hours for SLA deadline calculations. '
             'Determines: Which days are working days, what hours count as working hours, holidays. '
             'Default: Company\'s default working calendar (typically Mon-Fri 9am-5pm). '
             'Important: Deadlines are calculated in business hours, not calendar hours. '
             'Example: 8-hour SLA on Friday 3pm â†’ Deadline is Monday 3pm (skipping weekend). '
             'Use Cases: '
             '- Standard business hours: Mon-Fri 9-5 '
             '- 24/7 operations: All days, all hours '
             '- Shift work: Custom calendar matching your shifts.'
    )
    target_duration = fields.Float(
        string='Target Duration (Hours)',
        required=True,
        help='Time allowed to complete the action, measured in working hours. '
             'Examples: '
             '- Express approval: 4 hours '
             '- Standard approval: 24 hours (1 business day) '
             '- Quote processing: 48 hours (2 business days) '
             '- Complex reviews: 160 hours (4 weeks). '
             'Calculation: Uses business hours from the Working Calendar above. '
             '24 hours means 24 working hours (3 business days if 8-hour days). '
             'Warning: System generates alerts when deadlines approach or are missed. '
             'Best Practice: Set realistic targets based on historical performance data.'
    )
    active = fields.Boolean(
        default=True,
        help='If unchecked, this SLA template is no longer in use and won\'t create new SLA instances. '
             'Use Cases: '
             '- Uncheck: Deprecated SLA, pilot SLA ended, changed business process '
             '- Check: Reactivate SLA for seasonal processes. '
             'Effect: Inactive templates stop generating new SLA instances but existing instances remain. '
             'Historical SLA data is preserved even when template is deactivated. '
             'Use this instead of deleting templates that have historical tracking data.'
    )

    def _compute_deadline(self, start_dt: datetime) -> datetime:
        """
        Calculate the deadline based on the start datetime and target duration,
        respecting the working calendar.
        """
        self.ensure_one()
        if not start_dt:
            return False
        
        # plan_hours returns the end datetime after adding target_duration hours
        # to start_dt within the calendar's working intervals.
        deadline = self.calendar_id.plan_hours(self.target_duration, start_dt)
        return deadline

--- ops_matrix_core/models/partner.py ---
from odoo import _, models, fields, api
from odoo.exceptions import ValidationError
from typing import TYPE_CHECKING, List, Dict, Any, Tuple

if TYPE_CHECKING:
    from odoo.api import Environment

class ResPartner(models.Model):
    _inherit = 'res.partner'

    # Stewardship State for Partner Governance
    ops_state = fields.Selection([
        ('draft', 'Draft'),
        ('approved', 'Approved'),
        ('blocked', 'Blocked'),
        ('archived', 'Archived')
    ], string='Stewardship State', default='draft', help="Partner approval state for governance workflow.", tracking=True)
    
    # Partner Verification & Compliance
    ops_verification_date = fields.Date(
        string='Verification Date',
        help='Date when partner was verified/approved'
    )
    ops_verified_by_id = fields.Many2one(
        'res.users',
        string='Verified By',
        help='User who verified the partner',
        readonly=True
    )
    ops_approval_notes = fields.Text(
        string='Approval Notes',
        help='Notes about partner approval/rejection'
    )
    
    # Credit & Payment Terms
    ops_credit_limit = fields.Monetary(
        string='OPS Credit Limit',
        help='Maximum credit amount for this partner (OPS Matrix)',
        currency_field='company_currency_id'
    )
    ops_total_outstanding = fields.Monetary(
        string='Total Outstanding',
        compute='_compute_total_outstanding',
        store=False,
        compute_sudo=True,
        help='Total outstanding amount for this partner',
        currency_field='company_currency_id'
    )
    
    company_currency_id = fields.Many2one(
        'res.currency',
        string='Company Currency',
        related='company_id.currency_id',
        readonly=True
    )
    
    ops_confirmation_restrictions = fields.Text(
        string='Confirmation Restrictions',
        compute='_compute_confirmation_restrictions',
        store=False,
        compute_sudo=True,
        help='Displays any restrictions preventing order confirmation'
    )
    
    @api.constrains('ops_state')
    def _check_state_validity(self) -> None:
        """Ensure state transitions are valid"""
        for record in self:
            if record.ops_state == 'archived' and record.active:
                raise ValidationError(_('Archived partners should be marked as inactive'))
    
    def _compute_total_outstanding(self) -> None:
        """Calculate total outstanding amount for partner"""
        for partner in self:
            total = 0.0
            
            # Sum outstanding invoices
            invoices = self.env['account.move'].search([
                ('partner_id', '=', partner.id),
                ('move_type', 'in', ['out_invoice', 'out_refund']),
                ('state', '!=', 'cancel'),
                ('payment_state', 'in', ['not_paid', 'partial'])
            ])
            
            for invoice in invoices:
                if invoice.move_type == 'out_invoice':
                    total += invoice.amount_residual
                else:  # refund
                    total -= invoice.amount_residual
            
            partner.ops_total_outstanding = total
    
    def _compute_confirmation_restrictions(self) -> None:
        """Compute any restrictions that would prevent order confirmation"""
        for partner in self:
            restrictions = []
            
            # Check stewardship state
            if partner.ops_state == 'draft':
                restrictions.append('Partner not yet approved (Draft state)')
            elif partner.ops_state == 'blocked':
                restrictions.append('Partner is blocked from transactions')
            elif partner.ops_state == 'archived':
                restrictions.append('Partner is archived')
            
            # Check credit limit (optional)
            if partner.ops_credit_limit > 0 and partner.ops_total_outstanding >= partner.ops_credit_limit:
                restrictions.append(f'Credit limit exceeded ({partner.ops_total_outstanding} >= {partner.ops_credit_limit})')
            
            # Check if partner is active
            if not partner.active:
                restrictions.append('Partner is inactive')
            
            partner.ops_confirmation_restrictions = '\n'.join(restrictions) if restrictions else ''
    
    def action_approve(self) -> bool:
        """Approve the partner for transactions"""
        for partner in self:
            partner.write({
                'ops_state': 'approved',
                'ops_verification_date': fields.Date.today(),
                'ops_verified_by_id': self.env.user.id
            })
            partner.message_post(body='Partner approved for transactions')
        return True
    
    def action_block(self) -> bool:
        """Block partner from further transactions"""
        for partner in self:
            partner.write({'ops_state': 'blocked'})
            partner.message_post(body='Partner blocked from transactions')
        return True
    
    def action_unblock(self) -> bool:
        """Unblock partner - return to approved state"""
        for partner in self:
            if partner.ops_state == 'blocked':
                partner.write({'ops_state': 'approved'})
                partner.message_post(body='Partner unblocked')
        return True
    
    def action_reset_to_draft(self) -> bool:
        """Reset partner back to draft state"""
        for partner in self:
            partner.write({
                'ops_state': 'draft',
                'ops_verification_date': None,
                'ops_verified_by_id': None
            })
            partner.message_post(body='Partner reset to draft')
        return True
    
    def can_confirm_orders(self) -> Tuple[bool, str]:
        """Check if partner can have orders confirmed"""
        self.ensure_one()
        
        if self.ops_state not in ['approved', 'approved']:
            return False, f'Partner state is {self.ops_state}'
        
        if not self.active:
            return False, 'Partner is inactive'
        
        if self.ops_credit_limit > 0 and self.ops_total_outstanding >= self.ops_credit_limit:
            return False, f'Credit limit exceeded: {self.ops_total_outstanding} >= {self.ops_credit_limit}'
        
        return True, 'Partner can confirm orders'
     
    @api.onchange('ops_state')
    def _onchange_ops_state(self) -> None:
        """Auto-deactivate when archived"""
        if self.ops_state == 'archived':
            self.active = False
    
    @api.model_create_multi
    def create(self, vals_list):
        """Override create to trigger approval notifications for draft customers."""
        partners = super().create(vals_list)
        
        # Trigger notification for draft customers
        for partner in partners:
            if partner.ops_state == 'draft' and partner.customer_rank > 0:
                partner._notify_draft_customer_creation()
        
        return partners
    
    def write(self, vals):
        """Override write to trigger notification if state changes to draft."""
        result = super().write(vals)
        
        # If ops_state changed to draft, notify approvers
        if 'ops_state' in vals and vals['ops_state'] == 'draft':
            for partner in self:
                if partner.customer_rank > 0:
                    partner._notify_draft_customer_creation()
        
        return result
    
    def _notify_draft_customer_creation(self):
        """Send notification/activity to approvers when customer is in draft state."""
        self.ensure_one()
        
        # Find users with approval rights
        approver_group = self.env.ref('ops_matrix_core.group_ops_matrix_approver', raise_if_not_found=False)
        manager_persona = self.env['ops.persona'].search([('name', 'ilike', 'Manager')], limit=1)
        
        approvers = self.env['res.users']
        
        # Add users from approver group
        if approver_group:
            approvers |= approver_group.users
        
        # Add users with Manager persona
        if manager_persona:
            approvers |= self.env['res.users'].search([('persona_id', '=', manager_persona.id)])
        
        # Create activity for each approver
        for approver in approvers:
            if not approver.share:  # Skip portal users
                self.activity_schedule(
                    activity_type_id=self.env.ref('mail.mail_activity_data_todo').id,
                    summary=_('Customer Approval Required: %s') % self.name,
                    note=_(
                        'A new customer "%s" has been created in Draft state and requires approval.\n\n'
                        'Please review the customer details and approve or reject as needed.'
                    ) % self.name,
                    user_id=approver.id
                )
        
        # Also post a message on the partner
        self.message_post(
            body=_('Customer created in Draft state. Approval notification sent to %d approver(s).') % len(approvers),
            subject=_('Approval Required'),
            message_type='notification'
        )

--- ops_matrix_core/models/pricelist.py ---
from odoo import models, fields, api
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from odoo.api import Environment

class ProductPricelist(models.Model):
    _inherit = 'product.pricelist'

    # Matrix Integration: Branch and Business Unit for Pricing Matrix
    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        help="Branch this pricelist applies to for Matrix pricing.",
        tracking=True
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        help="Business Unit this pricelist applies to for Matrix pricing.",
        tracking=True
    )
    
    ops_is_matrix_pricelist = fields.Boolean(
        string='Matrix Pricelist',
        default=False,
        help='If checked, this pricelist is managed by the Matrix pricing engine'
    )
    
    ops_priority = fields.Integer(
        string='Matrix Priority',
        default=10,
        help='Priority for auto-selection (lower = higher priority)'
    )
    
    @api.model
    def _get_applicable_pricelist(self, partner_id=None, branch_id=None, business_unit_id=None, company_id=None):
        """
        Get the most appropriate pricelist based on matrix dimensions.
        
        Selection priority:
        1. Branch + Business Unit exact match
        2. Business Unit only match
        3. Branch only match
        4. Partner-specific pricelist
        5. Default company pricelist
        """
        domain = [('active', '=', True)]
        
        if company_id:
            domain.append(('company_id', '=', company_id))
        
        candidates = []
        
        # Priority 1: Branch + Business Unit exact match
        if branch_id and business_unit_id:
            exact_match = self.search([
                *domain,
                ('ops_branch_id', '=', branch_id),
                ('ops_business_unit_id', '=', business_unit_id),
                ('ops_is_matrix_pricelist', '=', True)
            ], order='ops_priority ASC', limit=1)
            if exact_match:
                return exact_match
        
        # Priority 2: Business Unit only
        if business_unit_id:
            bu_match = self.search([
                *domain,
                ('ops_business_unit_id', '=', business_unit_id),
                ('ops_branch_id', '=', False),
                ('ops_is_matrix_pricelist', '=', True)
            ], order='ops_priority ASC', limit=1)
            if bu_match:
                return bu_match
        
        # Priority 3: Branch only
        if branch_id:
            branch_match = self.search([
                *domain,
                ('ops_branch_id', '=', branch_id),
                ('ops_business_unit_id', '=', False),
                ('ops_is_matrix_pricelist', '=', True)
            ], order='ops_priority ASC', limit=1)
            if branch_match:
                return branch_match
        
        # Priority 4: Partner-specific pricelist
        if partner_id:
            partner = self.env['res.partner'].browse(partner_id)
            if partner.property_product_pricelist:
                return partner.property_product_pricelist
        
        # Priority 5: Default company pricelist
        company = self.env['res.company'].browse(company_id) if company_id else self.env.company
        if company.sale_pricelist_id:
            return company.sale_pricelist_id
        
        # Fallback: First active pricelist
        return self.search(domain, limit=1)
    
    def _compute_price_from_matrix_context(self, product_id, quantity=1, partner_id=None):
        """
        Compute product price considering matrix context.
        Called during sale order line price calculation.
        """
        self.ensure_one()
        
        # Get base pricelist pricing
        pricelist_item = self.env['product.pricelist.item'].search([
            ('pricelist_id', '=', self.id),
            ('product_id', '=', product_id)
        ], limit=1)
        
        if pricelist_item:
            return pricelist_item.compute_price(product_id, quantity)
        
        # Return product list price as fallback
        product = self.env['product.product'].browse(product_id)
        return product.list_price
    
    @api.model
    def _get_pricelist_for_sale_order(self, partner_id, branch_id=None, business_unit_id=None):
        """
        Determine the pricelist for a sale order based on matrix dimensions.
        This is called during SO creation to auto-select the appropriate pricelist.
        """
        # Get user's current matrix context if not provided
        if not branch_id or not business_unit_id:
            user_context = self.env.user.get_effective_matrix_access()
            if not branch_id and user_context['branch_ids']:
                branch_id = user_context['branch_ids'][0].id
            if not business_unit_id and user_context['business_unit_ids']:
                business_unit_id = user_context['business_unit_ids'][0].id
        
        # Find appropriate pricelist
        company_id = self.env.company.id
        pricelist = self._get_applicable_pricelist(
            partner_id=partner_id,
            branch_id=branch_id,
            business_unit_id=business_unit_id,
            company_id=company_id
        )
        
        return pricelist if pricelist else self.env.company.sale_pricelist_id

--- ops_matrix_core/models/product.py ---
from odoo import models, fields, api
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from odoo.api import Environment

class ProductTemplate(models.Model):
    _inherit = 'product.template'

    # Matrix Integration: Link to Business Unit for Product Silo
    business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        help="Business Unit this product belongs to for Matrix access control.",
        tracking=True
    )
    
    # The Cost Shield: Field-Level Security for Product Costs
    # These computed fields control visibility and editability of sensitive cost information
    can_user_access_cost_prices = fields.Boolean(
        string='Can Access Cost Prices',
        compute='_compute_can_user_access_cost_prices',
        store=False,
        help="Determines if the current user can view cost prices based on their Persona authority."
    )
    
    can_user_modify_product_master = fields.Boolean(
        string='Can Modify Product Master',
        compute='_compute_can_user_modify_product_master',
        store=False,
        help="Determines if the current user can edit product master data (costs, suppliers) based on their Persona authority."
    )
    
    @api.depends_context('uid')
    def _compute_can_user_access_cost_prices(self):
        """
        Check if user has authority to view cost prices.
        
        Security Logic:
        - System administrators (base.group_system) always have access
        - Other users must have 'can_access_cost_prices' authority flag in their active Persona
        - Users with no personas are denied access by default
        
        This implements "The Cost Shield" anti-fraud measure.
        """
        for record in self:
            # Administrators bypass all restrictions
            if self.env.user.has_group('base.group_system'):
                record.can_user_access_cost_prices = True
            else:
                # Check persona authority flag
                record.can_user_access_cost_prices = self.env.user.has_ops_authority('can_access_cost_prices')
    
    @api.depends_context('uid')
    def _compute_can_user_modify_product_master(self):
        """
        Check if user has authority to modify product master data.
        
        Security Logic:
        - System administrators (base.group_system) always have access
        - Other users must have 'can_modify_product_master' authority flag in their active Persona
        - Users with no personas cannot modify product master data
        - This controls editing of cost prices, supplier information, and other sensitive fields
        
        This implements "The Cost Shield" anti-fraud measure.
        """
        for record in self:
            # Administrators bypass all restrictions
            if self.env.user.has_group('base.group_system'):
                record.can_user_modify_product_master = True
            else:
                # Check persona authority flag
                record.can_user_modify_product_master = self.env.user.has_ops_authority('can_modify_product_master')
    
    @api.model
    def _search_default_business_unit(self):
        """Get default business unit from user's access"""
        user = self.env.user
        access = user.get_effective_matrix_access()
        business_units = access.get('business_units', self.env['ops.business.unit'])
        if business_units:
            return business_units[0]
        return None
    
    @api.model
    def search(self, domain, offset=0, limit=None, order=None, count=False):
        """
        Override search to filter products by user's business unit access.
        
        PERFORMANCE NOTE: Uses pure SQL domain construction (not Python filtering).
        This ensures the ORM can optimize the query at DB level and the
        scheduler doesn't suffer from excessive Python processing.
        
        Logic:
        - Superusers bypass filtering entirely
        - Regular users see: (product in their BU) OR (product has no BU)
        - Uses domain syntax to let ORM handle DB-level filtering
        
        :param domain: Original domain filter
        :param offset: Record offset for pagination
        :param limit: Maximum records to return
        :param order: Order by clause
        :param count: If True, return count instead of records
        :return: Filtered RecordSet or count
        """
        # Get user's allowed business units using unified access method
        user = self.env.user
        access = user.get_effective_matrix_access()
        business_units = access.get('business_units', self.env['ops.business.unit'])
        
        # PURE SQL DOMAIN CONSTRUCTION (No Python filtering)
        # Build domain: products are visible if they belong to user's BU OR have no BU assigned
        if not self.env.is_superuser():
            if business_units:
                # Construct domain: (BU match) OR (no BU assigned)
                bu_domain = [
                    '|',
                    ('business_unit_id', 'in', business_units.ids),
                    ('business_unit_id', '=', False)
                ]
                # Merge with original domain using AND logic
                domain = bu_domain + domain
            else:
                # User has no business units, show only products with no BU
                domain = [('business_unit_id', '=', False)] + domain
        
        # Handle count parameter (removed in Odoo 19)
        if count:
            return super().search_count(domain)
        else:
            return super().search(domain, offset=offset, limit=limit, order=order)
    
    @api.model_create_multi
    def create(self, vals_list):
        """
        Auto-assign business unit from current user if not specified.
        
        Ensures new products are automatically scoped to the creating user's
        business unit (if applicable), simplifying the UI experience.
        """
        for vals in vals_list:
            if not vals.get('business_unit_id') and not self.env.is_superuser():
                default_bu = self._search_default_business_unit()
                if default_bu:
                    vals['business_unit_id'] = default_bu.id
        return super().create(vals_list)


class ProductProduct(models.Model):
    _inherit = 'product.product'
    
    @api.model
    def search(self, domain, offset=0, limit=None, order=None, count=False):
        """
        Override search to filter product variants by business unit access.
        
        PERFORMANCE NOTE: Filters through the product template's business_unit_id
        using pure SQL domain (not Python loops). Maintains consistency with
        ProductTemplate filtering.
        
        :param domain: Original domain filter
        :param offset: Record offset for pagination
        :param limit: Maximum records to return
        :param order: Order by clause
        :param count: If True, return count instead of records
        :return: Filtered RecordSet or count
        """
        # Get user's allowed business units
        user = self.env.user
        access = user.get_effective_matrix_access()
        business_units = access.get('business_units', self.env['ops.business.unit'])
        
        # PURE SQL DOMAIN CONSTRUCTION through product template
        # Filter product variants by their template's business unit
        if not self.env.is_superuser():
            if business_units:
                # Construct domain: (product's template BU matches) OR (no BU assigned)
                bu_domain = [
                    '|',
                    ('product_tmpl_id.business_unit_id', 'in', business_units.ids),
                    ('product_tmpl_id.business_unit_id', '=', False)
                ]
                domain = bu_domain + domain
            else:
                # User has no business units, show only products with no BU
                domain = [('product_tmpl_id.business_unit_id', '=', False)] + domain
        
        # Handle count parameter (removed in Odoo 19)
        if count:
            return super().search_count(domain)
        else:
            return super().search(domain, offset=offset, limit=limit, order=order)

--- ops_matrix_core/models/purchase_order.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)

class PurchaseOrder(models.Model):
    _inherit = ['purchase.order', 'ops.governance.mixin']
    
    # Governance Fields (explicitly declared for proper column creation)
    approval_locked = fields.Boolean(
        string='Approval Locked',
        default=False,
        help='Record is locked pending approval',
        copy=False
    )
    
    # OPS Matrix Fields
    ops_branch_id = fields.Many2one(
        'ops.branch',
        string='Branch',
        tracking=True,
        help='Operational branch for this purchase order'
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        tracking=True,
        help='Business unit for this purchase order'
    )
    
    @api.onchange('ops_branch_id')
    def _onchange_ops_branch_id(self):
        """Update company when branch changes."""
        if self.ops_branch_id:
            self.company_id = self.ops_branch_id.company_id
    
    def button_confirm(self):
        """
        Override button_confirm to enforce governance rules before confirmation.
        
        This ensures that governance rules are checked even if standard write()
        is bypassed, providing a hard gate for purchase order confirmation.
        """
        for order in self:
            _logger.info("OPS Governance: Checking PO %s for confirmation rules", order.name)
            
            # ADMIN BYPASS: Skip governance for administrators
            if self.env.su or self.env.user.has_group('base.group_system'):
                _logger.info("OPS Governance: Admin bypass for PO %s", order.name)
                # Log admin override for audit trail
                try:
                    self.env['ops.security.audit'].sudo().log_security_override(
                        model_name=order._name,
                        record_id=order.id,
                        reason='Admin bypass used to confirm Purchase Order without governance checks'
                    )
                except Exception as e:
                    _logger.warning("Failed to log admin override: %s", str(e))
                continue
            
            # Explicitly trigger Governance check for 'on_write' trigger
            # This catches rules like "Purchase orders over $10K require approval"
            order._enforce_governance_rules(order, trigger_type='on_write')
            
            _logger.info("OPS Governance: PO %s passed all governance checks", order.name)
        
        # If we reach here, all governance checks passed
        return super(PurchaseOrder, self).button_confirm()
    
    def action_rfq_send(self):
        """
        Override email sending to enforce governance rules.
        
        This prevents users from sending purchase orders/RFQs by email
        if they violate governance rules or have pending approvals.
        """
        # ADMIN BYPASS: Allow administrators to send anything
        if self.env.su or self.env.user.has_group('base.group_system'):
            # Log admin override for audit trail
            try:
                for order in self:
                    self.env['ops.security.audit'].sudo().log_security_override(
                        model_name=order._name,
                        record_id=order.id,
                        reason='Admin bypass used to send Purchase Order/RFQ without governance checks'
                    )
            except Exception as e:
                _logger.warning("Failed to log admin override: %s", str(e))
            return super().action_rfq_send()
        
        for order in self:
            _logger.info("OPS Governance: Checking PO %s for email commitment", order.name)
            
            # Check for pending approvals
            if hasattr(order, 'approval_request_ids'):
                pending_approvals = order.approval_request_ids.filtered(
                    lambda a: a.state == 'pending'
                )
                
                if pending_approvals:
                    rule_names = ', '.join(pending_approvals.mapped('rule_id.name'))
                    raise UserError(_(
                        "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s' "
                        "until it satisfies company Governance Rules.\n\n"
                        "â³ Pending Approval: %s\n\n"
                        "This document is locked for external commitment (email or print) "
                        "until the required approvals are granted."
                    ) % (order.display_name, rule_names))
            
            # Enforce governance rules
            try:
                order._enforce_governance_rules(order, trigger_type='on_write')
                _logger.info("OPS Governance: PO %s passed all governance checks for email", order.name)
            except UserError as e:
                # Re-raise with enhanced message for email context
                error_message = str(e)
                if 'requires approval' in error_message.lower():
                    raise UserError(_(
                        "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n"
                        "%s\n\n"
                        "External commitment (email/print) is blocked until approval is granted."
                    ) % (order.display_name, error_message))
                else:
                    raise UserError(_(
                        "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n%s"
                    ) % (order.display_name, error_message))
        
        # If all checks pass, proceed with email wizard
        return super().action_rfq_send()


class PurchaseOrderLine(models.Model):
    """Extend purchase.order.line with Matrix Mixin for dimension propagation."""
    _inherit = ['purchase.order.line', 'ops.matrix.mixin']
    _name = 'purchase.order.line'
    
    # These fields are inherited from ops.matrix.mixin:
    # - ops_branch_id
    # - ops_business_unit_id
    # - ops_company_id
    # - ops_analytic_distribution
    
    def _get_default_ops_branch(self):
        """Get default branch from parent order if available."""
        if self._context.get('default_order_id'):
            order = self.env['purchase.order'].browse(self._context['default_order_id'])
            if order.ops_branch_id:
                return order.ops_branch_id.id
        return super()._get_default_ops_branch()
    
    def _get_default_ops_business_unit(self):
        """Get default BU from parent order if available."""
        if self._context.get('default_order_id'):
            order = self.env['purchase.order'].browse(self._context['default_order_id'])
            if order.ops_business_unit_id:
                return order.ops_business_unit_id.id
        return super()._get_default_ops_business_unit()
    
    @api.onchange('order_id')
    def _onchange_order_id_propagate_dimensions(self):
        """
        When order_id changes or is set, inherit the order's matrix dimensions.
        
        This ensures that when a line is added to an order with specific dimensions,
        it automatically gets the correct dimensions.
        """
        if self.order_id:
            # Inherit dimensions from parent order if not already set
            if not self.ops_branch_id and self.order_id.ops_branch_id:
                self.ops_branch_id = self.order_id.ops_branch_id
            if not self.ops_business_unit_id and self.order_id.ops_business_unit_id:
                self.ops_business_unit_id = self.order_id.ops_business_unit_id

--- ops_matrix_core/models/res_company.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
from typing import List, Dict, Any
import logging

_logger = logging.getLogger(__name__)

class ResCompany(models.Model):
    _inherit = 'res.company'

    # ==================================================================
    # OPS MATRIX FIELDS - Legal Entity Only
    # ==================================================================
    
    ops_code = fields.Char(
        string='OPS Code',
        required=True,
        readonly=True,
        copy=False,
        default='New',
        tracking=True,
        help="Legal entity identification code (e.g., QAT-001, UAE-001). Auto-generated."
    )
    
    ops_manager_id = fields.Many2one(
        'res.users',
        string='Country Manager',
        domain="[('share', '=', False)]",
        tracking=True,
        help="Company-level manager (CEO, Country Director)"
    )

    # ---------------------------------------------------------
    # Branch Relationship (One2many)
    # ---------------------------------------------------------
    branch_ids = fields.One2many(
        'ops.branch',
        'company_id',
        string='Operational Branches',
        help="Operational branches under this legal entity"
    )

    branch_count = fields.Integer(
        compute='_compute_branch_count',
        string='Number of Branches',
        help="Count of operational branches"
    )

    # ---------------------------------------------------------
    # Computed Methods
    # ---------------------------------------------------------
    @api.depends('branch_ids')
    def _compute_branch_count(self) -> None:
        """Count operational branches."""
        for company in self:
            company.branch_count = len(company.branch_ids)

    # ---------------------------------------------------------
    # SQL Constraints
    # ---------------------------------------------------------
    _sql_constraints = [
        ('ops_code_unique',
         'UNIQUE(ops_code)',
         'OPS Code must be unique across all companies!')
    ]

    # ---------------------------------------------------------
    # CRUD & Sequence Generation
    # ---------------------------------------------------------
    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'ResCompany':
        """Override create to auto-generate OPS code via sequence."""
        for vals in vals_list:
            if vals.get('ops_code', 'New') == 'New':
                vals['ops_code'] = self.env['ir.sequence'].next_by_code('res.company.ops') or 'New'
        
        return super().create(vals_list)
    
    def write(self, vals: Dict[str, Any]) -> bool:
        """
        Override write to auto-generate OPS code when company name changes
        but ops_code is still 'New' (handles pre-configured 'New Company' scenario).
        """
        result = super().write(vals)
        
        # If name is being changed and ops_code is still 'New', generate proper code
        if 'name' in vals:
            for company in self:
                if company.ops_code == 'New':
                    new_code = self.env['ir.sequence'].next_by_code('res.company.ops') or 'New'
                    # Use super().write to avoid recursion
                    super(ResCompany, company).write({'ops_code': new_code})
                    _logger.info(
                        f"Auto-generated OPS code '{new_code}' for company '{company.name}' "
                        f"(was 'New')"
                    )
        
        return result

    # Note: Analytic account logic removed - now handled by ops.branch model

--- ops_matrix_core/models/res_users.py ---
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError
import logging

_logger = logging.getLogger(__name__)

class ResUsers(models.Model):
    _inherit = 'res.users'

    @classmethod
    def _valid_field_parameter(cls, field, name):
        # Add 'tracking' to valid parameters
        return name == 'tracking' or models.BaseModel._valid_field_parameter(cls, field, name)

    # ============================================
    # PERSONA FIELDS (Many2many Primary)
    # ============================================
    ops_persona_ids = fields.Many2many(
        'ops.persona',
        'res_users_ops_persona_rel',
        'user_id',
        'persona_id',
        string='OPS Personas',
        help='Multiple organizational personas/roles assigned to this user. '
             'User inherits ALL authorities from ALL assigned personas.',
        tracking=True
    )
    
    # Legacy Many2one field (computed for backward compatibility)
    persona_id = fields.Many2one(
        'ops.persona',
        string='Primary Persona',
        compute='_compute_persona_id',
        inverse='_inverse_persona_id',
        store=True,
        help='[DEPRECATED] Primary persona (first from ops_persona_ids). Use ops_persona_ids instead.',
        tracking=True
    )
    
    # Legacy alias for backward compatibility
    persona_ids = fields.Many2many(
        'ops.persona',
        'res_users_legacy_persona_rel',
        'user_id',
        'persona_id',
        string='Personas (Legacy)',
        compute='_compute_persona_ids',
        inverse='_inverse_persona_ids',
        store=True,
        help='[DEPRECATED ALIAS] Use ops_persona_ids instead'
    )
    
    delegated_persona_ids = fields.Many2many(
        'ops.persona',
        'res_users_ops_delegated_persona_rel',
        'user_id',
        'persona_id',
        string='Delegated Personas'
    )
    
    primary_branch_id = fields.Many2one(
        'ops.branch',
        string='Primary Branch',
        help='Primary branch this user belongs to',
        tracking=True
    )
    
    # ============================================
    # MATRIX ACCESS CONTROL FIELDS
    # ============================================
    
    # Multi-branch access
    ops_allowed_branch_ids = fields.Many2many(
        'ops.branch',
        'res_users_ops_allowed_branch_rel',
        'user_id',
        'branch_id',
        string='Allowed Branches',
        help='Operational branches this user can access',
        tracking=True
    )
    
    # Multi-business unit access
    ops_allowed_business_unit_ids = fields.Many2many(
        'ops.business.unit',
        'res_users_ops_allowed_business_unit_rel',
        'user_id',
        'business_unit_id',
        string='Allowed Business Units',
        help='Business units this user can access',
        tracking=True
    )
    
    # Default selections for quick transactions
    ops_default_branch_id = fields.Many2one(
        'ops.branch',
        string='Default Branch',
        help='Default branch for new transactions',
        domain="[('id', 'in', ops_allowed_branch_ids)]",
        tracking=True
    )
    
    ops_default_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Default Business Unit',
        help='Default business unit for new transactions',
        domain="[('id', 'in', ops_allowed_business_unit_ids)]",
        tracking=True
    )
    
    # Role indicators
    is_cross_branch_bu_leader = fields.Boolean(
        string='Cross-Branch BU Leader',
        help='Can access the same business unit across multiple branches',
        tracking=True
    )
    
    is_matrix_administrator = fields.Boolean(
        string='Matrix Administrator',
        help='Can configure and manage matrix structure (not data)',
        tracking=True
    )
    
    # ============================================
    # COMPUTED FIELDS
    # ============================================
    
    # Access summary for UI display
    matrix_access_summary = fields.Char(
        compute='_compute_matrix_access_summary',
        string='Matrix Access',
        help='Summary of user\'s matrix access rights'
    )
    
    # Count fields for quick reference
    allowed_branch_count = fields.Integer(
        compute='_compute_allowed_counts',
        string='Branch Count'
    )
    
    allowed_bu_count = fields.Integer(
        compute='_compute_allowed_counts',
        string='BU Count'
    )
    
    # Effective companies from allowed branches
    effective_company_ids = fields.Many2many(
        'res.company',
        compute='_compute_effective_companies',
        string='Effective Companies',
        help='Companies derived from allowed branches',
        store=False
    )
    
    # ========================================================================
    # LEGACY FIELDS (Computed for Backward Compatibility - DB Stored)
    # ========================================================================
    allowed_branch_ids = fields.Many2many(
        'ops.branch',
        'res_users_legacy_branch_rel',
        'user_id',
        'branch_id',
        string='Allowed Branches (Legacy)',
        compute='_compute_allowed_branch_ids',
        inverse='_inverse_allowed_branch_ids',
        store=True,
        help='[DEPRECATED] Use ops_allowed_branch_ids instead'
    )
    
    business_unit_ids = fields.Many2many(
        'ops.business.unit',
        'res_users_legacy_business_unit_rel',
        'user_id',
        'business_unit_id',
        string='Business Units (Legacy)',
        compute='_compute_business_unit_ids',
        inverse='_inverse_business_unit_ids',
        store=True,
        help='[DEPRECATED] Use ops_allowed_business_unit_ids instead'
    )
    
    allowed_business_unit_ids = fields.Many2many(
        'ops.business.unit',
        'res_users_allowed_business_unit_alias_rel',
        'user_id',
        'business_unit_id',
        string='Allowed Business Units (Alias)',
        compute='_compute_allowed_business_unit_ids',
        inverse='_inverse_allowed_business_unit_ids',
        store=True,
        help='[DEPRECATED ALIAS] Use ops_allowed_business_unit_ids instead'
    )
    
    default_branch_id = fields.Many2one(
        'ops.branch',
        string='Default Branch (Alias)',
        compute='_compute_default_branch_id',
        inverse='_inverse_default_branch_id',
        store=True,
        help='[DEPRECATED ALIAS] Use ops_default_branch_id instead'
    )
    
    default_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Default BU (Alias)',
        compute='_compute_default_business_unit_id',
        inverse='_inverse_default_business_unit_id',
        store=True,
        help='[DEPRECATED ALIAS] Use ops_default_business_unit_id instead'
    )
    
    branch_id = fields.Many2one(
        'ops.branch',
        string='Branch (Legacy)',
        compute='_compute_branch_id',
        inverse='_inverse_branch_id',
        store=True,
        help='[DEPRECATED] Use primary_branch_id instead'
    )
    
    # ========================================================================
    # COMPUTED METHODS - Synchronization
    # ========================================================================
    
    @api.depends('ops_allowed_branch_ids')
    def _compute_allowed_branch_ids(self):
        """Compute legacy field from OPS matrix field."""
        for user in self:
            user.allowed_branch_ids = user.ops_allowed_branch_ids
    
    def _inverse_allowed_branch_ids(self):
        """Inverse synchronization: Writing to legacy field updates OPS field."""
        for user in self:
            user.ops_allowed_branch_ids = user.allowed_branch_ids
    
    @api.depends('ops_allowed_business_unit_ids')
    def _compute_business_unit_ids(self):
        """Compute legacy field from OPS matrix field."""
        for user in self:
            user.business_unit_ids = user.ops_allowed_business_unit_ids
    
    def _inverse_business_unit_ids(self):
        """Inverse synchronization: Writing to legacy field updates OPS field."""
        for user in self:
            user.ops_allowed_business_unit_ids = user.business_unit_ids
    
    @api.depends('ops_allowed_business_unit_ids')
    def _compute_allowed_business_unit_ids(self):
        """Compute alias field from OPS matrix field."""
        for user in self:
            user.allowed_business_unit_ids = user.ops_allowed_business_unit_ids
    
    def _inverse_allowed_business_unit_ids(self):
        """Inverse synchronization: Writing to alias field updates OPS field."""
        for user in self:
            user.ops_allowed_business_unit_ids = user.allowed_business_unit_ids
    
    @api.depends('ops_default_branch_id')
    def _compute_default_branch_id(self):
        """Compute alias field from OPS matrix field."""
        for user in self:
            user.default_branch_id = user.ops_default_branch_id
    
    def _inverse_default_branch_id(self):
        """Inverse synchronization: Writing to alias field updates OPS field."""
        for user in self:
            user.ops_default_branch_id = user.default_branch_id
    
    @api.depends('ops_default_business_unit_id')
    def _compute_default_business_unit_id(self):
        """Compute alias field from OPS matrix field."""
        for user in self:
            user.default_business_unit_id = user.ops_default_business_unit_id
    
    def _inverse_default_business_unit_id(self):
        """Inverse synchronization: Writing to alias field updates OPS field."""
        for user in self:
            user.ops_default_business_unit_id = user.default_business_unit_id
    
    @api.depends('primary_branch_id')
    def _compute_branch_id(self):
        """Compute legacy field from primary_branch_id."""
        for user in self:
            user.branch_id = user.primary_branch_id
    
    def _inverse_branch_id(self):
        """Inverse synchronization: Writing to legacy field updates primary_branch_id."""
        for user in self:
            user.primary_branch_id = user.branch_id
    
    @api.depends('ops_persona_ids')
    def _compute_persona_id(self):
        """Compute primary persona from ops_persona_ids (first active persona)."""
        for user in self:
            active_personas = user.ops_persona_ids.filtered(lambda p: p.active and p.is_active_today)
            user.persona_id = active_personas[0] if active_personas else False
    
    def _inverse_persona_id(self):
        """Inverse synchronization: Writing to persona_id updates ops_persona_ids."""
        for user in self:
            if user.persona_id:
                # Add to ops_persona_ids if not already there
                if user.persona_id not in user.ops_persona_ids:
                    user.ops_persona_ids = [(4, user.persona_id.id)]
            else:
                # Clear all personas
                user.ops_persona_ids = [(5, 0, 0)]
    
    @api.depends('ops_persona_ids')
    def _compute_persona_ids(self):
        """Compute legacy persona_ids from ops_persona_ids."""
        for user in self:
            user.persona_ids = user.ops_persona_ids
    
    def _inverse_persona_ids(self):
        """Inverse synchronization: Writing to legacy field updates ops_persona_ids."""
        for user in self:
            user.ops_persona_ids = user.persona_ids
    
    # ========================================================================
    # COMPUTED METHODS - New Matrix Fields
    # ========================================================================
    
    @api.depends('ops_allowed_branch_ids', 'ops_allowed_business_unit_ids', 
                 'is_cross_branch_bu_leader', 'is_matrix_administrator')
    def _compute_matrix_access_summary(self):
        """Compute human-readable summary of matrix access."""
        for user in self:
            parts = []
            
            # Branch access summary
            if user.ops_allowed_branch_ids:
                if len(user.ops_allowed_branch_ids) <= 3:
                    branch_codes = [b.code if hasattr(b, 'code') else b.name 
                                   for b in user.ops_allowed_branch_ids]
                    parts.append(f"Branches: {', '.join(branch_codes)}")
                else:
                    parts.append(f"Branches: {len(user.ops_allowed_branch_ids)} branches")
            
            # BU access summary
            if user.ops_allowed_business_unit_ids:
                if len(user.ops_allowed_business_unit_ids) <= 3:
                    bu_codes = [bu.code if hasattr(bu, 'code') else bu.name 
                               for bu in user.ops_allowed_business_unit_ids]
                    parts.append(f"BUs: {', '.join(bu_codes)}")
                else:
                    parts.append(f"BUs: {len(user.ops_allowed_business_unit_ids)} units")
            
            # Role indicators
            if user.is_cross_branch_bu_leader:
                parts.append("Cross-Branch Leader")
            if user.is_matrix_administrator:
                parts.append("Matrix Admin")
            
            user.matrix_access_summary = " | ".join(parts) if parts else "No matrix access"
    
    @api.depends('ops_allowed_branch_ids', 'ops_allowed_business_unit_ids')
    def _compute_allowed_counts(self):
        """Compute count of allowed branches and BUs."""
        for user in self:
            user.allowed_branch_count = len(user.ops_allowed_branch_ids)
            user.allowed_bu_count = len(user.ops_allowed_business_unit_ids)
    
    @api.depends('ops_allowed_branch_ids')
    def _compute_effective_companies(self):
        """Compute companies from allowed branches."""
        for user in self:
            # Get companies from allowed branches (ops.branch has company_id field)
            companies = user.ops_allowed_branch_ids.mapped('company_id')
            user.effective_company_ids = [(6, 0, companies.ids)]
    
    # ========================================================================
    # ACCESS CONTROL METHODS
    # ========================================================================
    
    def get_effective_matrix_access(self):
        """
        Returns computed access based on user's direct assignments and personas.
        Consolidated view of all access rights.
        """
        self.ensure_one()
        
        # If system administrator, grant all access
        if self.has_group('base.group_system'):
            return {
                'companies': self.env['res.company'].search([]),
                'branches': self.env['ops.branch'].search([]),
                'business_units': self.env['ops.business.unit'].search([]),
            }
        
        # Start with direct assignments
        companies = self.company_ids
        branches = self.ops_allowed_branch_ids
        business_units = self.ops_allowed_business_unit_ids
        
        # Add access from personas (if persona module exists and is installed)
        if hasattr(self, 'persona_ids'):
            for persona in self.persona_ids.filtered(lambda p: p.active):
                # Add persona's allowed branches
                if hasattr(persona, 'branch_ids'):
                    branches |= persona.branch_ids
                
                # Add persona's allowed business units
                if hasattr(persona, 'business_unit_ids'):
                    business_units |= persona.business_unit_ids
        
        # For cross-branch BU leaders, get all branches where their BUs operate
        if self.is_cross_branch_bu_leader and business_units:
            # Get all branches where allowed BUs operate
            bu_branches = business_units.mapped('branch_ids')
            branches |= bu_branches
        
        # Derive companies from branches (if not already set)
        if branches and not companies:
            companies = branches.mapped('company_id')
        
        return {
            'companies': companies,
            'branches': branches,
            'business_units': business_units,
        }
    
    def can_access_branch(self, branch_id):
        """Check if user can access specific branch."""
        self.ensure_one()
        
        # System administrators can access everything
        if self.has_group('base.group_system'):
            return True
        
        # Get effective access
        effective_access = self.get_effective_matrix_access()
        
        # Check if branch is in allowed branches
        branch = self.env['ops.branch'].browse(branch_id)
        if not branch.exists():
            return False
        
        # Company-level access: if user has company access, they can see all branches in that company
        if branch.company_id.id in effective_access['companies'].ids:
            return True
        
        # Branch-level access
        return branch_id in effective_access['branches'].ids
    
    def can_access_business_unit(self, bu_id):
        """Check if user can access specific business unit."""
        self.ensure_one()
        
        # System administrators can access everything
        if self.has_group('base.group_system'):
            return True
        
        # Get effective access
        effective_access = self.get_effective_matrix_access()
        
        # Check if BU is in allowed BUs
        bu = self.env['ops.business.unit'].browse(bu_id)
        if not bu.exists():
            return False
        
        # Company-level access: if user has company access, they can see all BUs in that company
        bu_companies = bu.branch_ids.mapped('company_id')
        if any(company.id in effective_access['companies'].ids for company in bu_companies):
            return True
        
        # BU-level access
        return bu_id in effective_access['business_units'].ids
    
    def can_access_matrix_combination(self, branch_id, bu_id):
        """
        Check if user can access specific branch-BU combination.
        Useful for transaction validation.
        """
        self.ensure_one()
        
        # System administrators can access everything
        if self.has_group('base.group_system'):
            return True
        
        # Check individual access
        if not self.can_access_branch(branch_id):
            return False
        
        if not self.can_access_business_unit(bu_id):
            return False
        
        # For cross-branch BU leaders: special handling
        if self.is_cross_branch_bu_leader:
            # Cross-branch BU leaders can access their BUs in any branch
            allowed_bus = self.get_effective_matrix_access()['business_units']
            return bu_id in allowed_bus.ids
        
        # Regular users: BU must operate in the branch
        bu = self.env['ops.business.unit'].browse(bu_id)
        branch = self.env['ops.branch'].browse(branch_id)
        
        return branch in bu.branch_ids
    
    # ========================================================================
    # SEGREGATION OF DUTIES (SoD) AUTHORITY CHECKING
    # ========================================================================
    
    def has_authority(self, authority_field):
        """
        Check if user has specific authority based on ANY of their assigned personas.
        Returns True if ANY active persona has the authority flag set to True.
        
        :param authority_field: Name of the authority field (e.g., 'can_validate_invoices')
        :return: Boolean
        """
        self.ensure_one()
        
        # System administrators bypass all checks
        if self.has_group('base.group_system'):
            return True
        
        # Check all active personas
        active_personas = self.ops_persona_ids.filtered(lambda p: p.active and p.is_active_today)
        
        for persona in active_personas:
            if hasattr(persona, authority_field) and getattr(persona, authority_field):
                return True
        
        return False
    
    def has_ops_authority(self, field_name):
        """
        Cumulative Authority Logic Helper: Check if ANY of the user's assigned personas
        grants a specific authority.
        
        This method implements the OPS Framework anti-fraud pattern where users can have
        multiple personas, and we check if ANY persona grants the requested authority.
        
        Usage Example:
            if self.env.user.has_ops_authority('can_validate_invoices'):
                # Show validate button
                pass
        
        :param field_name: Name of the boolean authority field on ops.persona model
                          (e.g., 'can_validate_invoices', 'can_post_journal_entries')
        :return: Boolean - True if ANY active persona has the authority, False otherwise
        
        Edge Cases Handled:
        - Returns True for system administrators (bypass all checks)
        - Returns False if user has no personas assigned
        - Returns False if the field doesn't exist on the persona model
        - Returns False if all personas lack the authority
        - Considers only active personas with valid date ranges
        """
        self.ensure_one()
        
        # System administrators bypass all authority checks
        if self.has_group('base.group_system'):
            return True
        
        # Handle case: No personas assigned to user
        if not self.ops_persona_ids:
            _logger.debug(
                f"User {self.name} (ID: {self.id}) has no personas assigned. "
                f"Authority check for '{field_name}' returns False."
            )
            return False
        
        # Filter to only active personas with valid date ranges
        active_personas = self.ops_persona_ids.filtered(
            lambda p: p.active and p.is_active_today
        )
        
        # Handle case: No active personas
        if not active_personas:
            _logger.debug(
                f"User {self.name} (ID: {self.id}) has no active personas. "
                f"Authority check for '{field_name}' returns False."
            )
            return False
        
        # Defensive check: Verify field exists on persona model
        persona_model = self.env['ops.persona']
        if field_name not in persona_model._fields:
            _logger.warning(
                f"Authority field '{field_name}' does not exist on ops.persona model. "
                f"Authority check for user {self.name} (ID: {self.id}) returns False."
            )
            return False
        
        # Use any() for efficient cumulative authority check
        # Returns True if ANY persona has the authority field set to True
        try:
            has_authority = any(
                getattr(persona, field_name, False)
                for persona in active_personas
            )
            
            if has_authority:
                _logger.debug(
                    f"User {self.name} (ID: {self.id}) has authority '{field_name}' "
                    f"via one or more active personas."
                )
            
            return has_authority
            
        except Exception as e:
            _logger.error(
                f"Error checking authority '{field_name}' for user {self.name} (ID: {self.id}): {e}"
            )
            return False
    
    def can_modify_product_master(self):
        """Check if user can modify product master data (cost, suppliers)."""
        return self.has_authority('can_modify_product_master')
    
    def can_access_cost_prices(self):
        """Check if user can access/view product cost prices."""
        return self.has_authority('can_access_cost_prices')
    
    def can_validate_invoices(self):
        """Check if user can validate and post invoices."""
        return self.has_authority('can_validate_invoices')
    
    def can_post_journal_entries(self):
        """Check if user can post accounting journal entries."""
        return self.has_authority('can_post_journal_entries')
    
    def can_execute_payments(self):
        """Check if user can execute vendor payments."""
        return self.has_authority('can_execute_payments')
    
    def can_adjust_inventory(self):
        """Check if user can post inventory adjustments."""
        return self.has_authority('can_adjust_inventory')
    
    def can_manage_pdc(self):
        """Check if user can manage Post Dated Checks."""
        return self.has_authority('can_manage_pdc')
    
    # ========================================================================
    # VALIDATION CONSTRAINTS
    # ========================================================================
    
    @api.onchange('ops_allowed_branch_ids', 'ops_default_branch_id')
    def _onchange_auto_populate_primary_branch(self):
        """Auto-populate Primary Branch when allowed branches are selected."""
        for user in self:
            # Only auto-populate if primary_branch_id is not yet set
            if not user.primary_branch_id:
                # First try to use default branch if set
                if user.ops_default_branch_id and user.ops_default_branch_id in user.ops_allowed_branch_ids:
                    user.primary_branch_id = user.ops_default_branch_id
                # Otherwise use first allowed branch
                elif user.ops_allowed_branch_ids:
                    user.primary_branch_id = user.ops_allowed_branch_ids[0]
    
    @api.constrains('ops_default_branch_id', 'ops_allowed_branch_ids')
    def _check_default_branch_in_allowed(self):
        """Ensure default branch is in user's allowed branches."""
        for user in self:
            if (user.ops_default_branch_id and
                user.ops_default_branch_id not in user.ops_allowed_branch_ids):
                raise ValidationError(_(
                    "Default branch '%(branch_name)s' must be in user's allowed branches."
                ) % {
                    'branch_name': user.ops_default_branch_id.name
                })
    
    @api.constrains('ops_default_business_unit_id', 'ops_allowed_business_unit_ids')
    def _check_default_bu_in_allowed(self):
        """Ensure default BU is in user's allowed business units."""
        for user in self:
            if (user.ops_default_business_unit_id and 
                user.ops_default_business_unit_id not in user.ops_allowed_business_unit_ids):
                raise ValidationError(_(
                    "Default business unit '%(bu_name)s' must be in user's allowed business units."
                ) % {
                    'bu_name': user.ops_default_business_unit_id.name
                })
    
    @api.constrains('ops_allowed_branch_ids')
    def _check_branch_company_consistency(self):
        """Ensure all allowed branches belong to user's companies."""
        for user in self:
            if user.ops_allowed_branch_ids and user.company_ids:
                # ops.branch has company_id field linking to res.company
                invalid_branches = user.ops_allowed_branch_ids.filtered(
                    lambda b: b.company_id not in user.company_ids
                )
                if invalid_branches:
                    raise ValidationError(_(
                        "Branches %(branch_names)s do not belong to any of user's companies %(company_names)s."
                    ) % {
                        'branch_names': ', '.join(invalid_branches.mapped('name')),
                        'company_names': ', '.join(user.company_ids.mapped('name'))
                    })
    
    @api.constrains('primary_branch_id', 'ops_allowed_business_unit_ids', 'persona_id')
    def _check_user_matrix_requirements(self):
        """
        Ensure user has Primary Branch, at least one Business Unit, and a Persona assigned.
        Exception: Admin (ID 1) and Settings Managers are exempt from this check.
        
        Note: Setting a Persona is the first step - it will trigger auto-population of
        Primary Branch and Business Units if they are empty.
        """
        for user in self:
            # Skip admin user
            if user.id == 1:
                continue
            
            # Skip Settings Managers
            if user.has_group('base.group_system'):
                continue
            
            # Skip if user is being created (not yet saved)
            if not user.id:
                continue
            
            # Skip portal/public users
            if user.share:
                continue
            
            # If persona is assigned, allow save even if other fields are empty
            # The onchange will auto-populate them
            if user.persona_id:
                # Persona is set - this satisfies the first requirement
                # The system will auto-populate Primary Branch and BU
                continue
            
            # Validation: Persona required as first step
            if not user.persona_id:
                raise ValidationError(_(
                    "User '%(user_name)s' cannot be saved without an OPS Persona.\n\n"
                    "Please go to the 'OPS Matrix Access' tab and select a Persona first.\n"
                    "The system will then automatically populate Primary Branch and Business Units."
                ) % {'user_name': user.name})
    
    # ========================================================================
    # CRUD OVERRIDE
    # ========================================================================
    
    def write(self, vals):
        """
        Override write to handle matrix access changes and persona assignment.
        Important: Update dependent records and log changes for security audit.
        """
        # Track changes for audit
        matrix_fields = [
            'ops_allowed_branch_ids', 'ops_allowed_business_unit_ids',
            'ops_default_branch_id', 'ops_default_business_unit_id',
            'is_cross_branch_bu_leader', 'is_matrix_administrator', 'persona_id'
        ]
        
        matrix_changes = any(field in vals for field in matrix_fields)
        persona_changed = 'persona_id' in vals
        
        # Perform the write
        result = super().write(vals)
        
        # AUTO-SYNC: If persona changed, auto-populate and map groups
        if persona_changed:
            for user in self:
                # Auto-populate Primary Branch if empty
                if not user.primary_branch_id and user.persona_id:
                    main_branch = self.env['ops.branch'].search([
                        ('company_id', '=', user.company_id.id),
                        ('active', '=', True)
                    ], limit=1, order='sequence, id')
                    
                    if main_branch:
                        # Direct write to avoid recursion
                        super(ResUsers, user).write({'primary_branch_id': main_branch.id})
                        _logger.info(f"Auto-populated Primary Branch for user {user.name}: {main_branch.name}")
                
                # Auto-map security groups
                user._map_persona_to_groups()
        
        # Log matrix access changes for security audit
        if matrix_changes:
            for user in self:
                _logger.info(
                    f"User {user.name} (ID: {user.id}) matrix access rights modified. "
                    f"Changes: {', '.join([k for k in vals.keys() if k in matrix_fields])}"
                )
                
                # Post message for audit trail on partner (users don't have message_post)
                if user.partner_id:
                    user.partner_id.message_post(
                        body=_('Matrix access rights updated by %s') % self.env.user.name,
                        subject=_('Security Configuration Change')
                    )
        
        return result
    
    # ========================================================================
    # CONTEXT METHODS FOR DEFAULTS
    # ========================================================================
    
    @api.model
    def _get_default_branch_context(self):
        """Get default branch for context based on user's settings."""
        user = self.env.user
        if user.ops_default_branch_id:
            return {'default_ops_branch_id': user.ops_default_branch_id.id}
        return {}
    
    @api.model
    def _get_default_bu_context(self):
        """Get default BU for context based on user's settings."""
        user = self.env.user
        if user.ops_default_business_unit_id:
            return {'default_ops_business_unit_id': user.ops_default_business_unit_id.id}
        return {}
    
    def get_context_with_matrix_defaults(self):
        """Return context dictionary with matrix defaults."""
        context = self._context.copy()
        context.update(self._get_default_branch_context())
        context.update(self._get_default_bu_context())
        return context
    
    # ========================================================================
    # ACTION METHODS FOR UI
    # ========================================================================
    
    def action_view_allowed_branches(self):
        """Open view of user's allowed branches."""
        self.ensure_one()
        return {
            'name': _('Allowed Branches'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.branch',
            'view_mode': 'list,form',
            'domain': [('id', 'in', self.ops_allowed_branch_ids.ids)],
            'context': {
                'search_default_active': 1,
            }
        }
    
    def action_view_allowed_business_units(self):
        """Open view of user's allowed business units."""
        self.ensure_one()
        return {
            'name': _('Allowed Business Units'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.business.unit',
            'view_mode': 'tree,form',
            'domain': [('id', 'in', self.ops_allowed_business_unit_ids.ids)],
            'context': {
                'search_default_active': 1,
            }
        }
    
    def action_reset_matrix_access(self):
        """Reset matrix access to defaults (company-level)."""
        self.ensure_one()
        
        # Get all branches in user's companies
        company_branches = self.env['ops.branch'].search([
            ('company_id', 'in', self.company_ids.ids),
            ('active', '=', True)
        ])
        
        # Get all BUs in those branches
        company_bus = self.env['ops.business.unit'].search([
            ('branch_ids', 'in', company_branches.ids),
            ('active', '=', True)
        ])
        
        # Update user
        self.write({
            'ops_allowed_branch_ids': [(6, 0, company_branches.ids)],
            'ops_allowed_business_unit_ids': [(6, 0, company_bus.ids)],
            'ops_default_branch_id': company_branches[0].id if company_branches else False,
            'ops_default_business_unit_id': company_bus[0].id if company_bus else False,
        })
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Matrix Access Reset'),
                'message': _('Matrix access has been reset to company defaults.'),
                'type': 'success',
                'sticky': False,
            }
        }
    
    # ========================================================================
    # GROUP SYNCHRONIZATION
    # ========================================================================
    
    @api.depends('groups_id')
    def _compute_matrix_roles_from_groups(self):
        """Sync group membership with role boolean fields."""
        matrix_admin_group = self.env.ref('ops_matrix_core.group_ops_matrix_administrator', False)
        cross_branch_group = self.env.ref('ops_matrix_core.group_ops_cross_branch_bu_leader', False)
        
        for user in self:
            if matrix_admin_group:
                user.is_matrix_administrator = matrix_admin_group in user.groups_id
            if cross_branch_group:
                user.is_cross_branch_bu_leader = cross_branch_group in user.groups_id
    
    @api.onchange('is_matrix_administrator')
    def _onchange_is_matrix_administrator(self):
        """Update group membership when role changes."""
        # Skip if record not yet created (groups_id not available on new records in onchange)
        if not self.id:
            return
        matrix_admin_group = self.env.ref('ops_matrix_core.group_ops_matrix_administrator', False)
        if matrix_admin_group:
            if self.is_matrix_administrator:
                self.groups_id = [(4, matrix_admin_group.id)]
            else:
                self.groups_id = [(3, matrix_admin_group.id)]
    
    @api.onchange('is_cross_branch_bu_leader')
    def _onchange_is_cross_branch_bu_leader(self):
        """Update group membership when role changes."""
        # Skip if record not yet created (groups_id not available on new records in onchange)
        if not self.id:
            return
        cross_branch_group = self.env.ref('ops_matrix_core.group_ops_cross_branch_bu_leader', False)
        if cross_branch_group:
            if self.is_cross_branch_bu_leader:
                self.groups_id = [(4, cross_branch_group.id)]
            else:
                self.groups_id = [(3, cross_branch_group.id)]
    
    # ========================================================================
    # PERSONA AUTO-SYNC: ZERO-FRICTION SETUP
    # ========================================================================
    
    @api.onchange('persona_id')
    def _onchange_persona_id(self):
        """
        AUTO-SYNC LOGIC: When a persona is assigned:
        1. Auto-populate Primary Branch (use company's first branch)
        2. Auto-map Odoo 19 security groups based on persona
        3. Prevent "Primary Branch is missing" error
        """
        for user in self:
            if not user.persona_id:
                continue
            
            # Step 1: Auto-populate Primary Branch if empty
            if not user.primary_branch_id:
                # Find the first branch in the user's company
                main_branch = self.env['ops.branch'].search([
                    ('company_id', '=', user.company_id.id),
                    ('active', '=', True)
                ], limit=1, order='sequence, id')
                
                if main_branch:
                    user.primary_branch_id = main_branch
                    _logger.info(f"Auto-populated Primary Branch for user {user.name}: {main_branch.name}")
            
            # Step 2: Auto-map security groups based on persona code
            user._map_persona_to_groups()
    
    def _map_persona_to_groups(self):
        """
        Map persona to Odoo 19 security groups automatically.
        This is the "Zero-Friction" setup logic.
        """
        self.ensure_one()
        
        if not self.persona_id:
            return
        
        persona_code = self.persona_id.code
        groups_to_add = []
        
        # Persona â†’ Group Mapping
        persona_group_map = {
            'CEO': [
                'base.group_erp_manager',  # Access Rights
                'sales_team.group_sale_manager',  # Sales Manager
                'account.group_account_manager',  # Billing Manager
                'stock.group_stock_manager',  # Inventory Manager
                'ops_matrix_core.group_ops_executive',  # OPS Executive
                'ops_matrix_core.group_ops_matrix_administrator',  # Matrix Admin
            ],
            'CFO': [
                'account.group_account_manager',  # Billing Manager
                'account.group_account_user',  # Billing
                'ops_matrix_core.group_ops_executive',  # OPS Executive
                'ops_matrix_core.group_ops_cost_controller',  # Cost Controller
            ],
            'SALES_LEADER': [
                'sales_team.group_sale_manager',  # Sales Manager
                'sale.group_sale_manager',  # Administrator
                'ops_matrix_core.group_ops_bu_leader',  # BU Leader
            ],
            'SALES_MGR': [
                'sales_team.group_sale_manager',  # Sales Manager
                'sale.group_sale_salesman_all_leads',  # See All Leads
                'ops_matrix_core.group_ops_manager',  # OPS Manager
            ],
            'SALES_REP': [
                'sales_team.group_sale_salesman',  # User: Own Documents Only
                'sale.group_sale_salesman',  # User: Own Documents Only
                'ops_matrix_core.group_ops_user',  # OPS User
            ],
            'HR_MGR': [
                'hr.group_hr_manager',  # Officer (if HR installed)
                'ops_matrix_core.group_ops_manager',  # OPS Manager
            ],
            'CHIEF_ACCT': [
                'account.group_account_manager',  # Billing Manager
                'account.group_account_user',  # Billing
                'ops_matrix_core.group_ops_manager',  # OPS Manager
            ],
            'ACCOUNTANT': [
                'account.group_account_user',  # Billing
                'account.group_account_invoice',  # Billing
                'ops_matrix_core.group_ops_user',  # OPS User
            ],
            'LOG_MGR': [
                'stock.group_stock_manager',  # Inventory Manager
                'ops_matrix_core.group_ops_branch_manager',  # Branch Manager
                'ops_matrix_core.group_ops_manager',  # OPS Manager
            ],
            'LOG_CLERK': [
                'stock.group_stock_user',  # User
                'ops_matrix_core.group_ops_user',  # OPS User
            ],
            'TECH_SUPPORT': [
                'base.group_user',  # Internal User
                'ops_matrix_core.group_ops_user',  # OPS User
            ],
            'SYS_ADMIN': [
                'base.group_system',  # Settings
                'ops_matrix_core.group_ops_matrix_administrator',  # Matrix Admin
            ],
        }
        
        # Get groups for this persona
        group_xmlids = persona_group_map.get(persona_code, [])
        
        for xmlid in group_xmlids:
            try:
                group = self.env.ref(xmlid, raise_if_not_found=False)
                if group:
                    groups_to_add.append(group.id)
            except Exception as e:
                _logger.warning(f"Could not find group {xmlid}: {e}")
        
        # Add groups to user
        if groups_to_add:
            self.groups_id = [(4, gid) for gid in groups_to_add]
            _logger.info(f"Auto-mapped {len(groups_to_add)} groups to user {self.name} based on persona {persona_code}")
    
    # ========================================================================
    # PERSONA INTEGRATION
    # ========================================================================
    
    def _get_effective_persona(self):
        """Get the effective persona considering delegations."""
        self.ensure_one()
        
        # Check if there's an active delegation TO this user
        delegation = self.env['ops.persona.delegation'].search([
            ('delegate_id', '=', self.id),
            ('active', '=', True),
            ('start_date', '<=', fields.Date.today()),
            '|',
            ('end_date', '=', False),
            ('end_date', '>=', fields.Date.today()),
        ], limit=1)
        
        if delegation:
            return delegation.delegator_id.persona_id
        
        # Return user's own persona
        return self.persona_id
    
    # ========================================================================
    # REST API AUTHENTICATION FIELDS
    # ========================================================================
    
    ops_api_key = fields.Char(
        string='API Key',
        copy=False,
        groups='base.group_system',
        help='API key for REST API authentication. Keep this secret! '
             'Used in X-API-Key header for API requests.'
    )
    
    ops_api_key_created = fields.Datetime(
        string='API Key Created',
        copy=False,
        readonly=True,
        groups='base.group_system',
        help='Timestamp when the current API key was generated'
    )
    
    ops_api_rate_limit = fields.Integer(
        string='API Rate Limit (per hour)',
        default=1000,
        groups='base.group_system',
        help='Maximum number of API calls this user can make per hour. '
             'Default: 1000 calls/hour'
    )
    
    # ========================================================================
    # DASHBOARD CONFIGURATION FIELDS
    # ========================================================================
    
    # Dashboard Configuration
    ops_dashboard_config = fields.Json(
        string='Dashboard Configuration',
        help='User-specific dashboard configuration'
    )
    
    # Favorite Dashboards
    favorite_dashboard_ids = fields.Many2many(
        'ir.actions.act_window',
        'user_favorite_dashboard_rel',
        'user_id',
        'action_id',
        string='Favorite Dashboards',
        help='User\'s favorite dashboard actions'
    )
    
    # Dashboard Last Accessed
    last_dashboard_access = fields.Datetime(
        string='Last Dashboard Access',
        help='Timestamp of last dashboard access'
    )
    
    def get_dashboard_config(self):
        """Get user's dashboard configuration with defaults."""
        self.ensure_one()
        
        default_config = {
            'dashboard_layout': 'standard',
            'default_date_range': 'month',
            'show_branch_first': True,
            'include_inactive_dimensions': False,
            'color_scheme': 'corporate',
            'primary_color': '#1f77b4',
            'secondary_color': '#ff7f0e',
            'success_color': '#2ca02c',
            'warning_color': '#d62728',
            'cache_duration': 15,
            'auto_refresh': True,
            'refresh_interval': 300,
        }
        
        user_config = self.ops_dashboard_config or {}
        return {**default_config, **user_config}
    
    def action_open_dashboard_config(self):
        """Open dashboard configuration wizard."""
        self.ensure_one()
        
        return {
            'name': _('Dashboard Configuration'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.dashboard.config',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_user_id': self.id,
            }
        }
    
    # ========================================================================
    # REST API KEY MANAGEMENT ACTIONS
    # ========================================================================
    
    def action_generate_api_key(self):
        """Generate a new secure API key for the user."""
        self.ensure_one()
        
        import secrets
        
        # Generate secure random key (32 bytes = 256 bits)
        new_key = secrets.token_urlsafe(32)
        
        self.write({
            'ops_api_key': new_key,
            'ops_api_key_created': fields.Datetime.now()
        })
        
        _logger.info(f"API key generated for user {self.name} (ID: {self.id})")
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('API Key Generated'),
                'message': _('New API key: %s\n\nSave this key securely. It will not be shown again.') % new_key,
                'type': 'success',
                'sticky': True,
            }
        }
    
    def action_revoke_api_key(self):
        """Revoke the user's API key."""
        self.ensure_one()
        
        self.write({
            'ops_api_key': False,
            'ops_api_key_created': False
        })
        
        _logger.warning(f"API key revoked for user {self.name} (ID: {self.id})")
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('API Key Revoked'),
                'message': _('API key has been revoked. Generate a new key to continue using the API.'),
                'type': 'warning',
            }
        }

--- ops_matrix_core/models/sale_order.py ---
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
from typing import List, Dict, Any, Tuple
import base64
import io
import logging

_logger = logging.getLogger(__name__)
try:
    from pypdf import PdfMerger
except ImportError:
    try:
        from PyPDF2 import PdfMerger
    except ImportError:
        PdfMerger = None

class SaleOrder(models.Model):
    _name = 'sale.order'
    _inherit = ['sale.order', 'ops.governance.mixin', 'ops.matrix.mixin']
    
    # Governance Fields (explicitly declared for proper column creation)
    approval_locked = fields.Boolean(
        string='Approval Locked',
        default=False,
        help='Record is locked pending approval',
        copy=False
    )
    
    # Note: ops_branch_id and ops_business_unit_id are inherited from ops.matrix.mixin
    # Additional sale order specific fields
    ops_credit_check_passed = fields.Boolean(
        string='Credit Check Passed',
        default=False,
        readonly=True,
        help='Indicates if partner passed credit firewall check'
    )
    ops_credit_check_notes = fields.Text(
        string='Credit Check Notes',
        readonly=True,
        help='Notes from credit firewall evaluation'
    )

    @api.constrains('order_line')
    def _check_business_unit_silo(self) -> None:
        """
        Strictly enforce that a user can only sell products belonging to
        their allowed Business Units.
        
        Note: This constraint works alongside the governance rules engine.
        For more complex rules, use ops.governance.rule instead.
        """
        for order in self:
            # Skip check for Superuser/Admin to allow setup
            if order.env.is_superuser():
                continue

            # Get user's allowed units (from persona or legacy fields)
            effective_access = order.user_id.get_effective_matrix_access()
            user_allowed_units = effective_access['business_unit_ids'].ids if effective_access['business_unit_ids'] else []
            
            for line in order.order_line:
                product_unit = line.product_id.business_unit_id
                
                # If product has a unit, and it's not in user's allowed list
                if product_unit and product_unit.id not in user_allowed_units:
                    raise ValidationError(_(
                        "SILO VIOLATION: You cannot sell product '%s' (Unit: %s). "
                        "You are not assigned to this Business Unit."
                    ) % (line.product_id.name, product_unit.name))

    def _get_products_availability_data(self) -> List[Dict[str, Any]]:
        """
        Task 4: Prepare data for Products Availability Report.
        Returns availability data for each storable product in the sale order.
        """
        self.ensure_one()
        availability_data = []
        
        for line in self.order_line:
            product = line.product_id
            
            # Skip service and consumable products
            if product.type in ['service', 'consu']:
                continue
            
            # Get stock on hand for the product
            stock_on_hand = product.qty_available
            
            # Calculate display qty = min(ordered qty, stock on hand)
            display_qty = min(line.product_uom_qty, stock_on_hand)
            
            # Determine if stock is insufficient (for styling)
            is_insufficient = stock_on_hand < line.product_uom_qty
            
            availability_data.append({
                'sku': product.default_code or '',
                'product_name': product.name,
                'ordered_qty': line.product_uom_qty,
                'stock_on_hand': stock_on_hand,
                'display_qty': display_qty,
                'is_insufficient': is_insufficient,
            })
        
        return availability_data

    def _check_partner_credit_firewall(self) -> Tuple[bool, str]:
        """
        Credit Firewall: Check if partner can have this order confirmed.
        Returns (passed: bool, message: str)
        """
        self.ensure_one()
        
        if self.env.is_superuser():
            return True, 'Superuser bypass'
        
        partner = self.partner_id
        
        # Check 1: Partner Stewardship State
        if hasattr(partner, 'ops_state'):
            if partner.ops_state not in ['approved']:
                return False, f'Partner state is "{partner.ops_state}" - orders cannot be confirmed'
            
            if partner.ops_state == 'blocked':
                return False, 'Partner is blocked from transactions'
        
        # Check 2: Partner Activity
        if not partner.active:
            return False, 'Partner is inactive'
        
        # Check 3: Credit Limit Enforcement
        if hasattr(partner, 'ops_credit_limit') and hasattr(partner, 'ops_total_outstanding'):
            if partner.ops_credit_limit > 0:
                total_outstanding = partner.ops_total_outstanding
                potential_total = total_outstanding + self.amount_total
                
                if potential_total > partner.ops_credit_limit:
                    return False, (
                        f'Order would exceed credit limit. '
                        f'Current outstanding: {total_outstanding}, '
                        f'Order amount: {self.amount_total}, '
                        f'Credit limit: {partner.ops_credit_limit}'
                    )
        
        # Check 4: Partner Confirmation Restrictions (if field exists)
        if hasattr(partner, 'ops_confirmation_restrictions'):
            if partner.ops_confirmation_restrictions:
                return False, f'Partner restrictions: {partner.ops_confirmation_restrictions}'
        
        return True, 'Credit check passed'
    
    def action_confirm(self) -> bool:
        """
        Override action_confirm to enforce credit firewall and governance rules.
        
        This ensures that:
        1. Governance rules (margins, discounts, approvals) are enforced
        2. Credit firewall checks pass
        3. All validations happen before state changes to 'sale'
        """
        for order in self:
            _logger.info("OPS Governance: Checking SO %s for confirmation rules", order.name)
            
            # ADMIN BYPASS: Skip governance for administrators
            if self.env.su or self.env.user.has_group('base.group_system'):
                _logger.info("OPS Governance: Admin bypass for SO %s", order.name)
                # Log admin override for audit trail
                try:
                    self.env['ops.security.audit'].sudo().log_security_override(
                        model_name=order._name,
                        record_id=order.id,
                        reason='Admin bypass used to confirm Sale Order without governance checks'
                    )
                except Exception as e:
                    _logger.warning("Failed to log admin override: %s", str(e))
            else:
                # Explicitly trigger Governance check for 'on_write' triggers
                # This catches rules like:
                # - "Discounts > 20% require approval"
                # - "Margins < 15% require approval"
                # - "Orders > $50K require approval"
                order._enforce_governance_rules(order, trigger_type='on_write')
                
                _logger.info("OPS Governance: SO %s passed all governance checks", order.name)
            
            # Perform credit check
            passed, message = order._check_partner_credit_firewall()
            
            if not passed:
                order.write({
                    'ops_credit_check_passed': False,
                    'ops_credit_check_notes': message
                })
                raise UserError(_('Credit Firewall: ' + message))
            
            order.write({
                'ops_credit_check_passed': True,
                'ops_credit_check_notes': message
            })
        
        # Call parent method to confirm
        return super().action_confirm()
    
    def action_quotation_send(self):
        """
        Override email sending to enforce governance rules.
        
        This prevents users from sending quotations/orders by email
        if they violate governance rules or have pending approvals.
        """
        # ADMIN BYPASS: Allow administrators to send anything
        if self.env.su or self.env.user.has_group('base.group_system'):
            # Log admin override for audit trail
            try:
                for order in self:
                    self.env['ops.security.audit'].sudo().log_security_override(
                        model_name=order._name,
                        record_id=order.id,
                        reason='Admin bypass used to send Sale Order/Quotation without governance checks'
                    )
            except Exception as e:
                _logger.warning("Failed to log admin override: %s", str(e))
            return super().action_quotation_send()
        
        for order in self:
            _logger.info("OPS Governance: Checking SO %s for email commitment", order.name)
            
            # Check for pending approvals
            if hasattr(order, 'approval_request_ids'):
                pending_approvals = order.approval_request_ids.filtered(
                    lambda a: a.state == 'pending'
                )
                
                if pending_approvals:
                    rule_names = ', '.join(pending_approvals.mapped('rule_id.name'))
                    raise UserError(_(
                        "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s' "
                        "until it satisfies company Governance Rules.\n\n"
                        "â³ Pending Approval: %s\n\n"
                        "This document is locked for external commitment (email or print) "
                        "until the required approvals are granted."
                    ) % (order.display_name, rule_names))
            
            # Enforce governance rules
            try:
                order._enforce_governance_rules(order, trigger_type='on_write')
                _logger.info("OPS Governance: SO %s passed all governance checks for email", order.name)
            except UserError as e:
                # Re-raise with enhanced message for email context
                error_message = str(e)
                if 'requires approval' in error_message.lower():
                    raise UserError(_(
                        "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n"
                        "%s\n\n"
                        "External commitment (email/print) is blocked until approval is granted."
                    ) % (order.display_name, error_message))
                else:
                    raise UserError(_(
                        "ðŸš« COMMITMENT BLOCKED: You cannot Email document '%s'.\n\n%s"
                    ) % (order.display_name, error_message))
        
        # If all checks pass, proceed with email wizard
        return super().action_quotation_send()
    
    @api.model_create_multi
    def create(self, vals_list):
        """Override create to propagate matrix dimensions to lines."""
        orders = super().create(vals_list)
        for order in orders:
            if order.order_line:
                order._propagate_matrix_to_lines('order_line')
        return orders
    
    @api.onchange('ops_branch_id', 'ops_business_unit_id')
    def _onchange_matrix_dimensions(self):
        """Propagate matrix dimensions to order lines when changed."""
        super()._onchange_matrix_dimensions()
        if self.order_line:
            for line in self.order_line:
                line.ops_branch_id = self.ops_branch_id
                line.ops_business_unit_id = self.ops_business_unit_id
    
    def _prepare_invoice(self):
        """Propagate matrix dimensions to invoice."""
        invoice_vals = super()._prepare_invoice()
        invoice_vals.update(self._prepare_invoice_vals())
        return invoice_vals

    def action_print_product_bundle(self) -> Dict[str, Any]:
        """
        Task 5: Bulk Product Doc Generator (Smart Merge)
        Generate a single merged PDF of product documents (datasheets) for a sale order,
        removing duplicates using SHA-1 checksums.
        """
        self.ensure_one()
        
        if not PdfMerger:
            raise UserError(_('PyPDF library is not installed. Cannot merge PDFs.'))
        
        # Collect all PDF attachments from products
        pdf_attachments = []
        seen_checksums = set()
        
        for line in self.order_line:
            product = line.product_id
            
            # Find PDF attachments linked to this product
            attachments = self.env['ir.attachment'].search([
                ('res_model', '=', 'product.product'),
                ('res_id', '=', product.id),
                ('mimetype', '=', 'application/pdf'),
            ])
            
            # Also check product template attachments
            if product.product_tmpl_id:
                template_attachments = self.env['ir.attachment'].search([
                    ('res_model', '=', 'product.template'),
                    ('res_id', '=', product.product_tmpl_id.id),
                    ('mimetype', '=', 'application/pdf'),
                ])
                attachments |= template_attachments
            
            # Deduplicate by checksum
            for attachment in attachments:
                checksum = attachment.checksum
                if checksum and checksum not in seen_checksums:
                    seen_checksums.add(checksum)
                    pdf_attachments.append(attachment)
        
        if not pdf_attachments:
            raise UserError(_('No PDF documents found for the products in this sale order.'))
        
        # Merge PDFs
        merger = PdfMerger()
        
        try:
            for attachment in pdf_attachments:
                # Decode base64 attachment data
                pdf_data = base64.b64decode(attachment.datas)
                pdf_stream = io.BytesIO(pdf_data)
                merger.append(pdf_stream)
            
            # Get merged PDF output
            output_stream = io.BytesIO()
            merger.write(output_stream)
            merger.close()
            output_stream.seek(0)
            
            # Encode to base64
            merged_pdf_data = base64.b64encode(output_stream.read()).decode('utf-8')
            
            # Create attachment for the merged PDF
            attachment = self.env['ir.attachment'].create({
                'name': f'Product_Bundle_{self.name}.pdf',
                'type': 'binary',
                'datas': merged_pdf_data,
                'res_model': 'sale.order',
                'res_id': self.id,
                'mimetype': 'application/pdf',
            })
            
            # Return action to open the merged PDF in a new tab
            return {
                'type': 'ir.actions.act_url',
                'url': f'/web/content/{attachment.id}?download=true',
                'target': 'new',
            }
            
        except Exception as e:
            raise UserError(_('Error merging PDFs: %s') % str(e))


class SaleOrderLine(models.Model):
    """Extend sale.order.line with Matrix Mixin for dimension propagation."""
    _inherit = ['sale.order.line', 'ops.matrix.mixin']
    _name = 'sale.order.line'
    
    # These fields are inherited from ops.matrix.mixin:
    # - ops_branch_id
    # - ops_business_unit_id
    # - ops_company_id
    # - ops_analytic_distribution
    
    # The Cost Shield: Field-Level Security for Sale Order Line Costs
    can_user_access_cost_prices = fields.Boolean(
        string='Can Access Cost Prices',
        compute='_compute_can_user_access_cost_prices',
        store=False,
        help="Determines if the current user can view cost prices on sale order lines."
    )
    
    # Cost Shield Protected Fields - ISS-002 Hardening
    # These fields are restricted to Administrators and OPS Managers only
    # Model-level security prevents both UI and API access by unauthorized users
    purchase_price = fields.Float(
        string='Cost',
        compute='_compute_purchase_price',
        digits='Product Price',
        store=True,
        groups="base.group_system,ops_matrix_core.group_ops_manager",
        help="Unit cost price from product (protected field - Admin/OPS Manager only)"
    )
    
    margin = fields.Float(
        string='Margin',
        compute='_compute_margin',
        digits='Product Price',
        store=True,
        groups="base.group_system,ops_matrix_core.group_ops_manager",
        help="Gross margin amount (Sale Price - Cost) x Quantity (protected field - Admin/OPS Manager only)"
    )
    
    margin_percent = fields.Float(
        string='Margin %',
        compute='_compute_margin',
        store=True,
        groups="base.group_system,ops_matrix_core.group_ops_manager",
        help="Gross margin percentage (protected field - Admin/OPS Manager only)"
    )
    
    @api.depends_context('uid')
    def _compute_can_user_access_cost_prices(self):
        """
        Check if user has authority to view cost prices on sale order lines.
        
        Security Logic:
        - System administrators (base.group_system) always have access
        - Other users must have 'can_access_cost_prices' authority flag
        - This protects margin calculations from unauthorized viewing
        
        This implements "The Cost Shield" anti-fraud measure.
        """
        for record in self:
            # Administrators bypass all restrictions
            if self.env.user.has_group('base.group_system'):
                record.can_user_access_cost_prices = True
            else:
                # Check persona authority flag
                record.can_user_access_cost_prices = self.env.user.has_ops_authority('can_access_cost_prices')
    
    @api.depends('product_id', 'product_uom_id', 'product_uom_qty')
    def _compute_purchase_price(self):
        """
        Compute the unit cost (purchase price) from product standard_price.
        
        ISS-002 Security: This field is protected by model-level groups,
        preventing unauthorized users from accessing cost data via UI or API.
        """
        for line in self:
            if line.product_id:
                # Convert to line UOM if different from product UOM
                line.purchase_price = line.product_id.standard_price
            else:
                line.purchase_price = 0.0
    
    @api.depends('product_id', 'purchase_price', 'product_uom_qty', 'price_unit', 'price_subtotal')
    def _compute_margin(self):
        """
        Compute margin and margin percentage for sale order lines.
        
        ISS-002 Security: These fields are protected by model-level groups,
        preventing unauthorized users from accessing margin data via UI or API.
        
        Calculation:
        - Margin = (Unit Price - Cost) * Quantity
        - Margin % = (Margin / Sale Price) * 100 if Sale Price > 0
        """
        for line in self:
            if line.product_id:
                # Calculate total cost
                total_cost = line.purchase_price * line.product_uom_qty
                
                # Calculate margin (subtotal - cost)
                line.margin = line.price_subtotal - total_cost
                
                # Calculate margin percentage
                if line.price_subtotal:
                    line.margin_percent = (line.margin / line.price_subtotal) * 100.0
                else:
                    line.margin_percent = 0.0
            else:
                line.margin = 0.0
                line.margin_percent = 0.0
    
    def _get_default_ops_branch(self):
        """Get default branch from parent order if available."""
        if self._context.get('default_order_id'):
            order = self.env['sale.order'].browse(self._context['default_order_id'])
            if order.ops_branch_id:
                return order.ops_branch_id.id
        return super()._get_default_ops_branch()
    
    def _get_default_ops_business_unit(self):
        """Get default BU from parent order if available."""
        if self._context.get('default_order_id'):
            order = self.env['sale.order'].browse(self._context['default_order_id'])
            if order.ops_business_unit_id:
                return order.ops_business_unit_id.id
        return super()._get_default_ops_business_unit()
    
    @api.onchange('order_id')
    def _onchange_order_id_propagate_dimensions(self):
        """
        When order_id changes or is set, inherit the order's matrix dimensions.
        
        This ensures that when a line is added to an order with specific dimensions,
        it automatically gets the correct dimensions.
        """
        if self.order_id:
            # Inherit dimensions from parent order if not already set
            if not self.ops_branch_id and self.order_id.ops_branch_id:
                self.ops_branch_id = self.order_id.ops_branch_id
            if not self.ops_business_unit_id and self.order_id.ops_business_unit_id:
                self.ops_business_unit_id = self.order_id.ops_business_unit_id

--- ops_matrix_core/models/sale_order_import_wizard.py ---
from odoo import models, fields, api, _
from typing import TYPE_CHECKING
from odoo.exceptions import ValidationError
import base64
import io
try:
    import openpyxl
except ImportError:
    openpyxl = None

if TYPE_CHECKING:
    from odoo.api import Environment

class SaleOrderImportWizard(models.TransientModel):
    _name = 'sale.order.import.wizard'
    _description = 'Sales Order Excel Import Wizard'

    sale_order_id = fields.Many2one('sale.order', string='Sales Order', required=True)
    excel_file = fields.Binary(string='Excel File', required=True, help='Upload Excel file with columns: Section, Part Number, Quantity')
    file_name = fields.Char(string='File Name')
    import_result = fields.Text(string='Import Result', readonly=True)
    
    def action_validate_and_import(self):
        """Validate Excel file and import SO lines"""
        if not self.excel_file:
            raise ValidationError(_('Please upload an Excel file.'))
        
        if not openpyxl:
            raise ValidationError(_('openpyxl library is not installed. Please install it to use Excel import functionality.'))
        
        try:
            # Read Excel file
            excel_data = base64.b64decode(self.excel_file)
            workbook = openpyxl.load_workbook(io.BytesIO(excel_data))
            sheet = workbook.active
            
            # Get header row and validate columns
            headers = []
            for cell in sheet[1]:
                headers.append(cell.value)
            
            required_columns = ['Section', 'Part Number', 'Quantity']
            missing_columns = [col for col in required_columns if col not in headers]
            if missing_columns:
                raise ValidationError(_('Missing required columns: %s') % ', '.join(missing_columns))
            
            # Get column indices
            col_indices = {col: headers.index(col) for col in headers}
            
            # Validate all rows first (all-or-nothing approach)
            missing_parts = []
            product_model = self.env['product.product']
            
            for row_idx, row in enumerate(sheet.iter_rows(min_row=2, values_only=True), start=2):
                if not any(row):
                    continue  # Skip empty rows
                    
                part_number = str(row[col_indices['Part Number']]).strip() if col_indices['Part Number'] < len(row) else ''
                if part_number and part_number.lower() not in ['none', 'nan']:
                    product = product_model.search([('default_code', '=', part_number)], limit=1)
                    if not product:
                        missing_parts.append(f"Row {row_idx}: {part_number} not found")
            
            # If any parts are missing, show error with all missing parts
            if missing_parts:
                error_message = _('The following part numbers were not found in the system:\n\n') + '\n'.join(missing_parts)
                self.import_result = error_message
                return {
                    'type': 'ir.actions.act_window',
                    'name': _('Import Validation Error'),
                    'res_model': 'sale.order.import.wizard',
                    'res_id': self.id,
                    'view_mode': 'form',
                    'target': 'new',
                }
            
            # All validations passed, create SO lines
            line_commands = []
            for row_idx, row in enumerate(sheet.iter_rows(min_row=2, values_only=True), start=2):
                if not any(row):
                    continue  # Skip empty rows
                    
                section = str(row[col_indices['Section']]).strip() if col_indices['Section'] < len(row) else ''
                part_number = str(row[col_indices['Part Number']]).strip() if col_indices['Part Number'] < len(row) else ''
                
                # Handle quantity with proper ternary operator
                if col_indices['Quantity'] < len(row) and row[col_indices['Quantity']] not in [None, '']:
                    quantity = float(row[col_indices['Quantity']])
                else:
                    quantity = 0
                
                # Handle section rows
                if section and (not part_number or part_number.lower() in ['none', 'nan']):
                    line_commands.append([fields.Command.create({
                        'display_type': 'line_section',
                        'name': section,
                    })])
                elif part_number and quantity > 0:
                    # Find product
                    product = product_model.search([('default_code', '=', part_number)], limit=1)
                    if product:
                        # Get price from pricelist
                        pricelist = self.sale_order_id.pricelist_id
                        price = pricelist._get_product_price(product, quantity, partner=self.sale_order_id.partner_id)
                        
                        line_commands.append([fields.Command.create({
                            'product_id': product.id,
                            'product_uom_qty': quantity,
                            'price_unit': price,
                            'name': product.display_name,
                        })])
            
            # Add lines to sales order
            if line_commands:
                self.sale_order_id.write({
                    'order_line': line_commands
                })
            
            self.import_result = _('Successfully imported %d lines.') % len(line_commands)
            
            return {
                'type': 'ir.actions.act_window',
                'name': _('Import Successful'),
                'res_model': 'sale.order.import.wizard',
                'res_id': self.id,
                'view_mode': 'form',
                'target': 'new',
            }
            
        except Exception as e:
            raise ValidationError(_('Error processing Excel file: %s') % str(e))

--- ops_matrix_core/models/stock_move.py ---
from odoo import models, fields, api

class StockMove(models.Model):
    _inherit = 'stock.move'

    branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        related='picking_id.branch_id',
        store=True,
        readonly=True,
        help="Branch related to this stock move"
    )

    business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        related='picking_id.business_unit_id',
        store=True,
        readonly=True,
        help="Business unit from the source document (Sale/Purchase Order)"
    )

    def _prepare_account_move_vals(self):
        """Override to add branch and business unit to accounting entries."""
        vals = super(StockMove, self)._prepare_account_move_vals()
        
        # Add matrix dimensions to account move
        vals.update({
            'branch_id': self.branch_id.id,
            'business_unit_id': self.business_unit_id.id,
        })

        # Add dimensions to all move lines
        if 'line_ids' in vals:
            for line in vals['line_ids']:
                if len(line) > 2 and isinstance(line[2], dict):
                    line[2].update({
                        'branch_id': self.branch_id.id,
                        'business_unit_id': self.business_unit_id.id,
                    })
        
        return vals

--- ops_matrix_core/models/stock_picking.py ---
from odoo import models, fields, api
from odoo.exceptions import ValidationError
from typing import List, Dict, Any

class StockPicking(models.Model):
    _inherit = ['stock.picking', 'ops.matrix.mixin']
    _name = 'stock.picking'

    # Note: branch fields now come from ops.matrix.mixin as ops_branch_id and ops_business_unit_id
    # Keeping legacy fields for backward compatibility
    branch_id = fields.Many2one(
        'res.company',
        string='Branch (Legacy)',
        related='ops_branch_id',
        store=True
    )

    business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit (Legacy)',
        related='ops_business_unit_id',
        store=True
    )

    @api.model_create_multi
    def create(self, vals_list: List[Dict[str, Any]]) -> 'StockPicking':
        """Override to set branch from user context if not provided."""
        for vals in vals_list:
            if not vals.get('branch_id'):
                vals['branch_id'] = self.env.user.branch_id.id
        return super().create(vals_list)

    def button_validate(self) -> bool:
        """
        Task 1: Enforce strict inventory at delivery.
        Prevent validation if it would cause negative stock (outgoing deliveries only).
        """
        # Only check for outgoing pickings (deliveries)
        for picking in self:
            if picking.picking_type_id.code == 'outgoing':
                # Check each move for stock availability
                for move in picking.move_ids:
                    # Skip if product is consumable or service type
                    if move.product_id.type in ['consu', 'service']:
                        continue
                    
                    # Get available quantity at source location
                    available_qty = move.product_id.with_context(
                        location=move.location_id.id
                    ).qty_available
                    
                    # Check if move would cause negative stock
                    if available_qty < move.product_uom_qty:
                        raise ValidationError(
                            f"Cannot validate delivery. Product '{move.product_id.display_name}' "
                            f"has insufficient stock in '{move.location_id.display_name}'. "
                            f"Available: {available_qty:.2f}, Required: {move.product_uom_qty:.2f}. "
                            f"You cannot drive stock into negative."
                        )
        
        return super().button_validate()

--- ops_matrix_core/models/stock_quant.py ---
from odoo import models, fields, api
from odoo.tools.float_utils import float_compare
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from odoo.api import Environment

class StockQuant(models.Model):
    _inherit = 'stock.quant'
    
    # ========================================================================
    # BUSINESS UNIT SEGMENTATION
    # ========================================================================
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        compute='_compute_ops_business_unit_id',
        store=True,
        index=True,
        help='Business unit this stock quant belongs to (from product assignment)'
    )
    
    # ========================================================================
    # COMPUTED FIELDS
    # ========================================================================
    @api.depends('product_id.business_unit_id')
    def _compute_ops_business_unit_id(self):
        """
        Compute business unit from the product's assignment.
        
        Stock quants inherit their BU from the product template.
        If a product has no BU assignment, the quant is considered "global"
        and can be used by any BU (subject to strict constraint checks).
        """
        for quant in self:
            if quant.product_id and quant.product_id.business_unit_id:
                quant.ops_business_unit_id = quant.product_id.business_unit_id.id
            else:
                quant.ops_business_unit_id = False
    
    # ========================================================================
    # OVERRIDE: Availability Checking with BU Constraints
    # ========================================================================
    def _get_available_quantity(
        self,
        product_id,
        location_id,
        lot_id=None,
        package_id=None,
        owner_id=None,
        strict=False,
        allow_negative=False,
        business_unit_id=None,
    ):
        """
        Override to enforce business unit constraints on stock reservation.
        
        CRITICAL CONSTRAINT:
        - A Sale Order for "Business Unit A" can ONLY reserve quants
          where ops_business_unit_id matches "Business Unit A"
        - Quants with NO business unit (global) can be reserved by any BU
          (This allows shared inventory while maintaining accounting separation)
        
        Performance Note: This uses pure SQL domain filtering, not Python loops,
        to keep the scheduler efficient even with large quant datasets.
        
        :param product_id: Product to check availability for
        :param location_id: Location to check in
        :param lot_id: Lot filter (optional)
        :param package_id: Package filter (optional)
        :param owner_id: Owner filter (optional)
        :param strict: Whether to enforce strict positivity
        :param allow_negative: Whether to allow negative stock
        :param business_unit_id: Business unit context for filtering
        :return: Available quantity respecting BU constraints
        """
        
        # If no BU context provided, use default (should not happen in normal flow)
        if not business_unit_id:
            # Try to get from context (set by sale order confirmation)
            business_unit_id = self.env.context.get('ops_business_unit_id')
        
        # Build domain for quant search with BU constraint
        domain = [
            ('product_id', '=', product_id.id),
            ('location_id', '=', location_id.id),
            ('quantity', '!=', 0),
        ]
        
        # ADD BUSINESS UNIT CONSTRAINT
        # Quants are available if:
        # 1. They belong to the requesting BU, OR
        # 2. They have NO BU assignment (global stock)
        if business_unit_id:
            domain.append(
                '|',
            )
            domain.append(
                ('ops_business_unit_id', '=', business_unit_id.id)
            )
            domain.append(
                ('ops_business_unit_id', '=', False)  # Global stock
            )
        else:
            # No BU context: only show global quants (safety constraint)
            domain.append(('ops_business_unit_id', '=', False))
        
        # Apply standard filters
        if lot_id:
            domain.append(('lot_id', '=', lot_id.id))
        if package_id:
            domain.append(('package_id', '=', package_id.id))
        if owner_id:
            domain.append(('owner_id', '=', owner_id.id))
        
        # Search with pure SQL domain (ORM will optimize at DB level)
        quants = self.search(domain)
        
        if strict:
            # Only positive quantities
            quants = quants.filtered(lambda q: float_compare(q.quantity, 0, precision_digits=2) > 0)
        
        if allow_negative:
            # Include negative quants
            pass
        else:
            # Only non-negative
            quants = quants.filtered(lambda q: float_compare(q.quantity, 0, precision_digits=2) >= 0)
        
        # Sum the available quantity
        total_quantity = sum(quants.mapped('quantity'))
        
        return total_quantity
    
    # ========================================================================
    # RESERVED QUANTITY OVERRIDE with BU Constraint
    # ========================================================================
    def _get_reserved_quantity(
        self,
        product_id,
        location_id,
        lot_id=None,
        package_id=None,
        owner_id=None,
        business_unit_id=None,
    ):
        """
        Get reserved quantity respecting BU boundaries.
        
        Reserved stock is considered "committed" and cannot be used by other BUs.
        This method ensures we only count reservations for the requesting BU.
        
        :param product_id: Product to check reservations for
        :param location_id: Location to check in
        :param lot_id: Lot filter (optional)
        :param package_id: Package filter (optional)
        :param owner_id: Owner filter (optional)
        :param business_unit_id: Business unit context
        :return: Total reserved quantity for the BU
        """
        
        # Build domain for reserved quants
        domain = [
            ('product_id', '=', product_id.id),
            ('location_id', '=', location_id.id),
            ('reserved_quantity', '!=', 0),
        ]
        
        # Apply BU constraint (reserved qty is BU-specific)
        if business_unit_id:
            domain.append(('ops_business_unit_id', '=', business_unit_id.id))
        else:
            # No BU context: only global reservations
            domain.append(('ops_business_unit_id', '=', False))
        
        # Apply standard filters
        if lot_id:
            domain.append(('lot_id', '=', lot_id.id))
        if package_id:
            domain.append(('package_id', '=', package_id.id))
        if owner_id:
            domain.append(('owner_id', '=', owner_id.id))
        
        # Search with pure SQL domain
        quants = self.search(domain)
        
        # Sum reserved quantities
        total_reserved = sum(quants.mapped('reserved_quantity'))
        
        return total_reserved
    
    # ========================================================================
    # CONSTRAINT: Prevent Invalid Cross-BU Reservations
    # ========================================================================
    # NOTE: This constraint is commented out because stock.move.line.quant_id
    # is not a stored field in Odoo core, causing SQL conversion errors.
    # BU validation is handled at the reservation level through domain filtering.
    
    # @api.constrains('ops_business_unit_id', 'reserved_quantity')
    # def _check_bu_reservation_consistency(self):
    #     """
    #     Ensure that if a quant is reserved, its BU matches the related move's BU.
    #
    #     This constraint prevents the scenario where:
    #     1. A quant is reserved for Business Unit A
    #     2. But the move is actually for Business Unit B
    #
    #     This is a safety net to catch any BU mismatch in the reservation chain.
    #     """
    #     # Commented out - quant_id field is not stored on stock.move.line
    #     pass
    
    # ========================================================================
    # PUBLIC METHODS
    # ========================================================================
    def _update_available_quantity(
        self,
        product_id,
        location_id,
        quantity=0.0,
        lot_id=None,
        package_id=None,
        owner_id=None,
        in_date=None,
        reserved_quantity=None,
        business_unit_id=None,
    ):
        """
        Update available quantity respecting BU constraints.
        
        When stock is moved or adjusted, ensure the operation respects
        BU boundaries. Global stock (no BU) can be adjusted freely.
        
        :param product_id: Product being updated
        :param location_id: Location being updated
        :param quantity: Quantity change (default 0 for reservation-only updates)
        :param lot_id: Lot filter
        :param package_id: Package filter
        :param owner_id: Owner filter
        :param in_date: Date of receipt
        :param reserved_quantity: Reserved quantity to update (Odoo core parameter)
        :param business_unit_id: BU context for the change
        :return: Tuple (available_quantity, in_date) as expected by Odoo core
        """
        
        # Get existing quant with BU constraint
        quants = self.search([
            ('product_id', '=', product_id.id),
            ('location_id', '=', location_id.id),
            ('lot_id', '=', lot_id.id if lot_id else False),
            ('package_id', '=', package_id.id if package_id else False),
            ('owner_id', '=', owner_id.id if owner_id else False),
        ])
        
        # Filter for BU constraint
        if business_unit_id:
            quants = quants.filtered(
                lambda q: (q.ops_business_unit_id == business_unit_id or not q.ops_business_unit_id)
            )
        else:
            quants = quants.filtered(lambda q: not q.ops_business_unit_id)
        
        # Store the in_date to return
        result_in_date = in_date or fields.Datetime.now()
        
        if quants:
            # Use first matching quant
            quants = quants[0:1]
            vals_to_write = {}
            
            # Update on-hand quantity if provided
            if quantity != 0:
                vals_to_write['quantity'] = quants[0].quantity + quantity
            
            # Update reserved quantity if provided (Odoo core compatibility)
            if reserved_quantity is not None:
                vals_to_write['reserved_quantity'] = quants[0].reserved_quantity + reserved_quantity
            
            if vals_to_write:
                quants.write(vals_to_write)
            
            # Use the quant's in_date if available
            result_in_date = quants[0].in_date or result_in_date
            result_quantity = quants[0].quantity
        else:
            # Create new quant with BU assignment
            # Only create if there's actual quantity or reservation to record
            if quantity != 0 or reserved_quantity:
                vals = {
                    'product_id': product_id.id,
                    'location_id': location_id.id,
                    'quantity': quantity,
                    'in_date': result_in_date,
                }
                
                if lot_id:
                    vals['lot_id'] = lot_id.id
                if package_id:
                    vals['package_id'] = package_id.id
                if owner_id:
                    vals['owner_id'] = owner_id.id
                
                # Add reserved quantity if provided (Odoo core compatibility)
                if reserved_quantity is not None:
                    vals['reserved_quantity'] = reserved_quantity
                
                if business_unit_id and business_unit_id.id:
                    # Note: BU is computed from product, but stored context helps
                    vals['ops_business_unit_id'] = business_unit_id.id
                
                quants = self.create(vals)
                result_quantity = quants.quantity
                result_in_date = quants.in_date
            else:
                # No quantity change and no reservation - return zero quantity
                result_quantity = 0.0
        
        # Return tuple as expected by Odoo core: (available_quantity, in_date)
        return result_quantity, result_in_date
    
    # ========================================================================
    # CONTEXT HELPERS
    # ========================================================================
    @staticmethod
    def _prepare_bu_context(business_unit_id):
        """
        Prepare context dictionary for BU-aware operations.
        
        Use this when calling stock operations with BU context.
        
        :param business_unit_id: ops.business.unit record or ID
        :return: Context dict with BU information
        """
        bu_id = business_unit_id.id if hasattr(business_unit_id, 'id') else business_unit_id
        return {
            'ops_business_unit_id': bu_id,
        }


# Import validation error
from odoo.exceptions import ValidationError

--- ops_matrix_core/models/stock_warehouse.py ---
from odoo import _, models, fields, api
from odoo.exceptions import ValidationError

class StockWarehouse(models.Model):
    _inherit = 'stock.warehouse'

    # Note: branch_id now points to res.company (which IS the branch)
    # Most warehouses will use company_id directly, but branch_id allows
    # a warehouse to belong to a different company/branch than its main company
    branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,  # Will default to company_id
        ondelete='restrict',
        help="Branch/Company this warehouse belongs to. Defaults to warehouse's company."
    )

    @api.model_create_multi
    def create(self, vals_list):
        """Override create to ensure branch_id defaults to company_id."""
        for vals in vals_list:
            if not vals.get('branch_id'):
                # Default branch_id to company_id (company IS the branch now)
                vals['branch_id'] = vals.get('company_id', self.env.company.id)
        
        return super().create(vals_list)

    @api.onchange('company_id')
    def _onchange_company_id(self):
        """When company changes, update branch_id to match."""
        if self.company_id and not self.branch_id:
            self.branch_id = self.company_id

    @api.constrains('branch_id', 'company_id')
    def _check_branch_company(self):
        """
        Ensure branch belongs to a valid company.
        Note: With the new architecture, branch_id IS a company,
        so we just verify it exists and is accessible.
        """
        for warehouse in self:
            if warehouse.branch_id and not warehouse.branch_id.active:
                raise ValidationError(_("Warehouse's branch/company must be active."))

--- ops_matrix_core/models/stock_warehouse_orderpoint.py ---
from odoo import models, fields, api

class StockWarehouseOrderpoint(models.Model):
    _inherit = 'stock.warehouse.orderpoint'

    branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        compute='_compute_branch_id',
        store=True,
        help="Branch from the warehouse"
    )

    @api.depends('warehouse_id', 'warehouse_id.branch_id')
    def _compute_branch_id(self):
        """Compute branch from warehouse."""
        for orderpoint in self:
            orderpoint.branch_id = orderpoint.warehouse_id.branch_id if orderpoint.warehouse_id else False

--- ops_matrix_core/wizard/__init__.py ---
# -*- coding: utf-8 -*-

from . import ops_governance_violation_report
from . import ops_welcome_wizard

--- ops_matrix_core/wizard/ops_governance_violation_report.py ---
# -*- coding: utf-8 -*-

from odoo import models, fields, api, _
from odoo.exceptions import UserError
import json
import csv
import io
import base64
import logging

_logger = logging.getLogger(__name__)


class OpsGovernanceViolationReport(models.TransientModel):
    """Wizard for generating governance violation reports with matrix filtering"""
    _name = 'ops.governance.violation.report'
    _description = 'Governance Violations Dashboard & Reporting'
    
    # --- FILTERS ---
    date_from = fields.Date(
        string='From Date', 
        required=True,
        default=lambda self: fields.Date.today().replace(day=1)
    )
    
    date_to = fields.Date(
        string='To Date', 
        required=True,
        default=lambda self: fields.Date.today()
    )
    
    company_id = fields.Many2one(
        'res.company', 
        string='Company',
        default=lambda self: self.env.company
    )
    
    branch_id = fields.Many2one(
        'ops.branch', 
        string='Branch',
        domain="[('company_id', '=', company_id)]"
    )
    
    business_unit_id = fields.Many2one(
        'ops.business.unit', 
        string='Business Unit',
        domain="[('company_ids', 'in', [company_id])]"
    )
    
    rule_id = fields.Many2one(
        'ops.governance.rule', 
        string='Specific Rule',
        domain="[('company_id', '=', company_id)]"
    )
    
    violation_type = fields.Selection([
        ('all', 'All Violations'),
        ('matrix', 'Matrix Validation'),
        ('discount', 'Discount Limit'),
        ('margin', 'Margin Protection'),
        ('price', 'Price Override'),
        ('other', 'Other'),
    ], string='Violation Type', default='all')
    
    approval_status = fields.Selection([
        ('all', 'All Statuses'),
        ('pending', 'Pending Approval'),
        ('approved', 'Approved'),
        ('rejected', 'Rejected'),
        ('cancelled', 'Cancelled'),
    ], string='Approval Status', default='all')
    
    # --- REPORT OPTIONS ---
    group_by = fields.Selection([
        ('none', 'No Grouping'),
        ('rule', 'By Rule'),
        ('type', 'By Violation Type'),
        ('branch', 'By Branch'),
        ('bu', 'By Business Unit'),
        ('user', 'By User'),
        ('severity', 'By Severity'),
    ], string='Group By', default='none')
    
    include_details = fields.Boolean(string='Include Details', default=True)
    include_resolved = fields.Boolean(string='Include Resolved', default=False)
    
    # --- COMPUTED RESULTS ---
    violation_count = fields.Integer(
        string='Violation Count', 
        compute='_compute_violation_stats', 
        store=False
    )
    
    pending_count = fields.Integer(
        string='Pending Count', 
        compute='_compute_violation_stats', 
        store=False
    )
    
    approved_count = fields.Integer(
        string='Approved Count', 
        compute='_compute_violation_stats', 
        store=False
    )
    
    rejected_count = fields.Integer(
        string='Rejected Count', 
        compute='_compute_violation_stats', 
        store=False
    )
    
    # --- COMPUTED METHODS ---
    
    @api.depends('date_from', 'date_to', 'company_id', 'branch_id', 'business_unit_id',
                'rule_id', 'violation_type', 'approval_status')
    def _compute_violation_stats(self):
        """Compute violation statistics."""
        for wizard in self:
            domain = wizard._get_base_domain()
            
            all_violations = self.env['ops.approval.request'].search(domain)
            wizard.violation_count = len(all_violations)
            wizard.pending_count = len(all_violations.filtered(lambda r: r.state == 'pending'))
            wizard.approved_count = len(all_violations.filtered(lambda r: r.state == 'approved'))
            wizard.rejected_count = len(all_violations.filtered(lambda r: r.state == 'rejected'))
    
    # --- BUSINESS METHODS ---
    
    def _get_base_domain(self):
        """Build base domain for violation queries."""
        self.ensure_one()
        
        domain = [
            ('create_date', '>=', self.date_from),
            ('create_date', '<=', self.date_to),
            ('is_governance_violation', '=', True),
        ]
        
        if self.company_id:
            domain.append(('ops_company_id', '=', self.company_id.id))
        
        if self.branch_id:
            domain.append(('ops_branch_id', '=', self.branch_id.id))
        
        if self.business_unit_id:
            domain.append(('ops_business_unit_id', '=', self.business_unit_id.id))
        
        if self.rule_id:
            domain.append(('rule_id', '=', self.rule_id.id))
        
        if self.violation_type != 'all':
            domain.append(('violation_type', '=', self.violation_type))
        
        if self.approval_status != 'all':
            domain.append(('state', '=', self.approval_status))
        
        if not self.include_resolved:
            domain.append(('state', 'in', ['pending']))
        
        return domain
    
    def _get_violations(self):
        """Get violations based on filters."""
        self.ensure_one()
        
        domain = self._get_base_domain()
        approvals = self.env['ops.approval.request'].search(domain, order='create_date desc')
        
        # Format data
        violations = []
        for approval in approvals:
            violations.append({
                'id': approval.id,
                'name': approval.name,
                'date': approval.create_date,
                'user': approval.requested_by.name,
                'branch': approval.ops_branch_id.name if approval.ops_branch_id else '',
                'bu': approval.ops_business_unit_id.name if approval.ops_business_unit_id else '',
                'rule': approval.rule_id.name if approval.rule_id else '',
                'violation_type': dict(approval._fields['violation_type'].selection).get(approval.violation_type, ''),
                'violation_summary': approval.violation_summary or '',
                'severity': dict(approval._fields['violation_severity'].selection).get(approval.violation_severity, ''),
                'status': dict(approval._fields['state'].selection).get(approval.state, ''),
                'approvers': ', '.join(approval.approver_ids.mapped('name')),
            })
        
        # Group if requested
        if self.group_by != 'none':
            violations = self._group_violations(violations)
        
        return violations
    
    def _group_violations(self, violations):
        """Group violations by selected criteria."""
        grouped = {}
        
        for violation in violations:
            key = ''
            
            if self.group_by == 'rule':
                key = violation.get('rule', 'No Rule')
            elif self.group_by == 'type':
                key = violation.get('violation_type', 'Unknown')
            elif self.group_by == 'branch':
                key = violation.get('branch', 'No Branch')
            elif self.group_by == 'bu':
                key = violation.get('bu', 'No BU')
            elif self.group_by == 'user':
                key = violation.get('user', 'Unknown User')
            elif self.group_by == 'severity':
                key = violation.get('severity', 'Unknown Severity')
            
            if key not in grouped:
                grouped[key] = {
                    'key': key,
                    'count': 0,
                    'violations': [],
                    'pending': 0,
                    'approved': 0,
                    'rejected': 0,
                }
            
            grouped[key]['count'] += 1
            grouped[key]['violations'].append(violation)
            
            if violation['status'] == 'Pending':
                grouped[key]['pending'] += 1
            elif violation['status'] == 'Approved':
                grouped[key]['approved'] += 1
            elif violation['status'] == 'Rejected':
                grouped[key]['rejected'] += 1
        
        # Convert to list and sort by count
        result = list(grouped.values())
        result.sort(key=lambda x: x['count'], reverse=True)
        return result
    
    def action_generate_report(self):
        """Generate and display report."""
        self.ensure_one()
        
        violations = self._get_violations()
        
        # Return tree view of filtered approval requests
        return {
            'type': 'ir.actions.act_window',
            'name': _('Governance Violations Report: %s to %s') % (self.date_from, self.date_to),
            'res_model': 'ops.approval.request',
            'view_mode': 'tree,form,pivot,graph',
            'domain': self._get_base_domain(),
            'context': {
                'search_default_group_by_violation_type': 1 if self.group_by == 'type' else 0,
                'search_default_group_by_branch': 1 if self.group_by == 'branch' else 0,
                'search_default_group_by_rule': 1 if self.group_by == 'rule' else 0,
            },
        }
    
    def action_export_csv(self):
        """Export violations to CSV."""
        self.ensure_one()
        
        violations = self._get_violations()
        
        if not violations:
            raise UserError(_("No violations found matching the selected criteria."))
        
        # Create CSV content
        output = io.StringIO()
        writer = csv.DictWriter(output, fieldnames=[
            'Date', 'User', 'Branch', 'Business Unit', 'Rule', 
            'Violation Type', 'Violation Summary', 'Severity', 'Status', 'Approvers'
        ])
        
        writer.writeheader()
        
        # Handle both grouped and ungrouped data
        rows_to_write = []
        if violations and 'violations' in violations[0]:  # Grouped data
            for group in violations:
                for sub_violation in group['violations']:
                    rows_to_write.append(sub_violation)
        else:  # Ungrouped data
            rows_to_write = violations
        
        for violation in rows_to_write:
            writer.writerow({
                'Date': violation.get('date', ''),
                'User': violation.get('user', ''),
                'Branch': violation.get('branch', ''),
                'Business Unit': violation.get('bu', ''),
                'Rule': violation.get('rule', ''),
                'Violation Type': violation.get('violation_type', ''),
                'Violation Summary': violation.get('violation_summary', ''),
                'Severity': violation.get('severity', ''),
                'Status': violation.get('status', ''),
                'Approvers': violation.get('approvers', ''),
            })
        
        # Create attachment
        csv_data = output.getvalue().encode('utf-8')
        filename = f'governance_violations_{fields.Date.today()}.csv'
        
        attachment = self.env['ir.attachment'].create({
            'name': filename,
            'datas': base64.b64encode(csv_data),
            'res_model': 'ops.governance.violation.report',
            'res_id': self.id,
            'type': 'binary',
        })
        
        # Return download action
        return {
            'type': 'ir.actions.act_url',
            'url': f'/web/content/{attachment.id}?download=true',
            'target': 'self',
        }
    
    def action_view_violations(self):
        """Open filtered violations view."""
        self.ensure_one()
        
        return {
            'type': 'ir.actions.act_window',
            'name': _('Governance Violations'),
            'res_model': 'ops.approval.request',
            'view_mode': 'tree,form,pivot,graph',
            'domain': self._get_base_domain(),
            'context': {
                'search_default_pending': 1 if self.approval_status == 'pending' else 0,
                'search_default_group_by_date': 1,
                'search_default_group_by_violation_type': 1,
            },
        }
    
    def action_view_summary(self):
        """Display summary statistics."""
        self.ensure_one()
        
        violations = self._get_violations()
        
        if self.group_by == 'none':
            summary_message = _(
                "Total Violations: %s\n"
                "Pending: %s\n"
                "Approved: %s\n"
                "Rejected: %s"
            ) % (
                self.violation_count,
                self.pending_count,
                self.approved_count,
                self.rejected_count
            )
        else:
            # Grouped summary
            summary_lines = [_("Grouped by %s:") % self.group_by]
            for group in violations[:10]:  # Show top 10 groups
                summary_lines.append(
                    _("  %s: %s violations (%s pending)") % (
                        group['key'],
                        group['count'],
                        group['pending']
                    )
                )
            summary_message = "\n".join(summary_lines)
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Violation Summary'),
                'message': summary_message,
                'type': 'info',
                'sticky': True,
            }
        }

--- ops_matrix_core/wizard/ops_welcome_wizard.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
import logging

_logger = logging.getLogger(__name__)


class OpsWelcomeWizard(models.TransientModel):
    """
    OPS Matrix Framework - Welcome & Setup Wizard
    
    Guides users through the initial setup of the OPS Matrix Framework:
    1. Welcome & Overview
    2. Company Configuration
    3. Branch Creation
    4. Business Unit Setup
    5. Industry Template Selection
    6. Configuration Summary & Finalization
    """
    _name = 'ops.welcome.wizard'
    _description = 'OPS Matrix Setup Wizard'
    
    # =========================================================================
    # Wizard State Management
    # =========================================================================
    state = fields.Selection([
        ('welcome', 'Welcome'),
        ('company', 'Company Setup'),
        ('branches', 'Branch Configuration'),
        ('business_units', 'Business Units'),
        ('industry', 'Industry Template'),
        ('configuration', 'Matrix Configuration'),
        ('summary', 'Summary & Confirmation'),
        ('complete', 'Setup Complete'),
    ], string='Wizard Step', default='welcome', required=True)
    
    # =========================================================================
    # Company Information
    # =========================================================================
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        default=lambda self: self.env.company,
        required=True,
        help='Select the legal entity to configure'
    )
    
    company_setup_complete = fields.Boolean(
        string='Company Already Configured',
        compute='_compute_company_setup_complete',
        help='Indicates if the company has basic information'
    )
    
    @api.depends('company_id')
    def _compute_company_setup_complete(self):
        """Check if company has minimum required information."""
        for wizard in self:
            if wizard.company_id:
                wizard.company_setup_complete = bool(
                    wizard.company_id.name and
                    wizard.company_id.currency_id and
                    wizard.company_id.country_id
                )
            else:
                wizard.company_setup_complete = False
    
    # =========================================================================
    # Branch Configuration
    # =========================================================================
    branch_count = fields.Integer(
        string='Number of Branches',
        default=1,
        help='How many geographic locations does your organization operate?'
    )
    
    branch_ids = fields.One2many(
        'ops.welcome.wizard.branch',
        'wizard_id',
        string='Branches'
    )
    
    create_sample_branches = fields.Boolean(
        string='Create Sample Branches',
        default=False,
        help='Create example branches for testing'
    )
    
    # =========================================================================
    # Business Unit Configuration
    # =========================================================================
    business_unit_count = fields.Integer(
        string='Number of Business Units',
        default=1,
        help='How many strategic business units/divisions do you have?'
    )
    
    business_unit_ids = fields.One2many(
        'ops.welcome.wizard.business.unit',
        'wizard_id',
        string='Business Units'
    )
    
    create_sample_business_units = fields.Boolean(
        string='Create Sample Business Units',
        default=False,
        help='Create example business units for testing'
    )
    
    # =========================================================================
    # Industry Template
    # =========================================================================
    industry_template = fields.Selection([
        ('retail', 'Retail & Distribution'),
        ('manufacturing', 'Manufacturing'),
        ('services', 'Professional Services'),
        ('hospitality', 'Hospitality & F&B'),
        ('healthcare', 'Healthcare'),
        ('construction', 'Construction & Real Estate'),
        ('custom', 'Custom Configuration'),
    ], string='Industry Template',
       default='custom',
       help='Choose a template optimized for your industry')
    
    # =========================================================================
    # Configuration Settings
    # =========================================================================
    branch_weight = fields.Float(
        string='Branch Weight (%)',
        default=50.0,
        help='Analytic distribution weight for Branch dimension'
    )
    
    business_unit_weight = fields.Float(
        string='Business Unit Weight (%)',
        default=50.0,
        help='Analytic distribution weight for Business Unit dimension'
    )
    
    require_branch_on_transactions = fields.Boolean(
        string='Require Branch on Transactions',
        default=True
    )
    
    require_bu_on_transactions = fields.Boolean(
        string='Require Business Unit on Transactions',
        default=True
    )
    
    # =========================================================================
    # Setup Progress
    # =========================================================================
    setup_log = fields.Text(
        string='Setup Log',
        readonly=True,
        help='Log of setup actions performed'
    )
    
    # =========================================================================
    # Navigation Methods
    # =========================================================================
    def action_next(self):
        """Move to the next step in the wizard."""
        self.ensure_one()
        
        state_sequence = [
            'welcome', 'company', 'branches', 'business_units',
            'industry', 'configuration', 'summary', 'complete'
        ]
        
        current_index = state_sequence.index(self.state)
        
        # Validate current step before proceeding
        self._validate_current_step()
        
        if current_index < len(state_sequence) - 1:
            self.state = state_sequence[current_index + 1]
            
            # Auto-execute certain steps
            if self.state == 'complete':
                self._execute_setup()
        
        return self._reopen_wizard()
    
    def action_back(self):
        """Move to the previous step in the wizard."""
        self.ensure_one()
        
        state_sequence = [
            'welcome', 'company', 'branches', 'business_units',
            'industry', 'configuration', 'summary', 'complete'
        ]
        
        current_index = state_sequence.index(self.state)
        
        if current_index > 0:
            self.state = state_sequence[current_index - 1]
        
        return self._reopen_wizard()
    
    def action_skip(self):
        """Skip the current optional step."""
        self.ensure_one()
        return self.action_next()
    
    def _reopen_wizard(self):
        """Reopen the wizard at the current state."""
        return {
            'type': 'ir.actions.act_window',
            'res_model': 'ops.welcome.wizard',
            'res_id': self.id,
            'view_mode': 'form',
            'target': 'new',
            'context': self.env.context,
        }
    
    # =========================================================================
    # Validation Methods
    # =========================================================================
    def _validate_current_step(self):
        """Validate the current wizard step before proceeding."""
        self.ensure_one()
        
        if self.state == 'company':
            if not self.company_id:
                raise ValidationError(_('Please select a company to continue.'))
        
        elif self.state == 'branches':
            if not self.create_sample_branches and not self.branch_ids:
                raise ValidationError(_(
                    'Please create at least one branch or enable sample branch creation.'
                ))
        
        elif self.state == 'business_units':
            if not self.create_sample_business_units and not self.business_unit_ids:
                raise ValidationError(_(
                    'Please create at least one business unit or enable sample BU creation.'
                ))
        
        elif self.state == 'configuration':
            total = self.branch_weight + self.business_unit_weight
            if abs(total - 100.0) > 0.01:
                raise ValidationError(_(
                    'Branch weight (%.2f%%) + Business Unit weight (%.2f%%) must equal 100%%.'
                ) % (self.branch_weight, self.business_unit_weight))
    
    # =========================================================================
    # Setup Execution
    # =========================================================================
    def _execute_setup(self):
        """Execute the complete setup based on wizard configuration."""
        self.ensure_one()
        
        log_lines = []
        log_lines.append(_('=== OPS Matrix Setup Started ==='))
        log_lines.append(_('Company: %s') % self.company_id.name)
        
        try:
            # 1. Create configuration
            config = self._create_matrix_configuration()
            log_lines.append(_('âœ“ Matrix configuration created'))
            
            # 2. Create branches
            branches = self._create_branches()
            log_lines.append(_('âœ“ Created %d branches') % len(branches))
            
            # 3. Create business units
            business_units = self._create_business_units(branches)
            log_lines.append(_('âœ“ Created %d business units') % len(business_units))
            
            # 4. Apply industry template
            if self.industry_template != 'custom':
                config.industry_template = self.industry_template
                config.apply_industry_template()
                log_lines.append(_('âœ“ Applied %s industry template') % self.industry_template)
            
            # 5. Configure admin user
            self._configure_admin_user(branches, business_units)
            log_lines.append(_('âœ“ Configured admin user access'))
            
            log_lines.append(_('=== Setup Complete ==='))
            
            self.setup_log = '\n'.join(log_lines)
            
        except Exception as e:
            log_lines.append(_('âœ— ERROR: %s') % str(e))
            self.setup_log = '\n'.join(log_lines)
            raise UserError(_(
                'Setup failed with error: %s\n\nPlease contact support or try again.'
            ) % str(e))
    
    def _create_matrix_configuration(self):
        """Create or update matrix configuration."""
        self.ensure_one()
        
        config = self.env['ops.matrix.config'].search([
            ('company_id', '=', self.company_id.id)
        ], limit=1)
        
        if not config:
            config = self.env['ops.matrix.config'].create({
                'company_id': self.company_id.id,
                'branch_weight': self.branch_weight,
                'business_unit_weight': self.business_unit_weight,
                'require_branch_on_transactions': self.require_branch_on_transactions,
                'require_bu_on_transactions': self.require_bu_on_transactions,
                'industry_template': self.industry_template,
            })
        else:
            config.write({
                'branch_weight': self.branch_weight,
                'business_unit_weight': self.business_unit_weight,
                'require_branch_on_transactions': self.require_branch_on_transactions,
                'require_bu_on_transactions': self.require_bu_on_transactions,
                'industry_template': self.industry_template,
            })
        
        return config
    
    def _create_branches(self):
        """Create branches based on wizard configuration."""
        self.ensure_one()
        
        if self.create_sample_branches:
            return self._create_sample_branches()
        
        branches = self.env['ops.branch']
        for branch_line in self.branch_ids:
            branch = self.env['ops.branch'].create({
                'name': branch_line.name,
                'code': branch_line.code or 'BR-' + branch_line.name[:3].upper(),
                'company_id': self.company_id.id,
                'address': branch_line.address,
                'phone': branch_line.phone,
                'email': branch_line.email,
            })
            branches |= branch
        
        return branches
    
    def _create_sample_branches(self):
        """Create sample branches for testing."""
        self.ensure_one()
        
        sample_data = [
            {'name': 'Head Office', 'code': 'BR-HQ'},
            {'name': 'Branch A', 'code': 'BR-A'},
            {'name': 'Branch B', 'code': 'BR-B'},
        ]
        
        branches = self.env['ops.branch']
        for data in sample_data[:self.branch_count]:
            branch = self.env['ops.branch'].create({
                'name': data['name'],
                'code': data['code'],
                'company_id': self.company_id.id,
            })
            branches |= branch
        
        return branches
    
    def _create_business_units(self, branches):
        """Create business units based on wizard configuration."""
        self.ensure_one()
        
        if self.create_sample_business_units:
            return self._create_sample_business_units(branches)
        
        business_units = self.env['ops.business.unit']
        for bu_line in self.business_unit_ids:
            # Get branch IDs from wizard line
            branch_ids = bu_line.branch_ids.ids if bu_line.branch_ids else branches.ids
            
            bu = self.env['ops.business.unit'].create({
                'name': bu_line.name,
                'code': bu_line.code or 'BU-' + bu_line.name[:3].upper(),
                'description': bu_line.description,
                'branch_ids': [(6, 0, branch_ids)],
                'primary_branch_id': branch_ids[0] if branch_ids else False,
            })
            business_units |= bu
        
        return business_units
    
    def _create_sample_business_units(self, branches):
        """Create sample business units for testing."""
        self.ensure_one()
        
        sample_data = [
            {'name': 'Sales Division', 'code': 'BU-SALES'},
            {'name': 'Operations', 'code': 'BU-OPS'},
            {'name': 'Services', 'code': 'BU-SVC'},
        ]
        
        business_units = self.env['ops.business.unit']
        for data in sample_data[:self.business_unit_count]:
            bu = self.env['ops.business.unit'].create({
                'name': data['name'],
                'code': data['code'],
                'branch_ids': [(6, 0, branches.ids)],
                'primary_branch_id': branches[0].id if branches else False,
            })
            business_units |= bu
        
        return business_units
    
    def _configure_admin_user(self, branches, business_units):
        """Configure the admin user with matrix access."""
        self.ensure_one()
        
        admin_user = self.env.ref('base.user_admin', raise_if_not_found=False)
        if admin_user:
            admin_user.write({
                'ops_allowed_branch_ids': [(6, 0, branches.ids)],
                'ops_allowed_business_unit_ids': [(6, 0, business_units.ids)],
                'ops_default_branch_id': branches[0].id if branches else False,
                'ops_default_business_unit_id': business_units[0].id if business_units else False,
            })
    
    # =========================================================================
    # Action Methods
    # =========================================================================
    def action_finish(self):
        """Complete the wizard and close."""
        self.ensure_one()
        
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Setup Complete!'),
                'message': _('OPS Matrix Framework has been configured successfully. '
                           'You can now start using branches and business units in your transactions.'),
                'type': 'success',
                'sticky': False,
                'next': {'type': 'ir.actions.act_window_close'},
            }
        }
    
    def action_open_configuration(self):
        """Open the matrix configuration form."""
        self.ensure_one()
        
        config = self.env['ops.matrix.config'].search([
            ('company_id', '=', self.company_id.id)
        ], limit=1)
        
        return {
            'type': 'ir.actions.act_window',
            'res_model': 'ops.matrix.config',
            'res_id': config.id if config else False,
            'view_mode': 'form',
            'target': 'current',
        }


class OpsWelcomeWizardBranch(models.TransientModel):
    """Wizard line for branch creation."""
    _name = 'ops.welcome.wizard.branch'
    _description = 'Welcome Wizard - Branch Line'
    
    wizard_id = fields.Many2one(
        'ops.welcome.wizard',
        string='Wizard',
        required=True,
        ondelete='cascade'
    )
    
    name = fields.Char(string='Branch Name', required=True)
    code = fields.Char(string='Branch Code')
    address = fields.Text(string='Address')
    phone = fields.Char(string='Phone')
    email = fields.Char(string='Email')


class OpsWelcomeWizardBusinessUnit(models.TransientModel):
    """Wizard line for business unit creation."""
    _name = 'ops.welcome.wizard.business.unit'
    _description = 'Welcome Wizard - Business Unit Line'
    
    wizard_id = fields.Many2one(
        'ops.welcome.wizard',
        string='Wizard',
        required=True,
        ondelete='cascade'
    )
    
    name = fields.Char(string='Business Unit Name', required=True)
    code = fields.Char(string='BU Code')
    description = fields.Text(string='Description')
    branch_ids = fields.Many2many(
        'ops.branch',
        string='Operating Branches',
        help='Leave empty to include all branches'
    )


============================================
MODULE: ops_matrix_accounting
============================================

>>> STRUCTURE <<<
ops_matrix_accounting/__init__.py
ops_matrix_accounting/__manifest__.py
ops_matrix_accounting/data/templates/ops_budget_templates.xml
ops_matrix_accounting/hooks.py
ops_matrix_accounting/models/__init__.py
ops_matrix_accounting/models/ops_budget.py
ops_matrix_accounting/models/ops_consolidated_reporting.py
ops_matrix_accounting/models/ops_matrix_standard_extensions.py
ops_matrix_accounting/models/ops_pdc.py
ops_matrix_accounting/models/ops_product_category_defaults.py
ops_matrix_accounting/reports/__init__.py
ops_matrix_accounting/reports/ops_consolidated_report_templates.xml
ops_matrix_accounting/reports/ops_financial_report_parser.py
ops_matrix_accounting/reports/ops_financial_report_template.xml
ops_matrix_accounting/reports/ops_general_ledger_report.py
ops_matrix_accounting/reports/ops_general_ledger_template.xml
ops_matrix_accounting/reports/ops_general_ledger_xlsx.py
ops_matrix_accounting/views/ops_accounting_menus.xml
ops_matrix_accounting/views/ops_budget_views.xml
ops_matrix_accounting/views/ops_financial_report_wizard_views.xml
ops_matrix_accounting/views/ops_general_ledger_wizard_enhanced_views.xml
ops_matrix_accounting/views/ops_general_ledger_wizard_views.xml
ops_matrix_accounting/views/ops_pdc_views.xml
ops_matrix_accounting/views/ops_reporting_views.xml
ops_matrix_accounting/wizard/__init__.py
ops_matrix_accounting/wizard/ops_financial_report_wizard.py
ops_matrix_accounting/wizard/ops_general_ledger_wizard.py
ops_matrix_accounting/wizard/ops_general_ledger_wizard_enhanced.py

>>> __manifest__.py <<<
# -*- coding: utf-8 -*-
{
    'name': "OPS Matrix Accounting",
    'summary': "Advanced Financial Management & Reporting for Matrix Operations",
    'description': """
        Version 1.0 - Accounting Extension
        
        Transforms the standard Invoicing app into a full Accounting suite:
        1. PDC (Post-Dated Checks) Management
        2. Budget Control & Analytic Enforcement
        3. Professional Financial Reports (GL, TB, PL, BS)
        4. Excel Export Engine
        
        Requires: ops_matrix_core
    """,
    'author': "Gemini-3.0-Pro",
    'website': "http://www.yourcompany.com",
    'category': 'Accounting/Accounting',
    'version': '19.0.1.0.0',
    'depends': ['ops_matrix_core', 'account'],
    'external_dependencies': {
        'python': ['xlsxwriter'],
    },
    'data': [
        'security/ir.model.access.csv',
        'views/ops_accounting_menus.xml',
        'views/ops_pdc_views.xml',
        'views/ops_budget_views.xml',
        'views/ops_general_ledger_wizard_views.xml',
        'views/ops_general_ledger_wizard_enhanced_views.xml',
        'views/ops_financial_report_wizard_views.xml',
        'views/ops_reporting_views.xml',
        'reports/ops_general_ledger_template.xml',
        'reports/ops_financial_report_template.xml',
        'reports/ops_consolidated_report_templates.xml',
        
        # Template Data Files
        'data/templates/ops_budget_templates.xml',
    ],
    'post_init_hook': 'post_init_hook',
    'installable': True,
    'application': True,
    'license': 'LGPL-3',
}

--- ops_matrix_accounting/models/__init__.py ---
from . import ops_pdc
from . import ops_budget
from . import ops_product_category_defaults
from . import ops_matrix_standard_extensions
from . import ops_consolidated_reporting

--- ops_matrix_accounting/models/ops_budget.py ---
from odoo import models, fields, api
from odoo.exceptions import ValidationError
from psycopg2 import sql

class OpsBudget(models.Model):
    _name = 'ops.budget'
    _description = 'Matrix Budget Control'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'date_from desc, id desc'

    name = fields.Char(string='Budget Name', required=True, tracking=True)
    active = fields.Boolean(default=True)
    
    # Matrix Dimensions (Required)
    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=True,
        tracking=True,
        help="Branch this budget applies to"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=True,
        tracking=True,
        help="Business unit this budget applies to"
    )
    
    # Date Range
    date_from = fields.Date(string='Start Date', required=True, tracking=True)
    date_to = fields.Date(string='End Date', required=True, tracking=True)
    
    # Budget Status
    state = fields.Selection([
        ('draft', 'Draft'),
        ('confirmed', 'Confirmed'),
        ('done', 'Closed'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', tracking=True)
    
    # Budget Lines
    line_ids = fields.One2many('ops.budget.line', 'budget_id', string='Budget Lines')
    
    # Totals
    total_planned = fields.Monetary(
        string='Total Planned',
        compute='_compute_totals',
        store=True
    )
    total_practical = fields.Monetary(
        string='Total Actual',
        compute='_compute_totals',
        store=True
    )
    total_committed = fields.Monetary(
        string='Total Committed',
        compute='_compute_totals',
        store=True
    )
    available_balance = fields.Monetary(
        string='Available Balance',
        compute='_compute_totals',
        store=True
    )
    currency_id = fields.Many2one(
        'res.currency',
        string='Currency',
        required=True,
        default=lambda self: self.env.company.currency_id
    )

    _unique_matrix_budget = models.Constraint(
        'unique(ops_branch_id, ops_business_unit_id, date_from, date_to)',
        'A budget already exists for this Branch/Business Unit combination in the specified date range!'
    )

    @api.constrains('date_from', 'date_to')
    def _check_dates(self):
        for budget in self:
            if budget.date_to < budget.date_from:
                raise ValidationError('End Date must be after Start Date')

            # Check for overlapping date ranges
            overlapping = self.search([
                ('id', '!=', budget.id),
                ('ops_branch_id', '=', budget.ops_branch_id.id),
                ('ops_business_unit_id', '=', budget.ops_business_unit_id.id),
                ('date_from', '<=', budget.date_to),
                ('date_to', '>=', budget.date_from)
            ])
            if overlapping:
                raise ValidationError(
                    'Budget dates overlap with existing budget(s) for the same Branch/Business Unit!'
                )

    @api.depends('line_ids.planned_amount', 'line_ids.practical_amount', 'line_ids.committed_amount')
    def _compute_totals(self):
        for budget in self:
            budget.total_planned = sum(budget.line_ids.mapped('planned_amount'))
            budget.total_practical = sum(budget.line_ids.mapped('practical_amount'))
            budget.total_committed = sum(budget.line_ids.mapped('committed_amount'))
            budget.available_balance = budget.total_planned - budget.total_practical - budget.total_committed

    def action_confirm(self):
        self.write({'state': 'confirmed'})

    def action_done(self):
        self.write({'state': 'done'})

    def action_cancel(self):
        self.write({'state': 'cancelled'})

    def action_draft(self):
        self.write({'state': 'draft'})

    @api.model
    def check_budget_availability(self, account_id, ops_branch_id, ops_business_unit_id, amount):
        """Check if sufficient budget is available for a planned expense.
        
        Args:
            account_id: The expense account to check
            ops_branch_id: The branch requesting the expense
            ops_business_unit_id: The business unit requesting the expense
            amount: The amount to check
            
        Returns:
            bool: True if sufficient budget exists, False otherwise
        """
        domain = [
            ('state', '=', 'confirmed'),
            ('ops_branch_id', '=', ops_branch_id),
            ('ops_business_unit_id', '=', ops_business_unit_id),
            ('date_from', '<=', fields.Date.today()),
            ('date_to', '>=', fields.Date.today())
        ]
        
        active_budget = self.search(domain, limit=1)
        if not active_budget:
            return False
            
        budget_line = active_budget.line_ids.filtered(
            lambda l: l.general_account_id.id == account_id
        )
        if not budget_line:
            return False
            
        available = budget_line.planned_amount - budget_line.practical_amount - budget_line.committed_amount
        return available >= amount


class OpsBudgetLine(models.Model):
    _name = 'ops.budget.line'
    _description = 'Matrix Budget Line'
    _order = 'general_account_id'

    budget_id = fields.Many2one('ops.budget', string='Budget', required=True, ondelete='cascade')
    general_account_id = fields.Many2one(
        'account.account',
        string='Expense Account',
        required=True,
        domain=[('account_type', '=', 'expense')]
    )
    
    planned_amount = fields.Monetary(string='Planned Amount', required=True)
    practical_amount = fields.Monetary(string='Actual Amount', compute='_compute_practical_amount', store=True)
    committed_amount = fields.Monetary(string='Committed Amount', compute='_compute_committed_amount', store=True)
    available_amount = fields.Monetary(string='Available Amount', compute='_compute_available_amount', store=True)
    
    currency_id = fields.Many2one(related='budget_id.currency_id')
    company_id = fields.Many2one(related='budget_id.ops_branch_id')

    _unique_account_per_budget = models.Constraint(
        'unique(budget_id, general_account_id)',
        'You can only have one budget line per account!'
    )

    @api.depends('planned_amount', 'practical_amount', 'committed_amount')
    def _compute_available_amount(self):
        for line in self:
            line.available_amount = line.planned_amount - line.practical_amount - line.committed_amount

    def _compute_practical_amount(self):
        """Compute actual spend from account moves."""
        for line in self:
            domain = [
                ('account_id', '=', line.general_account_id.id),
                ('ops_branch_id', '=', line.budget_id.ops_branch_id.id),
                ('ops_business_unit_id', '=', line.budget_id.ops_business_unit_id.id),
                ('date', '>=', line.budget_id.date_from),
                ('date', '<=', line.budget_id.date_to),
                ('move_id.state', '=', 'posted'),
                ('move_id.move_type', 'in', ['in_invoice', 'in_refund'])
            ]
            
            amount = sum(self.env['account.move.line'].search(domain).mapped('debit'))
            line.practical_amount = amount

    def _compute_committed_amount(self):
        """Compute committed amount from purchase orders."""
        for line in self:
            domain = [
                ('account_id', '=', line.general_account_id.id),
                ('order_id.ops_branch_id', '=', line.budget_id.ops_branch_id.id),
                ('order_id.ops_business_unit_id', '=', line.budget_id.ops_business_unit_id.id),
                ('order_id.date_order', '>=', line.budget_id.date_from),
                ('order_id.date_order', '<=', line.budget_id.date_to),
                ('order_id.state', 'in', ['purchase', 'done']),
                ('invoice_status', '!=', 'invoiced')
            ]
            
            amount = sum(self.env['purchase.order.line'].search(domain).mapped('price_total'))
            line.committed_amount = amount

--- ops_matrix_accounting/models/ops_consolidated_reporting.py ---
# -*- coding: utf-8 -*-
"""
OPS Matrix Accounting - Consolidated Financial Reporting
=========================================================

This module provides comprehensive financial reporting engines for hierarchical
consolidated reports across Company, Branch, and Business Unit dimensions.

Author: OPS Matrix Framework
"""

from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
from odoo.tools import date_utils, float_round
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)


class OpsCompanyConsolidation(models.TransientModel):
    """Company-Level Consolidated P&L Report"""
    _name = 'ops.company.consolidation'
    _description = 'Company-Level Consolidated P&L Report'
    
    # Filter Fields
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # Comparison Period
    compare_with_previous = fields.Boolean(
        string='Compare with Previous Period',
        default=True
    )
    previous_date_from = fields.Date(
        string='Previous From Date',
        compute='_compute_previous_dates',
        store=False
    )
    previous_date_to = fields.Date(
        string='Previous To Date',
        compute='_compute_previous_dates',
        store=False
    )
    
    # Branch Filtering
    branch_ids = fields.Many2many(
        'ops.branch',
        string='Filter Branches',
        help='Leave empty for all branches in company'
    )
    
    # Level of Detail
    report_detail_level = fields.Selection([
        ('summary', 'Summary Only'),
        ('by_branch', 'By Branch'),
        ('by_bu', 'By Business Unit'),
        ('by_account', 'By Account Group')
    ], string='Detail Level', default='summary', required=True)
    
    # Report Data (stored)
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    # Computed Methods
    @api.depends('date_from', 'date_to')
    def _compute_previous_dates(self):
        """Compute previous period dates for comparison."""
        for wizard in self:
            if wizard.date_from and wizard.date_to:
                period_days = (wizard.date_to - wizard.date_from).days
                wizard.previous_date_from = wizard.date_from - timedelta(days=period_days + 1)
                wizard.previous_date_to = wizard.date_from - timedelta(days=1)
            else:
                wizard.previous_date_from = False
                wizard.previous_date_to = False
    
    @api.depends('company_id', 'date_from', 'date_to', 'branch_ids', 'report_detail_level')
    def _compute_report_data(self):
        """Main method to compute consolidated company P&L."""
        for wizard in self:
            if not wizard.date_from or not wizard.date_to:
                wizard.report_data = {}
                continue
            
            # Get company branches (filtered if selected)
            domain = [('company_id', '=', wizard.company_id.id)]
            if wizard.branch_ids:
                domain.append(('id', 'in', wizard.branch_ids.ids))
            
            branches = self.env['ops.branch'].search(domain)
            
            # Get account move lines for the period
            base_domain = [
                ('date', '>=', wizard.date_from),
                ('date', '<=', wizard.date_to),
                ('company_id', '=', wizard.company_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            # Apply branch filter if specified
            if wizard.branch_ids:
                base_domain.append(('ops_branch_id', 'in', wizard.branch_ids.ids))
            
            # Get data based on detail level
            if wizard.report_detail_level == 'summary':
                data = wizard._get_summary_data(base_domain, branches)
            elif wizard.report_detail_level == 'by_branch':
                data = wizard._get_branch_detail_data(base_domain, branches)
            elif wizard.report_detail_level == 'by_bu':
                data = wizard._get_bu_detail_data(base_domain, branches)
            elif wizard.report_detail_level == 'by_account':
                data = wizard._get_account_detail_data(base_domain, branches)
            else:
                data = {}
            
            # Add comparison data if requested
            if wizard.compare_with_previous:
                comparison_data = wizard._get_comparison_data()
                data['comparison'] = comparison_data
            
            wizard.report_data = data
    
    def _get_summary_data(self, domain, branches):
        """Get high-level summary P&L data."""
        MoveLine = self.env['account.move.line']
        
        # Get total income
        income_domain = domain + [
            ('account_id.account_type', 'in', ['income', 'income_other'])
        ]
        MoveLine._read_group(
            domain=income_domain,
            groupby=[],
            aggregates=['credit:sum', 'debit:sum']
        )
        total_income = income_data[0]['credit'] - income_data[0]['debit'] if income_data else 0
        
        # Get total expense
        expense_domain = domain + [
            ('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])
        ]
        MoveLine._read_group(
            domain=expense_domain,
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        total_expense = expense_data[0]['debit'] - expense_data[0]['credit'] if expense_data else 0
        
        # Get gross profit (income - COGS)
        cogs_domain = domain + [
            ('account_id.account_type', '=', 'expense_direct_cost')
        ]
        MoveLine._read_group(
            domain=cogs_domain,
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        total_cogs = cogs_data[0]['debit'] - cogs_data[0]['credit'] if cogs_data else 0
        gross_profit = total_income - total_cogs
        
        # Get operating expenses
        operating_domain = domain + [
            ('account_id.account_type', 'in', ['expense', 'expense_depreciation'])
        ]
        MoveLine._read_group(
            domain=operating_domain,
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        total_operating = operating_data[0]['debit'] - operating_data[0]['credit'] if operating_data else 0
        
        net_profit = total_income - total_expense
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'branches': len(branches),
            'totals': {
                'total_income': total_income,
                'total_cogs': total_cogs,
                'gross_profit': gross_profit,
                'gross_margin': (gross_profit / total_income * 100) if total_income else 0,
                'total_operating': total_operating,
                'total_expense': total_expense,
                'net_profit': net_profit,
                'net_margin': (net_profit / total_income * 100) if total_income else 0,
            },
            'branch_performance': self._get_branch_performance_summary(branches, domain),
        }
    
    def _get_branch_detail_data(self, domain, branches):
        """Get P&L data broken down by branch."""
        MoveLine = self.env['account.move.line']
        
        branch_data = []
        for branch in branches:
            branch_domain = domain + [('ops_branch_id', '=', branch.id)]
            
            # Get income for branch
            income_domain = branch_domain + [
                ('account_id.account_type', 'in', ['income', 'income_other'])
            ]
            MoveLine._read_group(
                domain=income_domain,
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            branch_income = income_result[0].get('credit', 0) - income_result[0].get('debit', 0) if income_result else 0
            
            # Get expense for branch
            expense_domain = branch_domain + [
                ('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])
            ]
            MoveLine._read_group(
                domain=expense_domain,
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            branch_expense = expense_result[0].get('debit', 0) - expense_result[0].get('credit', 0) if expense_result else 0
            
            branch_data.append({
                'branch_id': branch.id,
                'branch_code': branch.code,
                'branch_name': branch.name,
                'income': branch_income,
                'expense': branch_expense,
                'net_profit': branch_income - branch_expense,
                'bu_count': len(branch.business_unit_ids),
                'transactions': MoveLine.search_count(branch_domain),
            })
        
        # Sort by net profit (descending)
        branch_data.sort(key=lambda x: x['net_profit'], reverse=True)
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'branch_data': branch_data,
            'summary': {
                'total_income': sum(b['income'] for b in branch_data),
                'total_expense': sum(b['expense'] for b in branch_data),
                'total_net_profit': sum(b['net_profit'] for b in branch_data),
                'best_performing': branch_data[0] if branch_data else None,
                'worst_performing': branch_data[-1] if branch_data else None,
            }
        }
    
    def _get_bu_detail_data(self, domain, branches):
        """Get P&L data broken down by business unit."""
        MoveLine = self.env['account.move.line']
        
        # Get all BUs in selected branches
        branch_ids = branches.ids if branches else []
        bus = self.env['ops.business.unit'].search([
            ('branch_ids', 'in', branch_ids)
        ]) if branch_ids else self.env['ops.business.unit'].search([
            ('company_ids', 'in', [self.company_id.id])
        ])
        
        bu_data = []
        for bu in bus:
            bu_domain = domain + [('ops_business_unit_id', '=', bu.id)]
            
            # Get income for BU
            income_domain = bu_domain + [
                ('account_id.account_type', 'in', ['income', 'income_other'])
            ]
            MoveLine._read_group(
                domain=income_domain,
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            bu_income = income_result[0].get('credit', 0) - income_result[0].get('debit', 0) if income_result else 0
            
            # Get expense for BU
            expense_domain = bu_domain + [
                ('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])
            ]
            MoveLine._read_group(
                domain=expense_domain,
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            bu_expense = expense_result[0].get('debit', 0) - expense_result[0].get('credit', 0) if expense_result else 0
            
            # Get branches where this BU operates
            bu_branches = bu.branch_ids.filtered(lambda b: b.id in branch_ids) if branch_ids else bu.branch_ids
            
            bu_data.append({
                'bu_id': bu.id,
                'bu_code': bu.code,
                'bu_name': bu.name,
                'income': bu_income,
                'expense': bu_expense,
                'net_profit': bu_income - bu_expense,
                'branch_count': len(bu_branches),
                'branch_names': ', '.join(bu_branches.mapped('code')),
                'profitability_ratio': (bu_income - bu_expense) / bu_income * 100 if bu_income else 0,
            })
        
        # Sort by profitability ratio (descending)
        bu_data.sort(key=lambda x: x['profitability_ratio'], reverse=True)
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'bu_data': bu_data,
            'summary': {
                'total_income': sum(b['income'] for b in bu_data),
                'total_expense': sum(b['expense'] for b in bu_data),
                'total_net_profit': sum(b['net_profit'] for b in bu_data),
                'most_profitable': bu_data[0] if bu_data else None,
                'least_profitable': bu_data[-1] if bu_data else None,
            }
        }
    
    def _get_account_detail_data(self, domain, branches):
        """Get detailed P&L data by account group."""
        MoveLine = self.env['account.move.line']
        
        # Define account types for P&L
        account_types = [
            ('income', 'Revenue'),
            ('income_other', 'Other Income'),
            ('expense_direct_cost', 'Cost of Goods Sold'),
            ('expense', 'Operating Expenses'),
            ('expense_depreciation', 'Depreciation'),
        ]
        
        account_data = []
        for acc_type, acc_name in account_types:
            type_domain = domain + [('account_id.account_type', '=', acc_type)]
            
            # Get sum for this account type
            MoveLine._read_group(
                domain=type_domain,
                groupby=['account_id'],
                aggregates=['debit:sum', 'credit:sum', 'balance:sum']
            )
            
            total_debit = sum(item['debit'] for item in result)
            total_credit = sum(item['credit'] for item in result)
            
            if acc_type.startswith('income'):
                amount = total_credit - total_debit
            else:
                amount = total_debit - total_credit
            
            # Get top 5 accounts in this type
            top_accounts = []
            for item in result:
                if item.get('account_id'):
                    account = self.env['account.account'].browse(item['account_id'][0])
                    top_accounts.append({
                        'account_code': account.code,
                        'account_name': account.name,
                        'amount': item['credit'] - item['debit'] if acc_type.startswith('income') else item['debit'] - item['credit'],
                    })
            
            # Sort top accounts
            top_accounts.sort(key=lambda x: abs(x['amount']), reverse=True)
            
            account_data.append({
                'account_type': acc_type,
                'account_type_name': acc_name,
                'total_amount': amount,
                'top_accounts': top_accounts[:5],
                'account_count': len(result),
            })
        
        return {
            'company': self.company_id.name,
            'period': f"{self.date_from} to {self.date_to}",
            'account_data': account_data,
            'branches': len(branches),
        }
    
    def _get_comparison_data(self):
        """Get comparison data with previous period."""
        MoveLine = self.env['account.move.line']
        
        previous_domain = [
            ('date', '>=', self.previous_date_from),
            ('date', '<=', self.previous_date_to),
            ('company_id', '=', self.company_id.id),
            ('move_id.state', '=', 'posted'),
        ]
        
        if self.branch_ids:
            previous_domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
        
        # Get previous period totals
        MoveLine._read_group(
            domain=previous_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
            groupby=[],
            aggregates=['credit:sum', 'debit:sum']
        )
        previous_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
        
        MoveLine._read_group(
            domain=previous_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
            groupby=[],
            aggregates=['debit:sum', 'credit:sum']
        )
        previous_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
        
        previous_net = previous_income - previous_expense
        
        return {
            'previous_income': previous_income,
            'previous_expense': previous_expense,
            'previous_net_profit': previous_net,
            'period': f"{self.previous_date_from} to {self.previous_date_to}",
        }
    
    def _get_branch_performance_summary(self, branches, domain):
        """Get high-level branch performance summary."""
        MoveLine = self.env['account.move.line']
        
        performance = []
        for branch in branches[:10]:  # Limit to top 10 for summary
            branch_domain = domain + [('ops_branch_id', '=', branch.id)]
            
            MoveLine._read_group(
                domain=branch_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            branch_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            performance.append({
                'branch_code': branch.code,
                'branch_name': branch.name,
                'income': branch_income,
                'bu_count': len(branch.business_unit_ids),
            })
        
        return performance
    
    # Action Methods
    def action_generate_pdf(self):
        """Generate PDF report."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_company_consolidation_pdf').report_action(self)
    
    def action_generate_xlsx(self):
        """Generate Excel report."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_company_consolidation_xlsx').report_action(self)
    
    def action_view_branch_details(self, branch_id):
        """Drill down to branch report."""
        self.ensure_one()
        return {
            'name': _('Branch Report'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.branch.report',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_branch_id': branch_id,
                'default_date_from': self.date_from,
                'default_date_to': self.date_to,
            }
        }
    
    def action_view_bu_details(self, bu_id):
        """Drill down to BU report."""
        self.ensure_one()
        return {
            'name': _('Business Unit Report'),
            'type': 'ir.actions.act_window',
            'res_model': 'ops.business.unit.report',
            'view_mode': 'form',
            'target': 'new',
            'context': {
                'default_business_unit_id': bu_id,
                'default_date_from': self.date_from,
                'default_date_to': self.date_to,
            }
        }


class OpsBranchReport(models.TransientModel):
    """Branch-Level Profit & Loss Report"""
    _name = 'ops.branch.report'
    _description = 'Branch-Level Profit & Loss Report'
    
    # Filter Fields
    branch_id = fields.Many2one(
        'ops.branch',
        string='Branch',
        required=True
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # BU Filtering
    business_unit_ids = fields.Many2many(
        'ops.business.unit',
        string='Filter Business Units'
    )
    
    # Report Data
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    @api.depends('branch_id', 'date_from', 'date_to', 'business_unit_ids')
    def _compute_report_data(self):
        """Compute branch-level P&L report."""
        for wizard in self:
            if not wizard.branch_id or not wizard.date_from or not wizard.date_to:
                wizard.report_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            base_domain = [
                ('date', '>=', wizard.date_from),
                ('date', '<=', wizard.date_to),
                ('ops_branch_id', '=', wizard.branch_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            # Apply BU filter if specified
            if wizard.business_unit_ids:
                base_domain.append(('ops_business_unit_id', 'in', wizard.business_unit_ids.ids))
            
            # Get BU performance data
            bu_performance = {}
            # Get business units that operate in this branch
            if wizard.business_unit_ids:
                bus = wizard.business_unit_ids
            else:
                bus = self.env['ops.business.unit'].search([
                    ('branch_ids', 'in', [wizard.branch_id.id])
                ])
            
            for bu in bus:
                bu_domain = base_domain + [('ops_business_unit_id', '=', bu.id)]
                
                # Income for this BU
                MoveLine._read_group(
                    domain=bu_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                    groupby=[],
                    aggregates=['credit:sum', 'debit:sum']
                )
                bu_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
                
                # Expense for this BU
                MoveLine._read_group(
                    domain=bu_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                    groupby=[],
                    aggregates=['debit:sum', 'credit:sum']
                )
                bu_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
                
                bu_performance[bu.id] = {
                    'bu_id': bu.id,
                    'bu_code': bu.code,
                    'bu_name': bu.name,
                    'income': bu_income,
                    'expense': bu_expense,
                    'net_profit': bu_income - bu_expense,
                    'margin': ((bu_income - bu_expense) / bu_income * 100) if bu_income else 0,
                    'transaction_count': MoveLine.search_count(bu_domain),
                }
            
            # Get branch totals
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            total_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            total_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
            
            # Get top products/services (if sale/purchase modules installed)
            top_products = []
            if 'sale.order.line' in self.env:
                try:
                    sale_lines = self.env['sale.order.line'].search([
                        ('order_id.ops_branch_id', '=', wizard.branch_id.id),
                        ('order_id.date_order', '>=', wizard.date_from),
                        ('order_id.date_order', '<=', wizard.date_to),
                        ('order_id.state', 'in', ['sale', 'done']),
                    ], limit=10)
                    
                    for line in sale_lines:
                        top_products.append({
                            'product': line.product_id.name if line.product_id else 'N/A',
                            'quantity': line.product_uom_qty,
                            'revenue': line.price_subtotal,
                        })
                except Exception as e:
                    _logger.warning(f"Could not fetch sale order lines: {e}")
            
            wizard.report_data = {
                'branch': wizard.branch_id.name,
                'branch_code': wizard.branch_id.code,
                'company': wizard.branch_id.company_id.name,
                'period': f"{wizard.date_from} to {wizard.date_to}",
                'bu_performance': list(bu_performance.values()),
                'totals': {
                    'total_income': total_income,
                    'total_expense': total_expense,
                    'net_profit': total_income - total_expense,
                    'bu_count': len(bus),
                    'transaction_count': MoveLine.search_count(base_domain),
                },
                'top_products': top_products[:5],
            }
    
    def action_generate_pdf(self):
        """Generate PDF report for branch."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_branch_pl_pdf').report_action(self)


class OpsBusinessUnitReport(models.TransientModel):
    """Business Unit Profitability Report"""
    _name = 'ops.business.unit.report'
    _description = 'Business Unit Profitability Report'
    
    # Filter Fields
    business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=True
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # Branch Filtering
    branch_ids = fields.Many2many(
        'ops.branch',
        string='Filter Branches'
    )
    
    business_unit_branch_ids = fields.Many2many(
        'ops.branch',
        compute='_compute_business_unit_branch_ids',
        store=False
    )
    
    # Include branch consolidation
    consolidate_by_branch = fields.Boolean(
        string='Show Branch Breakdown',
        default=True
    )
    
    # Report Data
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    @api.depends('business_unit_id')
    def _compute_business_unit_branch_ids(self):
        """Compute available branches for the selected business unit."""
        for wizard in self:
            if wizard.business_unit_id:
                wizard.business_unit_branch_ids = wizard.business_unit_id.branch_ids
            else:
                wizard.business_unit_branch_ids = False
    
    @api.depends('business_unit_id', 'date_from', 'date_to', 'branch_ids', 'consolidate_by_branch')
    def _compute_report_data(self):
        """Compute BU performance across branches."""
        for wizard in self:
            if not wizard.business_unit_id or not wizard.date_from or not wizard.date_to:
                wizard.report_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            base_domain = [
                ('date', '>=', wizard.date_from),
                ('date', '<=', wizard.date_to),
                ('ops_business_unit_id', '=', wizard.business_unit_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            # Apply branch filter if specified
            branches = wizard.branch_ids if wizard.branch_ids else wizard.business_unit_id.branch_ids
            if wizard.branch_ids:
                base_domain.append(('ops_branch_id', 'in', wizard.branch_ids.ids))
            
            # Branch performance breakdown
            branch_performance = {}
            if wizard.consolidate_by_branch:
                for branch in branches:
                    branch_domain = base_domain + [('ops_branch_id', '=', branch.id)]
                    
                    # Income for this branch
                    MoveLine._read_group(
                        domain=branch_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                        groupby=[],
                        aggregates=['credit:sum', 'debit:sum']
                    )
                    branch_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
                    
                    # Expense for this branch
                    MoveLine._read_group(
                        domain=branch_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                        groupby=[],
                        aggregates=['debit:sum', 'credit:sum']
                    )
                    branch_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
                    
                    branch_performance[branch.id] = {
                        'branch_id': branch.id,
                        'branch_code': branch.code,
                        'branch_name': branch.name,
                        'income': branch_income,
                        'expense': branch_expense,
                        'net_profit': branch_income - branch_expense,
                        'contribution_percentage': 0,  # Will calculate after totals
                        'transaction_count': MoveLine.search_count(branch_domain),
                    }
            
            # Get BU totals
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            total_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            MoveLine._read_group(
                domain=base_domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            total_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
            
            total_net = total_income - total_expense
            
            # Calculate contribution percentages
            for branch_id, data in branch_performance.items():
                if total_income > 0:
                    data['contribution_percentage'] = (data['income'] / total_income * 100)
                else:
                    data['contribution_percentage'] = 0
            
            # Sort branches by contribution (descending)
            sorted_branches = sorted(
                branch_performance.values(),
                key=lambda x: x['contribution_percentage'],
                reverse=True
            )
            
            wizard.report_data = {
                'business_unit': wizard.business_unit_id.name,
                'business_unit_code': wizard.business_unit_id.code,
                'primary_branch': wizard.business_unit_id.primary_branch_id.name if wizard.business_unit_id.primary_branch_id else 'None',
                'period': f"{wizard.date_from} to {wizard.date_to}",
                'branch_performance': sorted_branches,
                'totals': {
                    'total_income': total_income,
                    'total_expense': total_expense,
                    'net_profit': total_net,
                    'profit_margin': (total_net / total_income * 100) if total_income else 0,
                    'branch_count': len(branches),
                    'active_branches': len([b for b in branch_performance.values() if b['transaction_count'] > 0]),
                    'total_transactions': MoveLine.search_count(base_domain),
                },
                'trend_data': wizard._get_trend_data(),
            }
    
    def _get_trend_data(self):
        """Get monthly trend data for the past 6 months."""
        MoveLine = self.env['account.move.line']
        trend_data = []
        
        for i in range(6, -1, -1):  # Last 6 months plus current
            month_start = date_utils.start_of(datetime.now() - timedelta(days=30*i), 'month')
            month_end = date_utils.end_of(month_start, 'month')
            
            domain = [
                ('date', '>=', month_start),
                ('date', '<=', month_end),
                ('ops_business_unit_id', '=', self.business_unit_id.id),
                ('move_id.state', '=', 'posted'),
            ]
            
            if self.branch_ids:
                domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
            
            MoveLine._read_group(
                domain=domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                groupby=[],
                aggregates=['credit:sum', 'debit:sum']
            )
            month_income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
            
            MoveLine._read_group(
                domain=domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                groupby=[],
                aggregates=['debit:sum', 'credit:sum']
            )
            month_expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
            
            trend_data.append({
                'month': month_start.strftime('%b %Y'),
                'income': month_income,
                'expense': month_expense,
                'net_profit': month_income - month_expense,
                'transaction_count': MoveLine.search_count(domain),
            })
        
        return trend_data
    
    def action_generate_pdf(self):
        """Generate PDF report for business unit."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_business_unit_pdf').report_action(self)


class OpsConsolidatedBalanceSheet(models.TransientModel):
    """Group-Level Balance Sheet Consolidation"""
    _name = 'ops.consolidated.balance.sheet'
    _description = 'Group-Level Balance Sheet Consolidation'
    
    # Company Selection
    company_ids = fields.Many2many(
        'res.company',
        string='Companies',
        required=True,
        default=lambda self: self.env.company
    )
    
    # Date for balance sheet
    date = fields.Date(
        string='As of Date',
        required=True,
        default=fields.Date.today
    )
    
    # Consolidation Options
    include_intercompany = fields.Boolean(
        string='Include Intercompany Eliminations',
        default=True
    )
    
    currency_id = fields.Many2one(
        'res.currency',
        string='Reporting Currency',
        default=lambda self: self.env.company.currency_id
    )
    
    # Report Data
    report_data = fields.Json(
        string='Report Data',
        compute='_compute_report_data',
        store=False
    )
    
    @api.depends('company_ids', 'date', 'include_intercompany', 'currency_id')
    def _compute_report_data(self):
        """Compute consolidated balance sheet for multiple companies."""
        for wizard in self:
            if not wizard.company_ids or not wizard.date:
                wizard.report_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            
            # Get balance sheet data for each company
            company_data = []
            total_assets = total_liabilities = total_equity = 0
            
            for company in wizard.company_ids:
                domain = [
                    ('date', '<=', wizard.date),
                    ('company_id', '=', company.id),
                    ('move_id.state', '=', 'posted'),
                    ('account_id.include_initial_balance', '=', True),
                ]
                
                # Group by account type
                MoveLine._read_group(
                    domain=domain,
                    groupby=['account_id'],
                    aggregates=['balance:sum']
                )
                
                # Initialize totals
                assets = liabilities = equity = income = expense = 0
                
                for group in grouped_data:
                    if group.get('account_id'):
                        account = self.env['account.account'].browse(group['account_id'][0])
                        balance = group.get('balance', 0)
                        
                        if account.account_type and account.account_type.startswith('asset'):
                            assets += balance
                        elif account.account_type and account.account_type.startswith('liability'):
                            liabilities += balance
                        elif account.account_type == 'equity':
                            equity += balance
                        elif account.account_type in ['income', 'income_other']:
                            income += balance
                        elif account.account_type in ['expense', 'expense_depreciation', 'expense_direct_cost']:
                            expense += balance
                
                # Calculate net income/loss for period
                net_income = income + expense  # Expense is negative in accounting
                
                company_data.append({
                    'company_id': company.id,
                    'company_name': company.name,
                    'company_code': company.ops_code if hasattr(company, 'ops_code') else company.name,
                    'assets': assets,
                    'liabilities': liabilities,
                    'equity': equity + net_income,  # Include current year profit/loss
                    'net_income': net_income,
                    'currency': company.currency_id.name,
                })
                
                # Accumulate totals
                total_assets += assets
                total_liabilities += liabilities
                total_equity += equity + net_income
            
            # Apply intercompany eliminations if requested
            eliminations = {'asset_eliminations': 0, 'liability_eliminations': 0}
            if wizard.include_intercompany and len(wizard.company_ids) > 1:
                eliminations = wizard._calculate_intercompany_eliminations(wizard.company_ids.ids, wizard.date)
                total_assets -= eliminations.get('asset_eliminations', 0)
                total_liabilities -= eliminations.get('liability_eliminations', 0)
            
            wizard.report_data = {
                'report_date': str(wizard.date),
                'companies': company_data,
                'consolidated': {
                    'total_assets': total_assets,
                    'total_liabilities': total_liabilities,
                    'total_equity': total_equity,
                    'balance_check': total_assets - (total_liabilities + total_equity),
                },
                'eliminations': eliminations,
                'reporting_currency': wizard.currency_id.name,
                'company_count': len(wizard.company_ids),
            }
    
    def _calculate_intercompany_eliminations(self, company_ids, date):
        """Calculate intercompany eliminations for consolidation."""
        MoveLine = self.env['account.move.line']
        
        # Find intercompany accounts (accounts marked as intercompany)
        intercompany_accounts = self.env['account.account'].search([
            ('company_id', 'in', company_ids),
            ('reconcile', '=', True),  # Use reconcile flag as proxy for intercompany
        ])
        
        asset_eliminations = 0
        liability_eliminations = 0
        
        for account in intercompany_accounts:
            if 'intercompany' not in account.name.lower():
                continue
                
            domain = [
                ('date', '<=', date),
                ('account_id', '=', account.id),
                ('company_id', 'in', company_ids),
                ('move_id.state', '=', 'posted'),
            ]
            
            MoveLine._read_group(
                domain=domain,
                groupby=['company_id'],
                aggregates=['balance:sum']
            )
            
            # Sum balances across companies
            total_balance = sum(item.get('balance', 0) for item in result)
            
            # If total balance across companies is not zero, there's an elimination
            if abs(total_balance) > 0.01:  # Tolerance for floating point
                if account.account_type and account.account_type.startswith('asset'):
                    asset_eliminations += total_balance
                elif account.account_type and account.account_type.startswith('liability'):
                    liability_eliminations += total_balance
        
        return {
            'asset_eliminations': asset_eliminations,
            'liability_eliminations': liability_eliminations,
        }
    
    def action_generate_pdf(self):
        """Generate PDF consolidated balance sheet."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.report_consolidated_balance_sheet_pdf').report_action(self)


class OpsMatrixProfitabilityAnalysis(models.TransientModel):
    """Matrix Profitability Analysis (Branch x BU)"""
    _name = 'ops.matrix.profitability.analysis'
    _description = 'Matrix Profitability Analysis (Branch x BU)'
    
    # Filter Fields
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'month')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # Report Data
    matrix_data = fields.Json(
        string='Matrix Data',
        compute='_compute_matrix_data',
        store=False
    )
    
    @api.depends('company_id', 'date_from', 'date_to')
    def _compute_matrix_data(self):
        """Compute profitability matrix across branches and BUs."""
        for wizard in self:
            if not wizard.company_id or not wizard.date_from or not wizard.date_to:
                wizard.matrix_data = {}
                continue
            
            MoveLine = self.env['account.move.line']
            
            # Get all branches and BUs for the company
            branches = self.env['ops.branch'].search([
                ('company_id', '=', wizard.company_id.id),
                ('active', '=', True)
            ])
            
            bus = self.env['ops.business.unit'].search([
                ('company_ids', 'in', [wizard.company_id.id]),
                ('active', '=', True)
            ])
            
            # Initialize matrix
            matrix = {}
            branch_totals = {branch.id: {'income': 0, 'expense': 0} for branch in branches}
            bu_totals = {bu.id: {'income': 0, 'expense': 0} for bu in bus}
            
            # Populate matrix with data
            for branch in branches:
                for bu in bus:
                    key = f"{branch.id}-{bu.id}"
                    
                    # Check if BU operates in this branch
                    if branch in bu.branch_ids:
                        domain = [
                            ('date', '>=', wizard.date_from),
                            ('date', '<=', wizard.date_to),
                            ('ops_branch_id', '=', branch.id),
                            ('ops_business_unit_id', '=', bu.id),
                            ('move_id.state', '=', 'posted'),
                        ]
                        
                        # Get income
                        MoveLine._read_group(
                            domain=domain + [('account_id.account_type', 'in', ['income', 'income_other'])],
                            groupby=[],
                            aggregates=['credit:sum', 'debit:sum']
                        )
                        income = income_result[0]['credit'] - income_result[0]['debit'] if income_result else 0
                        
                        # Get expense
                        MoveLine._read_group(
                            domain=domain + [('account_id.account_type', 'in', ['expense', 'expense_depreciation', 'expense_direct_cost'])],
                            groupby=[],
                            aggregates=['debit:sum', 'credit:sum']
                        )
                        expense = expense_result[0]['debit'] - expense_result[0]['credit'] if expense_result else 0
                        
                        net_profit = income - expense
                        
                        matrix[key] = {
                            'branch_id': branch.id,
                            'branch_code': branch.code,
                            'branch_name': branch.name,
                            'bu_id': bu.id,
                            'bu_code': bu.code,
                            'bu_name': bu.name,
                            'income': income,
                            'expense': expense,
                            'net_profit': net_profit,
                            'profitability': (net_profit / income * 100) if income else 0,
                            'transaction_count': MoveLine.search_count(domain),
                        }
                        
                        # Update totals
                        branch_totals[branch.id]['income'] += income
                        branch_totals[branch.id]['expense'] += expense
                        bu_totals[bu.id]['income'] += income
                        bu_totals[bu.id]['expense'] += expense
            
            # Calculate overall totals
            total_income = sum(data['income'] for data in matrix.values())
            total_expense = sum(data['expense'] for data in matrix.values())
            total_net = total_income - total_expense
            
            # Find top performing combinations
            matrix_values = list(matrix.values())
            matrix_values.sort(key=lambda x: x['net_profit'], reverse=True)
            top_performers = matrix_values[:5]
            bottom_performers = matrix_values[-5:] if len(matrix_values) >= 5 else []
            
            wizard.matrix_data = {
                'company': wizard.company_id.name,
                'period': f"{wizard.date_from} to {wizard.date_to}",
                'matrix': matrix_values,
                'branch_totals': branch_totals,
                'bu_totals': bu_totals,
                'summary': {
                    'total_income': total_income,
                    'total_expense': total_expense,
                    'total_net_profit': total_net,
                    'total_combinations': len(matrix),
                    'active_combinations': len([m for m in matrix_values if m['transaction_count'] > 0]),
                    'top_performers': top_performers,
                    'bottom_performers': bottom_performers,
                    'average_profitability': sum(m['profitability'] for m in matrix_values) / len(matrix_values) if matrix_values else 0,
                },
            }
    
    def action_generate_heatmap(self):
        """Generate heatmap visualization data (displays as notification for now)."""
        self.ensure_one()
        
        # Get matrix data summary
        matrix_data = self.matrix_data or {}
        summary = matrix_data.get('summary', {})
        
        # Create user-friendly message
        message = _(
            "Matrix Profitability Analysis Results:\n\n"
            "Total Income: %(income).2f\n"
            "Total Expense: %(expense).2f\n"
            "Total Net Profit: %(profit).2f\n"
            "Active Combinations: %(combinations)d\n"
            "Average Profitability: %(avg_profit).2f%%\n\n"
            "View the detailed data in the wizard form below."
        ) % {
            'income': summary.get('total_income', 0),
            'expense': summary.get('total_expense', 0),
            'profit': summary.get('total_net_profit', 0),
            'combinations': summary.get('active_combinations', 0),
            'avg_profit': summary.get('average_profitability', 0),
        }
        
        # Return action to show notification and keep wizard open
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Matrix Analysis Complete'),
                'message': message,
                'type': 'info',
                'sticky': False,
                'next': {
                    'type': 'ir.actions.act_window_close'
                }
            }
        }

--- ops_matrix_accounting/models/ops_matrix_standard_extensions.py ---
from odoo import models, fields, api

class SaleOrder(models.Model):
    _inherit = 'sale.order'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this sale"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this sale belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    def _prepare_invoice(self):
        """Propagate matrix dimensions to created invoice."""
        invoice_vals = super()._prepare_invoice()
        invoice_vals.update({
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
        })
        return invoice_vals


class PurchaseOrder(models.Model):
    _inherit = 'purchase.order'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this purchase"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this purchase belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    def _prepare_invoice(self):
        """Propagate matrix dimensions to created bill."""
        invoice_vals = super()._prepare_invoice()
        invoice_vals.update({
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
        })
        return invoice_vals


class StockPicking(models.Model):
    _inherit = 'stock.picking'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this transfer"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this transfer belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    @api.model_create_multi
    def create(self, vals_list):
        """Inherit matrix dimensions from source document."""
        for vals in vals_list:
            if vals.get('origin'):
                # Try to find source document
                sale_order = self.env['sale.order'].search([('name', '=', vals['origin'])], limit=1)
                if sale_order:
                    vals.update({
                        'ops_branch_id': sale_order.ops_branch_id.id,
                        'ops_business_unit_id': sale_order.ops_business_unit_id.id,
                    })
                    continue

                purchase_order = self.env['purchase.order'].search([('name', '=', vals['origin'])], limit=1)
                if purchase_order:
                    vals.update({
                        'ops_branch_id': purchase_order.ops_branch_id.id,
                        'ops_business_unit_id': purchase_order.ops_business_unit_id.id,
                    })
        
        return super().create(vals_list)


class AccountMove(models.Model):
    _inherit = 'account.move'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch responsible for this entry"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit this entry belongs to"
    )
    
    def _get_default_branch(self):
        """Get default branch from user or first available"""
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit or first available"""
        return self.env['ops.business.unit'].search([], limit=1)

    @api.model_create_multi
    def create(self, vals_list):
        """Ensure matrix dimensions are properly set."""
        moves = super().create(vals_list)
        for move in moves:
            # Propagate dimensions to lines if not already set
            for line in move.line_ids:
                if not line.ops_branch_id:
                    line.ops_branch_id = move.ops_branch_id
                if not line.ops_business_unit_id:
                    line.ops_business_unit_id = move.ops_business_unit_id
        return moves


class AccountMoveLine(models.Model):
    _inherit = 'account.move.line'

    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        required=False,
        default=lambda self: self._get_default_branch(),
        help="Branch for this journal item"
    )
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        required=False,
        default=lambda self: self._get_default_business_unit(),
        help="Business unit for this journal item"
    )
    
    def _get_default_branch(self):
        """Get default branch from move or user or first available"""
        if self.move_id and self.move_id.ops_branch_id:
            return self.move_id.ops_branch_id
        if hasattr(self.env.user, 'branch_id') and self.env.user.branch_id:
            return self.env.user.branch_id
        return self.env['res.company'].search([], limit=1)
    
    def _get_default_business_unit(self):
        """Get default business unit from move or first available"""
        if self.move_id and self.move_id.ops_business_unit_id:
            return self.move_id.ops_business_unit_id
        return self.env['ops.business.unit'].search([], limit=1)

    @api.model_create_multi
    def create(self, vals_list):
        """Ensure matrix dimensions are inherited from parent move."""
        for vals in vals_list:
            if vals.get('move_id'):
                move = self.env['account.move'].browse(vals['move_id'])
                if not vals.get('ops_branch_id'):
                    vals['ops_branch_id'] = move.ops_branch_id.id
                if not vals.get('ops_business_unit_id'):
                    vals['ops_business_unit_id'] = move.ops_business_unit_id.id
        
        return super().create(vals_list)

--- ops_matrix_accounting/models/ops_pdc.py ---
from odoo import models, fields, api
from odoo.exceptions import ValidationError

class OpsPostDatedCheck(models.Model):
    _name = 'ops.pdc'
    _description = 'Post-Dated Check'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _order = 'maturity_date desc, id desc'

    name = fields.Char(string='Reference', required=True, readonly=True, default='New')
    partner_id = fields.Many2one('res.partner', string='Partner', required=True)
    date = fields.Date(string='Issue Date', required=True, tracking=True)
    maturity_date = fields.Date(string='Maturity Date', required=True, tracking=True)
    amount = fields.Monetary(string='Amount', required=True)
    currency_id = fields.Many2one('res.currency', string='Currency', required=True, default=lambda self: self.env.company.currency_id)
    
    payment_type = fields.Selection([
        ('inbound', 'Customer'),
        ('outbound', 'Vendor')
    ], string='Payment Type', required=True)
    
    bank_id = fields.Many2one('res.bank', string='Bank', required=True)
    check_number = fields.Char(string='Check Number', required=True)
    
    state = fields.Selection([
        ('draft', 'Draft'),
        ('registered', 'Registered'),
        ('deposited', 'Deposited'),
        ('cleared', 'Cleared'),
        ('bounced', 'Bounced'),
        ('cancelled', 'Cancelled')
    ], string='Status', default='draft', tracking=True)

    # Matrix Dimensions
    ops_branch_id = fields.Many2one('res.company', string='Branch', required=True)
    ops_business_unit_id = fields.Many2one('ops.business.unit', string='Business Unit', required=True)
    
    # Accounting Fields
    journal_id = fields.Many2one('account.journal', string='PDC Journal', required=True, domain=[('type', '=', 'bank')])
    holding_account_id = fields.Many2one('account.account', string='PDC Holding Account', required=True)
    move_id = fields.Many2one('account.move', string='Registration Entry', readonly=True)
    deposit_move_id = fields.Many2one('account.move', string='Deposit Entry', readonly=True)
    
    # Anti-Fraud Security: Button-level authority for PDC management
    can_user_manage_pdc = fields.Boolean(
        compute='_compute_can_user_manage_pdc',
        string='Can Manage PDC',
        help='Technical field: User has authority to manage PDC operations (register, deposit, clear)'
    )
    
    @api.depends_context('uid')
    def _compute_can_user_manage_pdc(self):
        """
        Check if current user has authority to manage PDC operations.
        
        ADMIN BYPASS: System administrators always have access.
        PERSONA LOGIC: Uses additive authority - if ANY persona grants the right, access is granted.
        """
        for record in self:
            # Admin bypass
            if self.env.su or self.env.user.has_group('base.group_system'):
                record.can_user_manage_pdc = True
            else:
                # Check persona authority using the helper method
                record.can_user_manage_pdc = self.env.user.has_ops_authority('can_manage_pdc')

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            if vals.get('name', 'New') == 'New':
                vals['name'] = self.env['ir.sequence'].next_by_code('ops.pdc') or 'PDC/0001'
        return super().create(vals_list)

    @api.constrains('date', 'maturity_date')
    def _check_dates(self):
        for pdc in self:
            if pdc.maturity_date < pdc.date:
                raise ValidationError('Maturity Date cannot be earlier than Issue Date.')

    def _prepare_move_line_vals(self, account_id, debit, credit, name_suffix=''):
        """Helper to prepare consistent move line values with matrix dimensions."""
        return {
            'account_id': account_id,
            'partner_id': self.partner_id.id,
            'name': f'{name_suffix} - {self.check_number}',
            'debit': debit,
            'credit': credit,
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
        }

    def action_register(self):
        """Register the PDC and create initial journal entry."""
        self.ensure_one()
        if self.state != 'draft':
            raise ValidationError('Only draft PDCs can be registered.')

        # Determine accounts based on payment type
        if self.payment_type == 'inbound':
            partner_account = self.partner_id.property_account_receivable_id
            debit_account = self.holding_account_id
            credit_account = partner_account
        else:  # outbound
            partner_account = self.partner_id.property_account_payable_id
            debit_account = partner_account
            credit_account = self.holding_account_id

        move_vals = {
            'journal_id': self.journal_id.id,
            'date': self.date,
            'ref': f'PDC Registration - {self.name}',
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
            'line_ids': [
                (0, 0, self._prepare_move_line_vals(
                    debit_account.id, self.amount, 0.0, 'PDC Holding'
                )),
                (0, 0, self._prepare_move_line_vals(
                    credit_account.id, 0.0, self.amount, 'PDC Registration'
                ))
            ]
        }
        
        move = self.env['account.move'].create(move_vals)
        move.action_post()
        
        self.write({
            'state': 'registered',
            'move_id': move.id
        })

    def action_deposit(self):
        """Deposit the PDC and create bank entry."""
        self.ensure_one()
        if self.state != 'registered':
            raise ValidationError('Only registered PDCs can be deposited.')

        # Get bank account from journal
        if not self.journal_id.default_account_id:
            raise ValidationError('Bank journal must have a default account configured.')

        # Determine accounts based on payment type
        if self.payment_type == 'inbound':
            debit_account = self.journal_id.default_account_id
            credit_account = self.holding_account_id
        else:  # outbound
            debit_account = self.holding_account_id
            credit_account = self.journal_id.default_account_id

        move_vals = {
            'journal_id': self.journal_id.id,
            'date': fields.Date.today(),
            'ref': f'PDC Deposit - {self.name}',
            'ops_branch_id': self.ops_branch_id.id,
            'ops_business_unit_id': self.ops_business_unit_id.id,
            'line_ids': [
                (0, 0, self._prepare_move_line_vals(
                    debit_account.id, self.amount, 0.0, 'PDC Bank Deposit'
                )),
                (0, 0, self._prepare_move_line_vals(
                    credit_account.id, 0.0, self.amount, 'PDC Holding Clearance'
                ))
            ]
        }
        
        move = self.env['account.move'].create(move_vals)
        move.action_post()
        
        self.write({
            'state': 'deposited',
            'deposit_move_id': move.id
        })

--- ops_matrix_accounting/models/ops_product_category_defaults.py ---
from odoo import models, fields, api

class OpsProductCategory(models.Model):
    _inherit = 'product.category'

    # Override inventory valuation fields to enforce defaults
    property_cost_method = fields.Selection(
        default='fifo',
        readonly=True,
        help="FIFO costing method enforced by Matrix Operations"
    )
    
    property_valuation = fields.Selection(
        default='real_time',
        readonly=True,
        help="Real-time valuation enforced by Matrix Operations"
    )

    @api.constrains('property_cost_method', 'property_valuation')
    def _check_accounting_fields_not_empty(self):
        """Ensure costing and valuation methods are always set."""
        for record in self:
            if not record.property_cost_method:
                record.property_cost_method = 'fifo'
            if not record.property_valuation:
                record.property_valuation = 'real_time'

    @api.model
    def default_get(self, fields_list):
        """Override to auto-populate accounting fields with smart defaults."""
        defaults = super().default_get(fields_list)
        
        try:
            company = self.env.company
            account_obj = self.env['account.account']

            # Helper function to find accounts - simplified for Odoo 19 compatibility
            def find_account(fallback_type=None):
                if fallback_type:
                    try:
                        account = account_obj.search([
                            ('account_type', '=', fallback_type)
                        ], limit=1)
                        return account.id if account else False
                    except Exception:
                        pass
                return False

            # 1. Income Account (Sales)
            if 'property_account_income_categ_id' in fields_list:
                income_account = find_account(fallback_type='income')
                defaults['property_account_income_categ_id'] = income_account

            # 2. Expense Account (COGS)
            if 'property_account_expense_categ_id' in fields_list:
                expense_account = find_account(fallback_type='expense')
                defaults['property_account_expense_categ_id'] = expense_account

            # 3. Stock Valuation Account
            if 'property_stock_valuation_account_id' in fields_list:
                valuation_account = find_account(fallback_type='asset_current')
                defaults['property_stock_valuation_account_id'] = valuation_account

            # 4. Stock Input Account
            if 'property_stock_account_input_categ_id' in fields_list:
                input_account = find_account(fallback_type='asset_current')
                defaults['property_stock_account_input_categ_id'] = input_account

            # 5. Stock Output Account
            if 'property_stock_account_output_categ_id' in fields_list:
                output_account = find_account(fallback_type='asset_current')
                defaults['property_stock_account_output_categ_id'] = output_account

        except Exception:
            # Gracefully fall back if account lookup fails
            pass

        return defaults


class OpsProductTemplate(models.Model):
    _inherit = 'product.template'

    @api.model
    def default_get(self, fields_list):
        """Ensure products inherit category defaults properly."""
        defaults = super().default_get(fields_list)
        
        # If no category specified, find or create the default category
        if not defaults.get('categ_id'):
            default_category = self.env['product.category'].search([
                ('name', '=', 'All'),
                ('parent_id', '=', False)
            ], limit=1)
            
            if not default_category:
                default_category = self.env['product.category'].create({
                    'name': 'All'
                })
            
            defaults['categ_id'] = default_category.id
        
        return defaults

    @api.onchange('categ_id')
    def _onchange_categ_id(self):
        """Ensure accounting fields are properly inherited from category."""
        if self.categ_id:
            self.property_account_income_id = False  # Force inherit from category
            self.property_account_expense_id = False  # Force inherit from category

--- ops_matrix_accounting/wizard/__init__.py ---
from . import ops_financial_report_wizard
from . import ops_general_ledger_wizard
from . import ops_general_ledger_wizard_enhanced

--- ops_matrix_accounting/wizard/ops_financial_report_wizard.py ---
from odoo import models, fields, api, _
from odoo.exceptions import UserError
from dateutil.relativedelta import relativedelta
import io
import base64

class OpsFinancialReportWizard(models.TransientModel):
    """
    Lightweight Financial Reporting Wizard for Zero DB Bloat.
    Uses native Odoo views for on-screen analysis and in-memory generation for exports.
    """
    _name = 'ops.financial.report.wizard'
    _description = 'Financial Report Wizard'

    report_type = fields.Selection([
        ('pl', 'P&L'),
        ('bs', 'Balance Sheet'),
        ('gl', 'General Ledger'),
        ('aged', 'Aged Partner')
    ], string='Report Type', required=True, default='gl')
    
    date_from = fields.Date(string='Date From', required=True)
    date_to = fields.Date(string='Date To', required=True)
    
    branch_id = fields.Many2one(
        'ops.branch',
        string='Branch',
        help="Filter by branch (via analytic account)"
    )
    
    target_move = fields.Selection([
        ('posted', 'Posted Only'),
        ('all', 'All')
    ], string='Target Moves', default='posted', required=True)
    
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    
    journal_ids = fields.Many2many(
        'account.journal',
        string='Journals',
        help='Leave empty to include all journals'
    )

    @api.model
    def default_get(self, fields_list):
        """Set default date range to current month."""
        res = super().default_get(fields_list)
        
        today = fields.Date.context_today(self)
        first_day = today.replace(day=1)
        last_day = (first_day + relativedelta(months=1, days=-1))
        
        if 'date_from' in fields_list:
            res['date_from'] = first_day
        if 'date_to' in fields_list:
            res['date_to'] = last_day
        
        return res

    def _get_domain(self):
        """Build domain for account.move.line based on wizard filters."""
        self.ensure_one()
        
        domain = [
            ('date', '>=', self.date_from),
            ('date', '<=', self.date_to),
            ('company_id', '=', self.company_id.id),
        ]
        
        # Filter by move state
        if self.target_move == 'posted':
            domain.append(('move_id.state', '=', 'posted'))
        
        # Filter by branch (via ops_branch_id field)
        # Note: In Odoo 19, analytic_account_id is not available on account.move.line
        # We use ops_branch_id field added by ops_matrix_core module
        if self.branch_id:
            domain.append(('ops_branch_id', '=', self.branch_id.id))
        
        # Filter by journals if specified
        if self.journal_ids:
            domain.append(('journal_id', 'in', self.journal_ids.ids))
        
        return domain

    def _get_context_groupings(self):
        """Return default groupings based on report type."""
        self.ensure_one()
        
        context = {}
        
        if self.report_type == 'pl':
            # P&L: Group by account type (Income/Expense)
            context.update({
                'pivot_row_groupby': ['account_id'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        elif self.report_type == 'bs':
            # Balance Sheet: Group by account type (Asset/Liability)
            context.update({
                'pivot_row_groupby': ['account_id'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        elif self.report_type == 'gl':
            # General Ledger: Group by account and date
            context.update({
                'pivot_row_groupby': ['account_id', 'date'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        elif self.report_type == 'aged':
            # Aged Partner: Group by partner
            context.update({
                'pivot_row_groupby': ['partner_id'],
                'pivot_column_groupby': [],
                'pivot_measures': ['debit', 'credit', 'balance'],
            })
        
        return context

    def action_view_data(self):
        """
        Open account.move.line in pivot/tree view with filters applied.
        NO intermediate records created - Zero DB Bloat approach.
        """
        self.ensure_one()
        
        domain = self._get_domain()
        context = self._get_context_groupings()
        
        return {
            'name': _('%s - On-Screen Analysis') % dict(self._fields['report_type'].selection).get(self.report_type),
            'type': 'ir.actions.act_window',
            'res_model': 'account.move.line',
            'view_mode': 'pivot,tree',
            'views': [(False, 'pivot'), (False, 'tree')],
            'domain': domain,
            'context': context,
            'target': 'current',
        }

    def action_print_pdf(self):
        """Generate PDF report using AbstractModel parser (in-memory processing)."""
        self.ensure_one()
        return self.env.ref('ops_matrix_accounting.action_report_ops_financial').report_action(self)

    def action_export_xlsx(self):
        """Export to Excel using in-memory generation."""
        self.ensure_one()
        
        # Get the report parser (must match parser _name)
        report_parser = self.env['report.ops_matrix_accounting.report_ops_financial_document']
        report_data = report_parser._get_report_data(self)
        
        # Generate XLSX file
        try:
            import xlsxwriter
            output = io.BytesIO()
            workbook = xlsxwriter.Workbook(output, {'in_memory': True})
            worksheet = workbook.add_worksheet(report_data['title'])
            
            # Formats
            header_format = workbook.add_format({
                'bold': True,
                'bg_color': '#D3D3D3',
                'border': 1
            })
            
            # Write headers
            col = 0
            for header in report_data['headers']:
                worksheet.write(0, col, header, header_format)
                col += 1
            
            # Write data
            row = 1
            for line in report_data['lines']:
                col = 0
                for value in line.values():
                    worksheet.write(row, col, value)
                    col += 1
                row += 1
            
            workbook.close()
            output.seek(0)
            
            # Create attachment
            filename = f"{report_data['title']}_{self.date_from}_{self.date_to}.xlsx"
            attachment = self.env['ir.attachment'].create({
                'name': filename,
                'type': 'binary',
                'datas': base64.b64encode(output.read()),
                'mimetype': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            })
            
            return {
                'type': 'ir.actions.act_url',
                'url': f'/web/content/{attachment.id}?download=true',
                'target': 'new',
            }
            
        except ImportError:
            raise UserError(_('xlsxwriter library is not installed. Please install it to export to Excel.'))

--- ops_matrix_accounting/wizard/ops_general_ledger_wizard.py ---
from odoo import models, fields, api

class OpsGeneralLedgerWizard(models.TransientModel):
    _name = 'ops.general.ledger.wizard'
    _inherit = 'ops.financial.report.wizard'
    _description = 'General Ledger Report Wizard'

    account_ids = fields.Many2many('account.account', string='Accounts', 
                                     help='Leave empty to include all accounts')

    def action_print_pdf(self):
        self.ensure_one()
        data = {
            'date_from': self.date_from,
            'date_to': self.date_to,
            'target_move': self.target_move,
            'journal_ids': self.journal_ids.ids,
            'account_ids': self.account_ids.ids if self.account_ids else [],
            'company_id': self.company_id.id,
        }
        return self.env.ref('ops_matrix_accounting.action_report_general_ledger').report_action(self, data=data)

--- ops_matrix_accounting/wizard/ops_general_ledger_wizard_enhanced.py ---
# -*- coding: utf-8 -*-
"""
OPS Matrix Accounting - Enhanced General Ledger Wizard
======================================================

Comprehensive General Ledger wizard with matrix dimension filtering
(Branch and Business Unit) and advanced consolidation options.

Author: OPS Matrix Framework
"""

from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
from odoo.tools import date_utils, float_round
from datetime import datetime, timedelta
import logging

_logger = logging.getLogger(__name__)


class OpsGeneralLedgerWizardEnhanced(models.TransientModel):
    """Enhanced General Ledger Report Wizard with Matrix Dimensions"""
    _name = 'ops.general.ledger.wizard.enhanced'
    _description = 'General Ledger Report Wizard with Matrix Dimensions'
    
    # ============================================
    # 1. PERIOD FILTERS
    # ============================================
    date_from = fields.Date(
        string='From Date',
        required=True,
        default=lambda self: date_utils.start_of(datetime.now(), 'year')
    )
    date_to = fields.Date(
        string='To Date',
        required=True,
        default=lambda self: date_utils.end_of(datetime.now(), 'month')
    )
    
    # ============================================
    # 2. COMPANY & JOURNALS
    # ============================================
    company_id = fields.Many2one(
        'res.company',
        string='Company',
        required=True,
        default=lambda self: self.env.company
    )
    journal_ids = fields.Many2many(
        'account.journal',
        string='Journals',
        help='Leave empty for all journals'
    )
    
    # ============================================
    # 3. MATRIX DIMENSION FILTERS
    # ============================================
    
    # Branch Filter
    branch_ids = fields.Many2many(
        'ops.branch',
        'gl_wizard_branch_rel',
        'wizard_id',
        'branch_id',
        string='Branches',
        help='Filter by specific branches. Leave empty for all branches.'
    )
    
    # Business Unit Filter
    business_unit_ids = fields.Many2many(
        'ops.business.unit',
        'gl_wizard_bu_rel',
        'wizard_id',
        'bu_id',
        string='Business Units',
        help='Filter by specific business units. Leave empty for all BUs.'
    )
    
    # Matrix Combination Mode
    matrix_filter_mode = fields.Selection([
        ('any', 'Any Dimension (Branch OR BU)'),
        ('both', 'Both Dimensions (Branch AND BU)'),
        ('exact', 'Exact Combination'),
    ], string='Matrix Filter Mode', default='any', help="""
        - Any: Show transactions that match ANY selected branch/BU
        - Both: Show transactions that match BOTH selected branch AND BU
        - Exact: Show transactions with exact branch/BU combinations
    """)
    
    # ============================================
    # 4. ACCOUNT FILTERS
    # ============================================
    account_ids = fields.Many2many(
        'account.account',
        'gl_wizard_account_rel',
        'wizard_id',
        'account_id',
        string='Accounts',
        help='Filter by specific accounts. Leave empty for all accounts.'
    )
    
    account_type_ids = fields.Selection(
        selection=[
            ('asset_receivable', 'Receivable'),
            ('asset_cash', 'Bank and Cash'),
            ('asset_current', 'Current Assets'),
            ('asset_non_current', 'Non-current Assets'),
            ('asset_prepayments', 'Prepayments'),
            ('asset_fixed', 'Fixed Assets'),
            ('liability_payable', 'Payable'),
            ('liability_credit_card', 'Credit Card'),
            ('liability_current', 'Current Liabilities'),
            ('liability_non_current', 'Non-current Liabilities'),
            ('equity', 'Equity'),
            ('equity_unaffected', 'Current Year Earnings'),
            ('income', 'Income'),
            ('income_other', 'Other Income'),
            ('expense', 'Expenses'),
            ('expense_depreciation', 'Depreciation'),
            ('expense_direct_cost', 'Cost of Revenue'),
            ('off_balance', 'Off-Balance Sheet'),
        ],
        string='Account Type',
        help='Filter by specific account type'
    )
    
    display_account = fields.Selection([
        ('all', 'All Accounts'),
        ('movement', 'With Movements'),
        ('not_zero', 'With Balance Not Zero'),
    ], string='Display Accounts', default='movement', required=True)
    
    # ============================================
    # 5. TRANSACTION FILTERS
    # ============================================
    target_move = fields.Selection([
        ('posted', 'Posted Entries'),
        ('all', 'All Entries'),
    ], string='Target Moves', default='posted', required=True)
    
    reconciled = fields.Selection([
        ('all', 'All Items'),
        ('reconciled', 'Reconciled Only'),
        ('unreconciled', 'Unreconciled Only'),
    ], string='Reconciliation Status', default='all', required=True)
    
    # Partner Filter
    partner_ids = fields.Many2many(
        'res.partner',
        'gl_wizard_partner_rel',
        'wizard_id',
        'partner_id',
        string='Partners',
        help='Filter by specific partners'
    )
    
    # ============================================
    # 6. CONSOLIDATION & GROUPING OPTIONS
    # ============================================
    consolidate_by_branch = fields.Boolean(
        string='Consolidate by Branch',
        help='Show totals grouped by branch',
        default=False
    )
    
    consolidate_by_bu = fields.Boolean(
        string='Consolidate by Business Unit',
        help='Show totals grouped by business unit',
        default=False
    )
    
    consolidate_by_partner = fields.Boolean(
        string='Consolidate by Partner',
        help='Show totals grouped by partner',
        default=False
    )
    
    group_by_date = fields.Selection([
        ('none', 'No Grouping'),
        ('day', 'Daily'),
        ('week', 'Weekly'),
        ('month', 'Monthly'),
        ('quarter', 'Quarterly'),
        ('year', 'Yearly'),
    ], string='Group by Date', default='none', required=True)
    
    # ============================================
    # 7. OUTPUT OPTIONS
    # ============================================
    report_format = fields.Selection([
        ('detailed', 'Detailed Lines'),
        ('summary', 'Summary Only'),
        ('both', 'Both Detailed and Summary'),
    ], string='Report Format', default='detailed', required=True)
    
    sort_by = fields.Selection([
        ('date', 'Date'),
        ('account', 'Account'),
        ('partner', 'Partner'),
        ('branch', 'Branch'),
        ('bu', 'Business Unit'),
    ], string='Sort By', default='date', required=True)
    
    include_initial_balance = fields.Boolean(
        string='Include Initial Balance',
        default=True,
        help='Show opening balance before period'
    )
    
    # ============================================
    # 8. COMPUTED FIELDS
    # ============================================
    filter_summary = fields.Char(
        compute='_compute_filter_summary',
        string='Filter Summary',
        help='Summary of active filters'
    )
    
    record_count = fields.Integer(
        compute='_compute_record_count',
        string='Estimated Records',
        help='Estimated number of records matching filters'
    )
    
    # ============================================
    # COMPUTED METHODS
    # ============================================
    
    @api.depends('branch_ids', 'business_unit_ids', 'account_ids', 'journal_ids', 
                 'date_from', 'date_to', 'target_move', 'reconciled', 'partner_ids')
    def _compute_filter_summary(self):
        """Compute human-readable summary of active filters."""
        for wizard in self:
            parts = []
            
            # Date range
            if wizard.date_from and wizard.date_to:
                parts.append(f"Period: {wizard.date_from} to {wizard.date_to}")
            
            # Matrix dimensions
            if wizard.branch_ids:
                if len(wizard.branch_ids) <= 3:
                    branch_names = wizard.branch_ids.mapped('code')
                    parts.append(f"Branches: {', '.join(branch_names)}")
                else:
                    parts.append(f"Branches: {len(wizard.branch_ids)} selected")
            
            if wizard.business_unit_ids:
                if len(wizard.business_unit_ids) <= 3:
                    bu_names = wizard.business_unit_ids.mapped('code')
                    parts.append(f"BUs: {', '.join(bu_names)}")
                else:
                    parts.append(f"BUs: {len(wizard.business_unit_ids)} selected")
            
            # Accounts and journals
            if wizard.account_ids:
                parts.append(f"Accounts: {len(wizard.account_ids)} selected")
            
            if wizard.journal_ids:
                parts.append(f"Journals: {len(wizard.journal_ids)} selected")
            
            # Partners
            if wizard.partner_ids:
                parts.append(f"Partners: {len(wizard.partner_ids)} selected")
            
            # Transaction filters
            if wizard.target_move == 'posted':
                parts.append("Posted only")
            
            if wizard.reconciled == 'unreconciled':
                parts.append("Unreconciled")
            elif wizard.reconciled == 'reconciled':
                parts.append("Reconciled")
            
            wizard.filter_summary = " | ".join(parts) if parts else "No filters applied"
    
    @api.depends('date_from', 'date_to', 'company_id', 'branch_ids', 'business_unit_ids', 
                 'account_ids', 'target_move', 'journal_ids', 'partner_ids')
    def _compute_record_count(self):
        """Estimate number of records matching current filters."""
        for wizard in self:
            if not wizard.date_from or not wizard.date_to:
                wizard.record_count = 0
                continue
            
            try:
                # Build domain
                domain = wizard._build_domain()
                
                # Count records
                count = self.env['account.move.line'].search_count(domain)
                wizard.record_count = count
            except Exception as e:
                _logger.error(f"Error counting records: {e}")
                wizard.record_count = 0
    
    # ============================================
    # DOMAIN BUILDING METHODS
    # ============================================
    
    def _build_domain(self):
        """Build complete domain for account move line query."""
        self.ensure_one()
        
        domain = [
            ('date', '>=', self.date_from),
            ('date', '<=', self.date_to),
            ('company_id', '=', self.company_id.id),
        ]
        
        # Target moves filter
        if self.target_move == 'posted':
            domain.append(('move_id.state', '=', 'posted'))
        
        # Reconciliation filter
        if self.reconciled == 'unreconciled':
            domain.append(('reconciled', '=', False))
        elif self.reconciled == 'reconciled':
            domain.append(('reconciled', '=', True))
        
        # Account filters
        if self.account_ids:
            domain.append(('account_id', 'in', self.account_ids.ids))
        
        if self.account_type_ids:
            # Note: account.account uses 'company_ids' (Many2many) not 'company_id'
            account_ids = self.env['account.account'].search([
                ('account_type', '=', self.account_type_ids),
                ('company_ids', 'in', [self.company_id.id])
            ])
            domain.append(('account_id', 'in', account_ids.ids))
        
        # Journal filters
        if self.journal_ids:
            domain.append(('journal_id', 'in', self.journal_ids.ids))
        
        # Partner filter
        if self.partner_ids:
            domain.append(('partner_id', 'in', self.partner_ids.ids))
        
        # Matrix dimension filters
        matrix_domain = self._build_matrix_domain()
        if matrix_domain:
            domain += matrix_domain
        
        return domain
    
    def _build_matrix_domain(self):
        """Build matrix dimension domain based on filter mode."""
        matrix_domain = []
        
        # If no matrix filters, return empty
        if not self.branch_ids and not self.business_unit_ids:
            return matrix_domain
        
        # Build branch domain
        branch_domain = []
        if self.branch_ids:
            branch_domain = [('ops_branch_id', 'in', self.branch_ids.ids)]
        
        # Build BU domain
        bu_domain = []
        if self.business_unit_ids:
            bu_domain = [('ops_business_unit_id', 'in', self.business_unit_ids.ids)]
        
        # Apply filter mode
        if self.matrix_filter_mode == 'any':
            # OR condition: Branch OR BU
            if branch_domain and bu_domain:
                matrix_domain = ['|'] + branch_domain + bu_domain
            elif branch_domain:
                matrix_domain = branch_domain
            elif bu_domain:
                matrix_domain = bu_domain
        
        elif self.matrix_filter_mode == 'both':
            # AND condition: Branch AND BU
            if branch_domain and bu_domain:
                matrix_domain = branch_domain + bu_domain
            else:
                # If only one dimension selected in "both" mode, treat as "any"
                matrix_domain = branch_domain or bu_domain
        
        elif self.matrix_filter_mode == 'exact':
            # Exact combinations: apply both filters, post-filter in Python
            matrix_domain = []
            if branch_domain:
                matrix_domain += branch_domain
            if bu_domain:
                matrix_domain += bu_domain
        
        return matrix_domain
    
    def _get_exact_matrix_combinations(self):
        """Get list of exact branch-BU combinations for exact filter mode."""
        combinations = set()
        if self.branch_ids and self.business_unit_ids:
            for branch in self.branch_ids:
                for bu in self.business_unit_ids:
                    # Check if BU actually operates in this branch
                    if branch in bu.branch_ids:
                        combinations.add((branch.id, bu.id))
        return combinations
    
    # ============================================
    # VALIDATION METHODS
    # ============================================
    
    def _validate_filters(self):
        """Validate wizard filters before generating report."""
        self.ensure_one()
        
        if self.date_from > self.date_to:
            raise ValidationError(_("From date cannot be after To date."))
        
        # Check matrix filter logic
        if self.matrix_filter_mode == 'exact' and (not self.branch_ids or not self.business_unit_ids):
            raise ValidationError(_(
                "Exact combination mode requires both Branch and Business Unit filters."
            ))
        
        # Check for very large date ranges
        date_diff = (self.date_to - self.date_from).days
        if date_diff > 365 and self.report_format == 'detailed' and not self.account_ids:
            return {
                'warning': {
                    'title': _('Large Date Range'),
                    'message': _(
                        'You are generating a detailed report for more than 1 year without account filter. '
                        'This may take a long time. Consider using summary format or filtering by accounts.'
                    ),
                }
            }
        
        # Check for large result sets
        if self.record_count > 50000 and self.report_format == 'detailed':
            return {
                'warning': {
                    'title': _('Large Result Set'),
                    'message': _(
                        'This filter will return approximately %(count)d records. '
                        'Consider using summary format or applying additional filters.'
                    ) % {'count': self.record_count},
                }
            }
        
        return True
    
    # ============================================
    # REPORT GENERATION METHODS
    # ============================================
    
    def action_generate_report(self):
        """Generate the general ledger report with matrix filters."""
        self.ensure_one()
        
        # Validate filters
        validation_result = self._validate_filters()
        if isinstance(validation_result, dict) and 'warning' in validation_result:
            # Return warning but allow user to proceed
            pass
        
        # Generate report data
        report_data = self._prepare_report_data()
        
        # Return report action
        return self._return_report_action(report_data)
    
    def _prepare_report_data(self):
        """Prepare complete report data."""
        self.ensure_one()
        
        domain = self._build_domain()
        MoveLine = self.env['account.move.line']
        
        # Get initial balances if requested
        initial_balances = {}
        if self.include_initial_balance:
            initial_balances = self._get_initial_balances()
        
        # Get move lines
        order_by = self._get_sort_order()
        lines = MoveLine.search(domain, order=order_by)
        
        # Apply exact matrix filtering if needed
        if self.matrix_filter_mode == 'exact' and self.branch_ids and self.business_unit_ids:
            exact_combinations = self._get_exact_matrix_combinations()
            lines = lines.filtered(
                lambda l: (l.ops_branch_id.id, l.ops_business_unit_id.id) in exact_combinations
            )
        
        # Process lines based on report format
        if self.report_format == 'summary':
            processed_data = self._process_summary_data(lines)
        elif self.report_format == 'detailed':
            processed_data = self._process_detailed_data(lines)
        else:  # both
            processed_data = {
                'summary': self._process_summary_data(lines),
                'detailed': self._process_detailed_data(lines),
            }
        
        # Prepare final report data
        report_data = {
            'wizard_id': self.id,
            'company_name': self.company_id.name,
            'company_currency': self.company_id.currency_id.name,
            'date_from': str(self.date_from),
            'date_to': str(self.date_to),
            'filters': self._get_filter_summary_dict(),
            'initial_balances': initial_balances,
            'data': processed_data,
            'report_format': self.report_format,
            'totals': {
                'total_debit': sum(line.debit for line in lines),
                'total_credit': sum(line.credit for line in lines),
                'total_balance': sum(line.balance for line in lines),
                'line_count': len(lines),
            },
        }
        
        return report_data
    
    def _get_initial_balances(self):
        """Get initial balances for accounts before the period."""
        self.ensure_one()
        
        MoveLine = self.env['account.move.line']
        
        # Build domain for transactions before period
        domain = [
            ('date', '<', self.date_from),
            ('company_id', '=', self.company_id.id),
            ('move_id.state', '=', 'posted'),
        ]
        
        # Apply same filters as main report
        if self.account_ids:
            domain.append(('account_id', 'in', self.account_ids.ids))
        if self.journal_ids:
            domain.append(('journal_id', 'in', self.journal_ids.ids))
        if self.partner_ids:
            domain.append(('partner_id', 'in', self.partner_ids.ids))
        
        # Matrix filters
        matrix_domain = self._build_matrix_domain()
        if matrix_domain:
            domain += matrix_domain
        
        # Group by account (and other dimensions if consolidating)
        groupby_fields = ['account_id']
        if self.consolidate_by_branch and self.branch_ids:
            groupby_fields.append('ops_branch_id')
        if self.consolidate_by_bu and self.business_unit_ids:
            groupby_fields.append('ops_business_unit_id')
        if self.consolidate_by_partner and self.partner_ids:
            groupby_fields.append('partner_id')
        
        # Aggregate initial balances
        _read_group(
            domain=domain,
            groupby=groupby_fields,
            aggregates=['debit:sum', 'credit:sum', 'balance:sum']
        )
        
        # Process into dictionary
        balances = {}
        for item in initial_data:
            key = tuple(item.get(field, False) for field in groupby_fields)
            balances[key] = {
                'debit': item.get('debit', 0),
                'credit': item.get('credit', 0),
                'balance': item.get('balance', 0),
            }
        
        return balances
    
    def _process_summary_data(self, lines):
        """Process lines into summary format with grouping."""
        self.ensure_one()
        
        # Determine grouping
        groupby_fields = ['account_id']
        if self.consolidate_by_branch:
            groupby_fields.append('ops_branch_id')
        if self.consolidate_by_bu:
            groupby_fields.append('ops_business_unit_id')
        if self.consolidate_by_partner:
            groupby_fields.append('partner_id')
        
        # Group data
        grouped_data = {}
        for line in lines:
            # Create group key
            key_parts = []
            key_parts.append(line.account_id.id)
            if self.consolidate_by_branch:
                key_parts.append(line.ops_branch_id.id if line.ops_branch_id else False)
            if self.consolidate_by_bu:
                key_parts.append(line.ops_business_unit_id.id if line.ops_business_unit_id else False)
            if self.consolidate_by_partner:
                key_parts.append(line.partner_id.id if line.partner_id else False)
            
            key = tuple(key_parts)
            
            if key not in grouped_data:
                grouped_data[key] = {
                    'account_id': line.account_id.id,
                    'account_code': line.account_id.code,
                    'account_name': line.account_id.name,
                    'debit': 0,
                    'credit': 0,
                    'balance': 0,
                    'count': 0,
                }
                
                if self.consolidate_by_branch:
                    grouped_data[key]['branch_id'] = line.ops_branch_id.id if line.ops_branch_id else False
                    grouped_data[key]['branch_name'] = line.ops_branch_id.name if line.ops_branch_id else ''
                if self.consolidate_by_bu:
                    grouped_data[key]['bu_id'] = line.ops_business_unit_id.id if line.ops_business_unit_id else False
                    grouped_data[key]['bu_name'] = line.ops_business_unit_id.name if line.ops_business_unit_id else ''
                if self.consolidate_by_partner:
                    grouped_data[key]['partner_id'] = line.partner_id.id if line.partner_id else False
                    grouped_data[key]['partner_name'] = line.partner_id.name if line.partner_id else ''
            
            grouped_data[key]['debit'] += line.debit
            grouped_data[key]['credit'] += line.credit
            grouped_data[key]['balance'] += line.balance
            grouped_data[key]['count'] += 1
        
        return list(grouped_data.values())
    
    def _process_detailed_data(self, lines):
        """Process lines into detailed format."""
        self.ensure_one()
        
        detailed_data = []
        running_balance = 0
        
        for line in lines:
            running_balance += line.balance
            
            detailed_data.append({
                'id': line.id,
                'date': str(line.date),
                'move_id': line.move_id.id,
                'move_name': line.move_id.name,
                'journal_code': line.journal_id.code,
                'account_code': line.account_id.code,
                'account_name': line.account_id.name,
                'partner_name': line.partner_id.name if line.partner_id else '',
                'branch_code': line.ops_branch_id.code if line.ops_branch_id else '',
                'branch_name': line.ops_branch_id.name if line.ops_branch_id else '',
                'bu_code': line.ops_business_unit_id.code if line.ops_business_unit_id else '',
                'bu_name': line.ops_business_unit_id.name if line.ops_business_unit_id else '',
                'name': line.name,
                'ref': line.ref or '',
                'debit': line.debit,
                'credit': line.credit,
                'balance': line.balance,
                'running_balance': running_balance,
                'reconciled': line.reconciled,
                'currency_id': line.currency_id.name if line.currency_id else '',
                'amount_currency': line.amount_currency,
            })
        
        return detailed_data
    
    def _get_sort_order(self):
        """Get sort order based on wizard selection."""
        sort_mapping = {
            'date': 'date, move_id, id',
            'account': 'account_id, date, id',
            'partner': 'partner_id, date, id',
            'branch': 'ops_branch_id, date, id',
            'bu': 'ops_business_unit_id, date, id',
        }
        return sort_mapping.get(self.sort_by, 'date, move_id, id')
    
    def _get_filter_summary_dict(self):
        """Get filter summary as dictionary for report."""
        return {
            'branch_count': len(self.branch_ids),
            'branch_names': self.branch_ids.mapped('name') if self.branch_ids else [],
            'bu_count': len(self.business_unit_ids),
            'bu_names': self.business_unit_ids.mapped('name') if self.business_unit_ids else [],
            'account_count': len(self.account_ids),
            'journal_count': len(self.journal_ids),
            'partner_count': len(self.partner_ids),
            'date_range': f"{self.date_from} to {self.date_to}",
            'target_move': self.target_move,
            'reconciled': self.reconciled,
            'matrix_filter_mode': self.matrix_filter_mode,
            'consolidate_by_branch': self.consolidate_by_branch,
            'consolidate_by_bu': self.consolidate_by_bu,
            'consolidate_by_partner': self.consolidate_by_partner,
            'group_by_date': self.group_by_date,
            'display_account': self.display_account,
            'include_initial_balance': self.include_initial_balance,
        }
    
    def _return_report_action(self, data):
        """Return appropriate report action."""
        return {
            'type': 'ir.actions.report',
            'report_name': 'ops_matrix_accounting.report_general_ledger_matrix',
            'report_type': 'qweb-pdf',
            'data': data,
            'config': False,
        }
    
    # ============================================
    # ACTION METHODS
    # ============================================
    
    def action_export_to_excel(self):
        """Export report to Excel format."""
        self.ensure_one()
        
        # Prepare report data
        report_data = self._prepare_report_data()
        
        return {
            'type': 'ir.actions.report',
            'report_name': 'ops_matrix_accounting.report_general_ledger_matrix_xlsx',
            'report_type': 'xlsx',
            'data': report_data,
            'config': False,
        }
    
    def action_view_transactions(self):
        """Open filtered journal entries in tree view."""
        self.ensure_one()
        
        domain = self._build_domain()
        
        # Get move IDs
        lines = self.env['account.move.line'].search(domain)
        
        # Apply exact matrix filtering if needed
        if self.matrix_filter_mode == 'exact' and self.branch_ids and self.business_unit_ids:
            exact_combinations = self._get_exact_matrix_combinations()
            lines = lines.filtered(
                lambda l: (l.ops_branch_id.id, l.ops_business_unit_id.id) in exact_combinations
            )
        
        move_ids = lines.mapped('move_id').ids
        
        return {
            'name': _('Journal Entries'),
            'type': 'ir.actions.act_window',
            'res_model': 'account.move',
            'view_mode': 'tree,form',
            'domain': [('id', 'in', move_ids)],
            'context': {
                'search_default_group_by_date': 1 if self.group_by_date != 'none' else 0,
            },
        }
    
    def action_view_account_moves(self):
        """View moves for specific account (called from report)."""
        self.ensure_one()
        
        account_id = self.env.context.get('account_id')
        if not account_id:
            raise UserError(_("No account specified"))
        
        domain = self._build_domain()
        domain.append(('account_id', '=', account_id))
        
        return {
            'name': _('Account Moves'),
            'type': 'ir.actions.act_window',
            'res_model': 'account.move.line',
            'view_mode': 'tree,form',
            'domain': domain,
        }
    
    # ============================================
    # ONCHANGE METHODS
    # ============================================
    
    @api.onchange('company_id')
    def _onchange_company_id(self):
        """Reset filters when company changes."""
        if self.company_id:
            self.branch_ids = False
            self.business_unit_ids = False
            self.account_ids = False
            self.journal_ids = False
            self.partner_ids = False
    
    @api.onchange('branch_ids')
    def _onchange_branch_ids(self):
        """Update BU domain when branches change."""
        if self.branch_ids:
            return {
                'domain': {
                    'business_unit_ids': [('branch_ids', 'in', self.branch_ids.ids)]
                }
            }
        return {}
    
    @api.onchange('business_unit_ids')
    def _onchange_business_unit_ids(self):
        """Update branch domain when BUs change."""
        if self.business_unit_ids:
            branch_ids = self.business_unit_ids.mapped('branch_ids').ids
            return {
                'domain': {
                    'branch_ids': [('id', 'in', branch_ids)]
                }
            }
        return {}
    
    @api.onchange('report_format')
    def _onchange_report_format(self):
        """Adjust options based on report format."""
        if self.report_format == 'summary':
            # Enable consolidation for summary
            if not any([self.consolidate_by_branch, self.consolidate_by_bu, self.consolidate_by_partner]):
                self.consolidate_by_branch = bool(self.branch_ids)
                self.consolidate_by_bu = bool(self.business_unit_ids)


============================================
MODULE: ops_matrix_reporting
============================================

>>> STRUCTURE <<<
ops_matrix_reporting/__init__.py
ops_matrix_reporting/__manifest__.py
ops_matrix_reporting/data/dashboard_data.xml
ops_matrix_reporting/hooks.py
ops_matrix_reporting/models/__init__.py
ops_matrix_reporting/models/ops_financial_analysis.py
ops_matrix_reporting/models/ops_inventory_analysis.py
ops_matrix_reporting/models/ops_sales_analysis.py
ops_matrix_reporting/security/ir_rule.xml
ops_matrix_reporting/tests/__init__.py
ops_matrix_reporting/tests/test_excel_export.py
ops_matrix_reporting/tests/test_performance.py
ops_matrix_reporting/views/ops_excel_export_wizard_views.xml
ops_matrix_reporting/views/ops_financial_analysis_views.xml
ops_matrix_reporting/views/ops_inventory_analysis_views.xml
ops_matrix_reporting/views/ops_sales_analysis_views.xml
ops_matrix_reporting/views/reporting_menu.xml
ops_matrix_reporting/wizard/__init__.py
ops_matrix_reporting/wizard/ops_excel_export_wizard.py

>>> __manifest__.py <<<
{
    'name': 'OPS Matrix Reporting',
    'version': '19.0.1.0',
    'category': 'Reporting',
    'summary': 'Branch/Business Unit Matrix Analytics and Reporting',
    'description': """
    High-performance SQL-based reporting and analytics for the OPS Matrix framework.
    
    Features:
    - Sales Analysis by Branch and Business Unit
    - Financial Analysis with dimension tracking
    - Inventory Health and BU segregation verification
    - Spreadsheet Dashboard integration
    - Strict record-level security enforcement
    """,
    'author': 'OPS Matrix Development Team',
    'license': 'LGPL-3',
    'installable': True,
    'application': True,
    'auto_install': False,
    'depends': [
        'ops_matrix_core',
        'sale_management',
        'account',
        'stock',
        'spreadsheet_dashboard',
    ],
    'data': [
        # Security
        'security/ir.model.access.csv',
        'security/ir_rule.xml',
        # Views
        'views/ops_sales_analysis_views.xml',
        'views/ops_financial_analysis_views.xml',
        'views/ops_inventory_analysis_views.xml',
        'views/ops_excel_export_wizard_views.xml',
        'views/reporting_menu.xml',
    ],
    'assets': {
        'web.assets_backend': [
            'ops_matrix_reporting/static/src/css/reporting.css',
        ],
    },
    'external_dependencies': {
        'python': ['xlsxwriter'],
    },
    'images': ['static/description/icon.png'],
}

--- ops_matrix_reporting/models/__init__.py ---
# -*- coding: utf-8 -*-

from . import ops_sales_analysis
from . import ops_financial_analysis
from . import ops_inventory_analysis

__all__ = [
    'ops_sales_analysis',
    'ops_financial_analysis',
    'ops_inventory_analysis',
]

--- ops_matrix_reporting/models/ops_financial_analysis.py ---
from odoo import models, fields, api


class OpsFinancialAnalysis(models.Model):
    """
    Financial Analysis Report - Read-Only SQL View
    
    This model represents a PostgreSQL materialized view that provides
    high-performance financial analytics with Branch and Business Unit dimensions.
    
    The view joins account_move_line with account_move to provide:
    - Date of journal entry
    - Account information
    - Branch and Business Unit dimensions (from move)
    - Debit/Credit amounts and balance
    - Move status and type
    
    CRITICAL: This model is read-only (_auto=False) and backed by a PostgreSQL view.
    Only posted journal entries from actual invoices/bills are included.
    """
    
    _name = 'ops.financial.analysis'
    _description = 'Financial Analysis by Branch and Business Unit'
    _auto = False  # Don't auto-create table
    _rec_name = 'id'
    _order = 'date DESC'
    
    # ========================================================================
    # FIELDS - Mirror the View Columns
    # ========================================================================
    id = fields.Id(readonly=True)
    
    date = fields.Date(
        string='Entry Date',
        readonly=True,
        help='The accounting date of the journal entry, which determines the fiscal period for reporting. '
             'This is distinct from the transaction date and is used for period-end closing and financial statements. '
             'Use Case: Filter by date range to generate monthly/quarterly/annual financial reports and P&L statements. '
             'Example: "2025-01-01 to 2025-01-31" for January financial results. '
             'Important: Only posted entries (state=posted) are included - draft entries are excluded from this analysis. '
             'Note: This is the move date (account.move.date), not the line date - all lines in a move share the same date. '
             'Related: Combine with ops_branch_id and ops_business_unit_id for multi-dimensional financial analysis.'
    )
    
    move_id = fields.Many2one(
        'account.move',
        string='Journal Entry',
        readonly=True,
        help='The parent journal entry (account move) that contains this line item. '
             'Used to trace back to the source document (invoice, bill, payment, etc.) and view full transaction context. '
             'Use Case: Click to view complete journal entry details including all debit/credit lines and original document reference. '
             'Example: "INV/2025/0001" for customer invoice or "BILL/2025/0001" for vendor bill. '
             'Important: Each move can have multiple lines (debits and credits must balance). '
             'Navigation: From analysis view â†’ move_id â†’ view original invoice/bill with payment status and customer/vendor details. '
             'Related: move_type indicates whether this is a customer invoice, vendor bill, credit note, etc.'
    )
    
    account_id = fields.Many2one(
        'account.account',
        string='Account',
        readonly=True,
        help='The General Ledger (GL) account to which this financial transaction is posted. '
             'Accounts are organized in a chart of accounts with categories like Assets, Liabilities, Equity, Revenue, Expenses. '
             'Use Case: Group by account_id to generate trial balance, balance sheet, and income statement reports. '
             'Example: "101000 - Cash" for cash accounts, "400000 - Product Sales" for revenue, "600000 - COGS" for expenses. '
             'Important: Account type determines where it appears in financial statements (BS vs P&L). '
             'Analysis: Use get_account_analysis() to see account balances broken down by branch and BU dimensions. '
             'Related: Filter by account.account_type (asset_receivable, liability_payable, expense, income) for specific report types.'
    )
    
    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        readonly=True,
        help='The operational branch (location/store) to which this financial transaction is attributed for P&L reporting. '
             'This dimension enables branch-level financial statements including income statements and balance sheets. '
             'Use Case: Generate separate P&L statements per branch to evaluate location profitability and cost centers. '
             'Example: "Branch A: $100K revenue, $80K expenses = $20K profit vs Branch B: $90K revenue, $85K expenses = $5K profit". '
             'Important: Inherited from the parent move (invoice/bill level), not line level - all lines share the branch. '
             'Analysis: Use get_summary_by_branch() for aggregated debits, credits, and net balance per branch. '
             'Security: Users only see financial data from branches they have access to via security rules.'
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        readonly=True,
        help='The business unit (product line/division) to which this financial transaction is attributed for divisional P&L. '
             'This dimension enables BU-level financial statements to track divisional profitability independently. '
             'Use Case: Generate separate P&L per BU to evaluate which product lines are profitable and which need strategic changes. '
             'Example: "Electronics BU: $200K revenue, $120K COGS, $50K OpEx = $30K profit. Clothing BU: $150K revenue, $100K COGS, $60K OpEx = -$10K loss". '
             'Important: Combined with ops_branch_id, enables full matrix reporting (Branch Ã— BU P&L grid). '
             'Analysis: Use get_account_analysis() for account-level detail by both branch and BU simultaneously. '
             'Note: Inherited from parent move level for consistency across all lines in the transaction.'
    )
    
    move_type = fields.Selection([
        ('out_invoice', 'Customer Invoice'),
        ('out_refund', 'Customer Credit Note'),
        ('in_invoice', 'Vendor Bill'),
        ('in_refund', 'Vendor Credit Note'),
    ], string='Move Type', readonly=True,
       help='The transaction type that originated this journal entry, indicating whether it increases or decreases revenue/expenses. '
            'out_invoice: Customer Invoice (increases A/R and revenue). '
            'out_refund: Customer Credit Note (decreases A/R and revenue, issued for returns/corrections). '
            'in_invoice: Vendor Bill (increases A/P and expenses/COGS). '
            'in_refund: Vendor Credit Note (decreases A/P and expenses, received for returns/corrections). '
            'Use Case: Filter by move_type to separate sales analysis (out_*) from procurement analysis (in_*). '
            'Example: "Sum all out_invoice for total revenue, sum all in_invoice for total expenses". '
            'Important: Only these 4 transaction types are included - journal entries, payments, and manual moves are excluded. '
            'Analysis: Use get_receivables_payables_by_dimension() to analyze A/R (out_invoice) and A/P (in_invoice) by branch/BU.')
    
    debit = fields.Float(
        string='Debit',
        readonly=True,
        help='The debit amount for this journal entry line in the company currency. '
             'In double-entry accounting, debits increase Assets and Expenses, decrease Liabilities and Equity. '
             'Use Case: Sum debits by account to see total increases to asset/expense accounts during a period. '
             'Example: "Cash account debits of $50K = cash received from customers". '
             'Important: Debit and Credit always balance in a journal entry - total debits must equal total credits. '
             'Analysis: Debit - Credit = Balance. Positive balance indicates net debit position. '
             'Warning: Currency is always company currency - multi-currency transactions are converted at entry date rate.'
    )
    
    credit = fields.Float(
        string='Credit',
        readonly=True,
        help='The credit amount for this journal entry line in the company currency. '
             'In double-entry accounting, credits increase Liabilities, Equity, and Revenue, decrease Assets. '
             'Use Case: Sum credits by account to see total increases to liability/revenue accounts during a period. '
             'Example: "Sales revenue account credits of $100K = total sales revenue earned". '
             'Important: Every transaction has offsetting debits and credits - they must always balance (sum to zero). '
             'Analysis: Credit - Debit = negative Balance. Net credit position appears as negative balance. '
             'Related: For P&L analysis, revenue accounts show credits (good), expense accounts show debits (costs).'
    )
    
    balance = fields.Float(
        string='Balance',
        readonly=True,
        help='The net balance of this journal entry line, calculated as (debit - credit). '
             'Positive balance = net debit position (Assets/Expenses increase). Negative balance = net credit position (Liabilities/Revenue increase). '
             'Use Case: Sum balances by account to generate Trial Balance report showing net position for each GL account. '
             'Example: "Cash account balance +$10K = net cash increase. Sales revenue balance -$50K = revenue earned (credit normal)". '
             'Important: Balance sign convention: Assets/Expenses positive when growing, Liabilities/Equity/Revenue negative when growing. '
             'Analysis: Group by account_id and sum balance to see net change in each account during reporting period. '
             'Related: For period P&L, sum balances of all expense accounts (positive) and revenue accounts (negative) to calculate profit.'
    )
    
    partner_id = fields.Many2one(
        'res.partner',
        string='Partner',
        readonly=True,
        help='The business partner (customer or vendor) associated with this financial transaction. '
             'For customer invoices/credits: this is the customer. For vendor bills/credits: this is the supplier. '
             'Use Case: Track accounts receivable per customer and accounts payable per vendor by branch/BU dimensions. '
             'Example: "Customer ABC owes $15K across 3 branches (A/R analysis), Vendor XYZ is owed $8K across 2 BUs (A/P analysis)". '
             'Important: Partner is only populated for A/R and A/P account lines - expense and revenue lines may have null partner. '
             'Analysis: Use get_receivables_payables_by_dimension() to see aged receivables and payables by customer/vendor and dimension. '
             'Related: Cross-reference with sales analysis to see customer profitability (revenue vs payment behavior).'
    )
    
    # ========================================================================
    # SQL VIEW CREATION
    # ========================================================================
    def init(self):
        """
        Create the PostgreSQL view when the model is initialized.
        
        The view:
        1. Joins account_move_line with account_move
        2. Filters for posted entries (state='posted')
        3. Includes only transaction moves (out_invoice, out_refund, in_invoice, in_refund)
        4. Includes Branch and Business Unit dimensions from the move
        5. Optimized for financial analysis and multi-dimensional reporting
        """
        self.env.cr.execute(
            f"""
            CREATE OR REPLACE VIEW {self._table} AS (
                SELECT
                    -- Identification
                    aml.id,
                    aml.move_id,
                    aml.account_id,
                    
                    -- Temporal
                    CAST(am.date AS date) AS date,
                    
                    -- OPS Matrix Dimensions (from move level)
                    am.ops_branch_id,
                    am.ops_business_unit_id,
                    
                    -- Move information
                    am.move_type,
                    am.partner_id,
                    
                    -- Amounts
                    aml.debit,
                    aml.credit,
                    (aml.debit - aml.credit) AS balance
                
                FROM account_move_line aml
                
                INNER JOIN account_move am ON aml.move_id = am.id
                
                WHERE
                    -- Only posted entries
                    am.state = 'posted'
                    -- Only transaction-related moves
                    AND am.move_type IN ('out_invoice', 'out_refund', 'in_invoice', 'in_refund')
                    -- Exclude lines with zero balance
                    AND (aml.debit != 0 OR aml.credit != 0)
            )
            """
        )
    
    # ========================================================================
    # STATISTICS & AGGREGATIONS
    # ========================================================================
    @api.model
    def get_summary_by_branch(self):
        """
        Get financial summary grouped by branch.
        
        Returns aggregated financial data by branch:
        - Total debits
        - Total credits
        - Net balance
        - Transaction count
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                COUNT(*) as transaction_count,
                SUM(debit) as total_debits,
                SUM(credit) as total_credits,
                SUM(balance) as net_balance
            FROM ops_financial_analysis
            WHERE ops_branch_id IN (
                SELECT id FROM res_company
                WHERE id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_branch_id
            ORDER BY net_balance DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_summary_by_business_unit(self):
        """
        Get financial summary grouped by business unit.
        
        Returns aggregated financial data by BU:
        - Total debits
        - Total credits
        - Net balance
        - Transaction count
        """
        self.env.cr.execute(
            """
            SELECT
                ops_business_unit_id,
                COUNT(*) as transaction_count,
                SUM(debit) as total_debits,
                SUM(credit) as total_credits,
                SUM(balance) as net_balance
            FROM ops_financial_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_business_unit_id
            ORDER BY net_balance DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_account_analysis(self):
        """
        Get detailed analysis by account, branch, and business unit.
        
        Shows financial position by GL account and dimension:
        - Account balance by dimension
        - Helps identify cost centers and profit centers
        """
        self.env.cr.execute(
            """
            SELECT
                account_id,
                ops_branch_id,
                ops_business_unit_id,
                COUNT(*) as transaction_count,
                SUM(debit) as total_debits,
                SUM(credit) as total_credits,
                SUM(balance) as account_balance
            FROM ops_financial_analysis
            WHERE 
                ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY account_id, ops_branch_id, ops_business_unit_id
            ORDER BY account_balance DESC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_receivables_payables_by_dimension(self):
        """
        Get A/R and A/P analysis by dimension.
        
        Shows:
        - Customer receivables by branch/BU
        - Vendor payables by branch/BU
        - Helps manage working capital by dimension
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                ops_business_unit_id,
                move_type,
                partner_id,
                COUNT(*) as transaction_count,
                SUM(balance) as dimension_balance
            FROM ops_financial_analysis
            WHERE 
                move_type IN ('out_invoice', 'in_invoice')
                AND ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY ops_branch_id, ops_business_unit_id, move_type, partner_id
            ORDER BY dimension_balance DESC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    @api.model
    def create(self, vals):
        """Prevent creation of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be created.")
    
    def write(self, vals):
        """Prevent modification of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be modified.")
    
    def unlink(self):
        """Prevent deletion of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be deleted.")

--- ops_matrix_reporting/models/ops_inventory_analysis.py ---
from odoo import models, fields, api


class OpsInventoryAnalysis(models.Model):
    """
    Inventory Analysis Report - Read-Only SQL View
    
    This model represents a PostgreSQL materialized view that provides
    high-performance inventory analytics with Business Unit segregation.
    
    The view queries stock_quant to provide:
    - Product inventory levels
    - Location information
    - Business Unit dimension (from product via quant)
    - Quantity on hand
    - Stock value (quantity * standard cost)
    
    CRITICAL: This model is read-only (_auto=False) and backed by a PostgreSQL view.
    Ensures accurate inventory visibility respecting BU boundaries.
    """
    
    _name = 'ops.inventory.analysis'
    _description = 'Inventory Health and BU Segregation Analysis'
    _auto = False  # Don't auto-create table
    _rec_name = 'id'
    _order = 'product_id'
    
    # ========================================================================
    # FIELDS - Mirror the View Columns
    # ========================================================================
    id = fields.Id(readonly=True)
    
    product_id = fields.Many2one(
        'product.product',
        string='Product',
        readonly=True,
        help='The specific product variant held in inventory at this location. '
             'Used to track stock levels, valuation, and availability across the warehouse network. '
             'Use Case: Analyze inventory turnover rates, identify slow-moving stock, and plan replenishment by BU. '
             'Example: "Product SKU-001 has 500 units on-hand across 3 locations worth $25K". '
             'Important: This is the variant (product.product), not the template - tracking is at SKU level. '
             'Analysis: Use get_low_stock_alerts() to identify products below reorder points, get_overstocked_items() for excess inventory. '
             'Related: Product belongs to a Business Unit (ops_business_unit_id) - inventory respects BU silo boundaries.'
    )
    
    location_id = fields.Many2one(
        'stock.location',
        string='Location',
        readonly=True,
        help='The specific warehouse location (bin, shelf, zone) where this product quantity is physically stored. '
             'Locations are organized hierarchically: Warehouse â†’ Zone â†’ Bin, enabling precise inventory tracking. '
             'Use Case: Track which locations hold specific products for picking optimization and space utilization analysis. '
             'Example: "WH/Stock/Shelf-A/Bin-3 contains 50 units of Product X". '
             'Important: Only internal storage and transit locations are included (usage=internal/transit) - customer/vendor locations excluded. '
             'Analysis: Use get_inventory_by_location() to see total inventory value and diversity per physical location. '
             'Related: Each location typically belongs to a warehouse (stock.warehouse) which may be assigned to a branch.'
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        readonly=True,
        help='The business unit (division/product line) that owns and manages this inventory based on product assignment. '
             'This enables BU-level inventory silos ensuring each division controls its own stock independently. '
             'Use Case: Generate separate inventory reports per BU for P&L accuracy and divisional performance measurement. '
             'Example: "Electronics BU has $500K inventory value across 200 SKUs, Clothing BU has $300K across 150 SKUs". '
             'Important: Inherited from product.template.business_unit_id - product BU assignment determines inventory ownership. '
             'Security: Users only see inventory from BUs they have access to via persona assignments. '
             'Analysis: Use verify_bu_segregation() to identify products incorrectly assigned to multiple BUs (data integrity check).'
    )
    
    quantity = fields.Float(
        string='Quantity On Hand',
        readonly=True,
        help='The total physical quantity of this product currently present in this location, regardless of reservations. '
             'This is the actual stock-on-hand including both available and reserved units. '
             'Use Case: Calculate total inventory investment, track stock movements over time, identify excess or shortage situations. '
             'Example: "100 units on-hand: 70 available for sale + 30 reserved for existing orders". '
             'Important: Measured in product\'s unit of measure (UoM) - pieces, kg, liters, etc. Check product.uom_id for unit. '
             'Calculation: Available Quantity = Quantity - Reserved Quantity. '
             'Warning: Zero or negative quantities indicate stock discrepancies requiring physical inventory count.'
    )
    
    standard_price = fields.Float(
        string='Unit Cost',
        readonly=True,
        help='The standard cost per unit for this product, used for inventory valuation and margin calculations. '
             'This represents the acquisition cost (for purchased goods) or production cost (for manufactured goods). '
             'Use Case: Calculate total inventory value (quantity Ã— standard_price) and cost of goods sold (COGS) for margin analysis. '
             'Example: "Product cost $50/unit Ã— 100 units = $5,000 inventory value". '
             'Important: This is the cost at the time of snapshot - does not reflect current purchase price if costs have changed. '
             'Warning: Standard price should be updated periodically to reflect actual costs - outdated costs distort profitability reports. '
             'Related: Compare with sale price to calculate potential margin before selling (sale_price - standard_price).'
    )
    
    stock_value = fields.Float(
        string='Stock Value',
        readonly=True,
        help='The total inventory value for this product at this location, calculated as (quantity Ã— standard_price). '
             'This represents the total capital investment tied up in inventory at cost basis. '
             'Use Case: Track total inventory investment by location, product, and BU to manage working capital and inventory turns. '
             'Example: "100 units Ã— $50/unit = $5,000 stock value in Location A". '
             'Important: Sum across all locations and products to get total inventory asset value for balance sheet. '
             'Analysis: High stock value + low turnover = excess inventory tying up cash. Target: minimize value while maintaining availability. '
             'Related: Compare total stock_value to monthly sales to calculate inventory turnover ratio (Days Inventory Outstanding).'
    )
    
    reserved_quantity = fields.Float(
        string='Reserved Qty',
        readonly=True,
        help='The quantity of this product already reserved/allocated for confirmed sales orders awaiting delivery. '
             'Reserved stock is physically on-hand but committed to customers - not available for new orders. '
             'Use Case: Calculate true available-to-promise (ATP) inventory for sales quotations and order fulfillment planning. '
             'Example: "100 units on-hand: 30 reserved for Order #123, 70 available for new orders". '
             'Important: Reservations are created when sales orders are confirmed, released when shipment is completed. '
             'Warning: High reserved_quantity relative to total quantity indicates pending fulfillment backlog - may need expedited shipping. '
             'Related: Available Quantity = Quantity - Reserved Quantity shows true sellable inventory.'
    )
    
    available_quantity = fields.Float(
        string='Available Qty',
        readonly=True,
        help='The quantity of this product available for new sales orders, calculated as (quantity - reserved_quantity). '
             'This is the true "sellable" inventory that can be promised to new customers without overselling. '
             'Use Case: Check available_quantity before accepting new orders to avoid stockouts and backorders. '
             'Example: "100 on-hand - 30 reserved = 70 available for new orders". '
             'Important: This is the Available-to-Promise (ATP) metric used by sales teams and e-commerce systems. '
             'Warning: Negative available_quantity indicates oversold situation - more reserved than on-hand (requires urgent replenishment). '
             'Analysis: Low available_quantity triggers reorder points - use with minimum stock rules to prevent stockouts. '
             'Related: Compare with demand forecast to ensure sufficient stock for upcoming sales without excess inventory.'
    )
    
    # ========================================================================
    # SQL VIEW CREATION
    # ========================================================================
    def init(self):
        """
        Create the PostgreSQL view when the model is initialized.
        
        The view:
        1. Queries stock_quant for all stock quantities
        2. Joins with product_product and product_template for BU
        3. Includes location information
        4. Calculates stock value
        5. Optimized for BU-aware inventory analysis
        """
        self.env.cr.execute(
            f"""
            CREATE OR REPLACE VIEW {self._table} AS (
                SELECT
                    -- Identification
                    sq.id,
                    sq.product_id,
                    sq.location_id,
                    
                    -- OPS Matrix Dimension (from product)
                    pt.business_unit_id AS ops_business_unit_id,
                    
                    -- Inventory quantities
                    sq.quantity,
                    CAST(pp.standard_price AS NUMERIC) AS standard_price,
                    sq.reserved_quantity,
                    
                    -- Calculated fields
                    (sq.quantity * CAST(pp.standard_price AS NUMERIC)) AS stock_value,
                    (sq.quantity - sq.reserved_quantity) AS available_quantity
                
                FROM stock_quant sq
                
                INNER JOIN product_product pp ON sq.product_id = pp.id
                INNER JOIN product_template pt ON pp.product_tmpl_id = pt.id
                
                WHERE
                    -- Only include locations that are actual warehouses/storage
                    sq.location_id IN (
                        SELECT id FROM stock_location 
                        WHERE usage IN ('internal', 'transit')
                    )
                    -- Only non-zero quantities (filter out ghost records)
                    AND (sq.quantity != 0 OR sq.reserved_quantity != 0)
            )
            """
        )
    
    # ========================================================================
    # STATISTICS & AGGREGATIONS
    # ========================================================================
    @api.model
    def get_summary_by_business_unit(self):
        """
        Get inventory summary grouped by business unit.
        
        Returns aggregated inventory data by BU:
        - Total on-hand quantity
        - Total reserved quantity
        - Total available quantity
        - Total stock value
        - Item count
        """
        self.env.cr.execute(
            """
            SELECT
                ops_business_unit_id,
                COUNT(DISTINCT product_id) as product_count,
                COUNT(*) as location_product_count,
                SUM(quantity) as total_on_hand,
                SUM(reserved_quantity) as total_reserved,
                SUM(available_quantity) as total_available,
                SUM(stock_value) as total_value
            FROM ops_inventory_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_business_unit_id
            ORDER BY total_value DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_inventory_by_location(self):
        """
        Get inventory summary grouped by location and business unit.
        
        Shows warehouse-level inventory positions:
        - Inventory by warehouse
        - Shows BU ownership
        - Identifies stock segregation
        """
        self.env.cr.execute(
            """
            SELECT
                location_id,
                ops_business_unit_id,
                COUNT(DISTINCT product_id) as product_count,
                SUM(quantity) as total_on_hand,
                SUM(reserved_quantity) as total_reserved,
                SUM(available_quantity) as total_available,
                SUM(stock_value) as location_bu_value
            FROM ops_inventory_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY location_id, ops_business_unit_id
            ORDER BY location_bu_value DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_low_stock_alerts(self, threshold_value=1000):
        """
        Get inventory items with low stock value (potential issue).
        
        :param threshold_value: Value threshold to flag as "low stock"
        :return: Products below value threshold by BU
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                ops_business_unit_id,
                location_id,
                COUNT(*) as location_count,
                SUM(quantity) as total_quantity,
                SUM(stock_value) as total_value
            FROM ops_inventory_analysis
            WHERE 
                ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY product_id, ops_business_unit_id, location_id
            HAVING SUM(stock_value) > 0 AND SUM(stock_value) < %s
            ORDER BY total_value ASC
            """,
            [self.env.uid, threshold_value]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_overstocked_items(self, threshold_qty=100):
        """
        Get inventory items with excess/overstock condition.
        
        Helps identify potentially slow-moving or obsolete stock:
        - High quantity
        - Low recent movement
        - By BU
        
        :param threshold_qty: Quantity threshold to flag as "overstocked"
        :return: Products above quantity threshold by BU
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                ops_business_unit_id,
                COUNT(*) as location_count,
                SUM(quantity) as total_quantity,
                SUM(available_quantity) as total_available,
                SUM(stock_value) as total_value,
                ROUND((SUM(quantity) / NULLIF(SUM(reserved_quantity), 0))::numeric, 2) as qty_to_reserved_ratio
            FROM ops_inventory_analysis
            WHERE 
                ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY product_id, ops_business_unit_id
            HAVING SUM(quantity) > %s
            ORDER BY total_value DESC
            """,
            [self.env.uid, threshold_qty]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def verify_bu_segregation(self):
        """
        Verify that inventory is properly segregated by Business Unit.
        
        Returns products where:
        - Quantities exist in multiple BU assignments (possible data integrity issue)
        - Used for BU-aware inventory audits
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                COUNT(DISTINCT ops_business_unit_id) as bu_count,
                ARRAY_AGG(DISTINCT ops_business_unit_id) as bu_ids,
                SUM(quantity) as total_qty,
                SUM(stock_value) as total_value
            FROM ops_inventory_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY product_id
            HAVING COUNT(DISTINCT ops_business_unit_id) > 1
            ORDER BY total_value DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    @api.model
    def create(self, vals):
        """Prevent creation of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be created.")
    
    def write(self, vals):
        """Prevent modification of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be modified.")
    
    def unlink(self):
        """Prevent deletion of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be deleted.")

--- ops_matrix_reporting/models/ops_sales_analysis.py ---
from odoo import models, fields, api
from odoo.sql_db import Cursor


class OpsSalesAnalysis(models.Model):
    """
    Sales Analysis Report - Read-Only SQL View
    
    This model represents a PostgreSQL materialized view that provides
    high-performance sales analytics with Branch and Business Unit dimensions.
    
    The view joins sale.order_line with sale.order to provide:
    - Date of sale
    - Product sold
    - Customer (partner)
    - Branch and Business Unit dimensions
    - Quantities and revenue
    - Margin calculations
    
    CRITICAL: This model is read-only (_auto=False) and backed by a PostgreSQL view.
    """
    
    _name = 'ops.sales.analysis'
    _description = 'Sales Analysis by Branch and Business Unit'
    _auto = False  # Don't auto-create table
    _rec_name = 'id'
    _order = 'date_order DESC'
    
    # ========================================================================
    # FIELDS - Mirror the View Columns
    # ========================================================================
    id = fields.Id(readonly=True)
    
    date_order = fields.Datetime(
        string='Order Date',
        readonly=True,
        help='Date and time when the sale order was created in the system. '
             'This field is used as the primary temporal dimension for sales trend analysis and period comparisons. '
             'Use Case: Filter by date range to analyze sales performance over specific periods (month, quarter, year). '
             'Example: "2025-01-01 to 2025-03-31" for Q1 sales analysis. '
             'Note: Only confirmed/done orders (state=sale/done) are included in this analysis view. '
             'Related: Combine with ops_branch_id and ops_business_unit_id for multi-dimensional time series analysis.'
    )
    
    product_id = fields.Many2one(
        'product.product',
        string='Product',
        readonly=True,
        help='The specific product variant sold in this transaction line. '
             'Used to analyze product performance, identify top sellers, and track product margins across dimensions. '
             'Use Case: Group by product_id to see total revenue and margin per product. '
             'Example: "Product A sold 500 units with 25% average margin in Branch X". '
             'Important: This is the variant (product.product), not the template (product.template). '
             'Analysis: Use get_margin_analysis() to identify products with negative margins that need price adjustments. '
             'Related: Combine with ops_business_unit_id to verify product silo enforcement.'
    )
    
    partner_id = fields.Many2one(
        'res.partner',
        string='Customer',
        readonly=True,
        help='The customer (partner) who purchased the products in this sale order. '
             'Used to analyze customer purchasing patterns, identify top customers, and track customer profitability by dimension. '
             'Use Case: Group by partner_id to calculate customer lifetime value (CLV) and average order value per branch/BU. '
             'Example: "Customer ABC generated $50K revenue across 3 branches with 22% average margin". '
             'Important: Only business partners with type=contact or company are included (not addresses). '
             'Analysis: Cross-reference with receivables reports to identify high-value customers with payment issues. '
             'Related: Filter by ops_branch_id to see which customers prefer specific branches or regions.'
    )
    
    ops_branch_id = fields.Many2one(
        'res.company',
        string='Branch',
        readonly=True,
        help='The operational branch (location/store) that originated and owns this sale transaction. '
             'This is the primary geographic dimension for sales analysis and performance comparison across locations. '
             'Use Case: Compare revenue, margin, and volume across branches to identify high/low performers. '
             'Example: "Branch A: $100K revenue, 20% margin vs Branch B: $80K revenue, 25% margin". '
             'Important: This field respects user security rules - users only see sales from their allowed branches. '
             'Analysis: Use get_summary_by_branch() for aggregated branch performance metrics. '
             'Note: Legacy field name uses res.company model but represents operational branch concept.'
    )
    
    ops_business_unit_id = fields.Many2one(
        'ops.business.unit',
        string='Business Unit',
        readonly=True,
        help='The business unit (product line/division) that owns this sale transaction. '
             'This is the product/service dimension for sales analysis, enabling P&L tracking by division. '
             'Use Case: Analyze which product lines (BUs) generate the most revenue and margin across different branches. '
             'Example: "Electronics BU: $200K revenue in 5 branches, Consumer Goods BU: $150K in 3 branches". '
             'Important: Combined with ops_branch_id, this creates the matrix intersection for true multi-dimensional analysis. '
             'Analysis: Use get_summary_by_matrix() to see Branch Ã— BU performance grid. '
             'Security: Users only see BU data they have access to via their persona assignments.'
    )
    
    product_uom_qty = fields.Float(
        string='Quantity',
        readonly=True,
        help='The quantity of products sold in this transaction line, measured in the product\'s unit of measure (UoM). '
             'Used to calculate volume metrics, track unit sales trends, and compute average selling price per unit. '
             'Use Case: Track which products sell in high volumes vs high value but low volume (luxury goods). '
             'Example: "Product A sold 1000 units at $10 each = $10K revenue vs Product B sold 10 units at $1K = $10K revenue". '
             'Important: Quantity is in the product\'s default UoM (pieces, kg, liters, etc.) - check product.uom_id for unit type. '
             'Calculation: Average selling price = price_subtotal / product_uom_qty. '
             'Related: Compare with reserved_quantity in inventory analysis to forecast demand.'
    )
    
    price_subtotal = fields.Float(
        string='Subtotal (ex. tax)',
        readonly=True,
        help='The total revenue for this transaction line excluding taxes (net price Ã— quantity). '
             'This is the primary revenue metric used for all sales analysis, margin calculations, and financial reporting. '
             'Use Case: Sum by dimension (branch/BU/time period) to calculate total revenue and compare performance. '
             'Example: "Branch A generated $50K subtotal in Q1 across 200 order lines". '
             'Important: Excludes taxes and shipping charges - use this for margin calculations, not customer invoices. '
             'Calculation: Margin = price_subtotal - (product_uom_qty Ã— standard_price). '
             'Warning: Currency is the company currency - multi-currency sales are converted at transaction date rate.'
    )
    
    margin = fields.Float(
        string='Margin Amount',
        readonly=True,
        help='The gross profit amount for this transaction line, calculated as revenue minus cost of goods sold (COGS). '
             'Formula: margin = price_subtotal - (product_uom_qty Ã— standard_price). '
             'Use Case: Identify which products, branches, or BUs generate the highest absolute profit contribution. '
             'Example: "$1000 revenue - $600 COGS = $400 margin". '
             'Important: Margin can be negative if selling below cost - use get_margin_analysis() to identify loss-making products. '
             'Warning: Based on standard_price (cost) at transaction time - does not reflect inventory valuation changes. '
             'Analysis: High margin products may need volume increases, low margin products may need price increases or cost reductions.'
    )
    
    margin_percent = fields.Float(
        string='Margin %',
        readonly=True,
        help='The gross profit margin expressed as a percentage of revenue, calculated as (margin / price_subtotal) Ã— 100. '
             'This is the key profitability metric for comparing performance across products with different price points. '
             'Use Case: Identify high-margin products (>30%) and low-margin products (<10%) to guide pricing strategy. '
             'Example: "$400 margin / $1000 revenue = 40% margin percentage". '
             'Interpretation: 0% = break-even, <0% = loss, 10-20% = competitive, 20-30% = good, >30% = excellent. '
             'Warning: Percentage can be misleading - a 50% margin on a $10 sale ($5 profit) is less valuable than 10% on $1000 ($100 profit). '
             'Related: Compare margin_percent across branches to identify operational efficiency differences or pricing inconsistencies.'
    )
    
    # ========================================================================
    # SQL VIEW CREATION
    # ========================================================================
    def init(self):
        """
        Create the PostgreSQL view when the model is initialized.
        
        The view:
        1. Joins sale.order_line with sale.order
        2. Filters for confirmed orders (state in confirmed, done)
        3. Calculates margin as (price_subtotal - cogs)
        4. Includes Branch and Business Unit dimensions
        5. Optimized for pivot/grouping operations
        """
        self.env.cr.execute(
            f"""
            CREATE OR REPLACE VIEW {self._table} AS (
                SELECT
                    -- Identification
                    sol.id::integer AS id,
                    
                    -- Temporal
                    so.date_order::timestamp AS date_order,
                    
                    -- Products & Customers (explicit integer casting for Many2one fields)
                    sol.product_id::integer AS product_id,
                    so.partner_id::integer AS partner_id,
                    
                    -- OPS Matrix Dimensions (explicit integer casting for Many2one fields)
                    so.ops_branch_id::integer AS ops_branch_id,
                    so.ops_business_unit_id::integer AS ops_business_unit_id,
                    
                    -- Quantities & Revenue (explicit numeric casting for float fields)
                    sol.product_uom_qty::numeric AS product_uom_qty,
                    sol.price_subtotal::numeric AS price_subtotal,
                    
                    -- Margin Calculation (already numeric from computation)
                    (
                        sol.price_subtotal::numeric -
                        (sol.product_uom_qty::numeric * COALESCE(CAST(pp.standard_price AS NUMERIC), 0))
                    )::numeric AS margin,
                    
                    -- Margin Percentage (already numeric from computation)
                    CASE
                        WHEN sol.price_subtotal = 0 THEN 0::numeric
                        ELSE ROUND(
                            (
                                (
                                    sol.price_subtotal::numeric -
                                    (sol.product_uom_qty::numeric * COALESCE(CAST(pp.standard_price AS NUMERIC), 0))
                                ) / sol.price_subtotal::numeric * 100
                            )::numeric,
                            2
                        )
                    END AS margin_percent
                
                FROM sale_order_line sol
                
                INNER JOIN sale_order so ON sol.order_id = so.id
                LEFT JOIN product_product pp ON sol.product_id = pp.id
                LEFT JOIN product_template pt ON pp.product_tmpl_id = pt.id
                
                WHERE
                    -- Only include confirmed/done orders
                    so.state IN ('sale', 'done')
                    -- Exclude cancelled lines
                    AND sol.state != 'cancel'
            )
            """
        )
    
    # ========================================================================
    # STATISTICS & AGGREGATIONS
    # ========================================================================
    @api.model
    def get_summary_by_branch(self):
        """
        Get summary statistics grouped by branch.
        
        Returns aggregated sales data by branch:
        - Total revenue
        - Total margin
        - Average margin %
        - Total units sold
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                COUNT(*) as line_count,
                SUM(product_uom_qty) as total_qty,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent
            FROM ops_sales_analysis
            WHERE ops_branch_id IN (
                SELECT id FROM res_company
                WHERE id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_branch_id
            ORDER BY total_revenue DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_summary_by_business_unit(self):
        """
        Get summary statistics grouped by business unit.
        
        Returns aggregated sales data by BU:
        - Total revenue
        - Total margin
        - Average margin %
        - Total units sold
        """
        self.env.cr.execute(
            """
            SELECT
                ops_business_unit_id,
                COUNT(*) as line_count,
                SUM(product_uom_qty) as total_qty,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent
            FROM ops_sales_analysis
            WHERE ops_business_unit_id IN (
                SELECT id FROM ops_business_unit
                WHERE id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            )
            GROUP BY ops_business_unit_id
            ORDER BY total_revenue DESC
            """,
            [self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_summary_by_matrix(self):
        """
        Get summary statistics grouped by Branch AND Business Unit (matrix view).
        
        Returns aggregated sales data by the Branch/BU matrix intersection:
        - Revenue per dimension pair
        - Margin per dimension pair
        - Units per dimension pair
        """
        self.env.cr.execute(
            """
            SELECT
                ops_branch_id,
                ops_business_unit_id,
                COUNT(*) as line_count,
                SUM(product_uom_qty) as total_qty,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent
            FROM ops_sales_analysis
            WHERE 
                ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY ops_branch_id, ops_business_unit_id
            ORDER BY total_revenue DESC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    @api.model
    def get_margin_analysis(self):
        """
        Get detailed margin analysis by product, branch, and BU.
        
        Identifies products and dimensions with:
        - Highest margins
        - Lowest margins
        - Negative margin (loss-making) products
        """
        self.env.cr.execute(
            """
            SELECT
                product_id,
                ops_branch_id,
                ops_business_unit_id,
                COUNT(*) as transaction_count,
                ROUND(AVG(margin_percent)::numeric, 2) as avg_margin_percent,
                SUM(price_subtotal) as total_revenue,
                SUM(margin) as total_margin
            FROM ops_sales_analysis
            WHERE 
                ops_branch_id IN (
                    SELECT branch_id FROM res_users_ops_allowed_branch_rel
                    WHERE user_id = %s
                )
                AND ops_business_unit_id IN (
                    SELECT business_unit_id FROM res_users_ops_allowed_business_unit_rel
                    WHERE user_id = %s
                )
            GROUP BY product_id, ops_branch_id, ops_business_unit_id
            ORDER BY avg_margin_percent ASC
            """,
            [self.env.uid, self.env.uid]
        )
        return self.env.cr.dictfetchall()
    
    # ========================================================================
    # CONSTRAINTS
    # ========================================================================
    @api.model
    def create(self, vals):
        """Prevent creation of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be created.")
    
    def write(self, vals):
        """Prevent modification of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be modified.")
    
    def unlink(self):
        """Prevent deletion of records (read-only view)"""
        raise NotImplementedError("This is a read-only view. Records cannot be deleted.")

--- ops_matrix_reporting/wizard/__init__.py ---
# -*- coding: utf-8 -*-
from . import ops_excel_export_wizard

--- ops_matrix_reporting/wizard/ops_excel_export_wizard.py ---
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
import io
import base64
import logging

_logger = logging.getLogger(__name__)

try:
    import xlsxwriter
except ImportError:
    _logger.warning("xlsxwriter library not found. Excel export will not be available.")
    xlsxwriter = None


class OpsExcelExportWizard(models.TransientModel):
    _name = 'ops.excel.export.wizard'
    _description = 'OPS Excel Export Wizard'
    
    report_type = fields.Selection([
        ('sales', 'Sales Analysis'),
        ('financial', 'Financial Analysis'),
        ('inventory', 'Inventory Analysis'),
    ], string='Report Type', required=True, default='sales')
    
    date_from = fields.Date(string='Date From')
    date_to = fields.Date(string='Date To')
    
    branch_ids = fields.Many2many(
        'res.company', 
        string='Branches',
        help='Leave empty to include all branches'
    )
    
    business_unit_ids = fields.Many2many(
        'ops.business.unit', 
        string='Business Units',
        help='Leave empty to include all business units'
    )
    
    filename = fields.Char(string='Filename', readonly=True)
    excel_file = fields.Binary(string='Excel File', readonly=True)
    state = fields.Selection([
        ('draft', 'Draft'),
        ('done', 'Done'),
    ], default='draft')
    
    @api.constrains('date_from', 'date_to')
    def _check_dates(self):
        """Validate date range."""
        for wizard in self:
            if wizard.date_from and wizard.date_to:
                if wizard.date_from > wizard.date_to:
                    raise ValidationError(
                        _('The start date must be earlier than the end date.')
                    )
    
    def action_generate_excel(self):
        """Generate Excel file based on report type."""
        self.ensure_one()
        
        # Check if xlsxwriter is available
        if xlsxwriter is None:
            raise UserError(
                _('Excel export functionality is not available. '
                  'Please install the xlsxwriter Python library:\n\n'
                  'pip install xlsxwriter')
            )
        
        try:
            # Generate Excel file
            if self.report_type == 'sales':
                excel_data = self._generate_sales_excel()
                filename = 'sales_analysis.xlsx'
            elif self.report_type == 'financial':
                excel_data = self._generate_financial_excel()
                filename = 'financial_analysis.xlsx'
            elif self.report_type == 'inventory':
                excel_data = self._generate_inventory_excel()
                filename = 'inventory_analysis.xlsx'
            else:
                raise ValidationError(_('Invalid report type selected.'))
            
            # Save file to wizard
            self.write({
                'excel_file': base64.b64encode(excel_data),
                'filename': filename,
                'state': 'done',
            })
            
            # Return action to download file
            return {
                'type': 'ir.actions.act_window',
                'res_model': 'ops.excel.export.wizard',
                'view_mode': 'form',
                'res_id': self.id,
                'target': 'new',
            }
            
        except Exception as e:
            _logger.exception("Error generating Excel export")
            raise UserError(
                _('Failed to generate Excel file:\n\n%s') % str(e)
            )
    
    def _generate_sales_excel(self):
        """Generate Sales Analysis Excel report."""
        # Build domain
        domain = []
        if self.date_from:
            domain.append(('date_order', '>=', self.date_from))
        if self.date_to:
            domain.append(('date_order', '<=', self.date_to))
        if self.branch_ids:
            domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
        if self.business_unit_ids:
            domain.append(('ops_business_unit_id', 'in', self.business_unit_ids.ids))
        
        # Fetch data
        sales_data = self.env['ops.sales.analysis'].search_read(
            domain,
            ['date_order', 'product_id', 'partner_id', 'ops_branch_id', 
             'ops_business_unit_id', 'product_uom_qty', 'price_subtotal', 
             'margin', 'margin_percent'],
            order='date_order desc, partner_id'
        )
        
        # Create Excel file
        output = io.BytesIO()
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet('Sales Analysis')
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#4472C4',
            'font_color': 'white',
            'border': 1,
            'align': 'center',
            'valign': 'vcenter',
        })
        
        currency_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        percent_format = workbook.add_format({
            'num_format': '0.00%',
            'border': 1,
        })
        
        number_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        text_format = workbook.add_format({'border': 1})
        
        # Set column widths
        worksheet.set_column('A:A', 12)  # Date
        worksheet.set_column('B:B', 30)  # Product
        worksheet.set_column('C:C', 25)  # Customer
        worksheet.set_column('D:D', 20)  # Branch
        worksheet.set_column('E:E', 20)  # Business Unit
        worksheet.set_column('F:F', 12)  # Quantity
        worksheet.set_column('G:G', 15)  # Revenue
        worksheet.set_column('H:H', 15)  # Margin
        worksheet.set_column('I:I', 12)  # Margin %
        
        # Write headers
        headers = ['Date', 'Product', 'Customer', 'Branch', 'Business Unit', 
                   'Quantity', 'Revenue', 'Margin', 'Margin %']
        for col, header in enumerate(headers):
            worksheet.write(0, col, header, header_format)
        
        # Write data
        row = 1
        total_qty = 0
        total_revenue = 0
        total_margin = 0
        
        for record in sales_data:
            worksheet.write(row, 0, record['date_order'], text_format)
            worksheet.write(row, 1, record['product_id'][1] if record.get('product_id') else '', text_format)
            worksheet.write(row, 2, record['partner_id'][1] if record.get('partner_id') else '', text_format)
            worksheet.write(row, 3, record['ops_branch_id'][1] if record.get('ops_branch_id') else '', text_format)
            worksheet.write(row, 4, record['ops_business_unit_id'][1] if record.get('ops_business_unit_id') else '', text_format)
            worksheet.write(row, 5, record['product_uom_qty'], number_format)
            worksheet.write(row, 6, record['price_subtotal'], currency_format)
            worksheet.write(row, 7, record['margin'], currency_format)
            worksheet.write(row, 8, record['margin_percent'] / 100, percent_format)
            
            total_qty += record['product_uom_qty']
            total_revenue += record['price_subtotal']
            total_margin += record['margin']
            row += 1
        
        # Write totals
        total_format = workbook.add_format({
            'bold': True,
            'bg_color': '#E7E6E6',
            'border': 1,
            'num_format': '#,##0.00',
        })
        
        worksheet.write(row, 4, 'TOTAL:', total_format)
        worksheet.write(row, 5, total_qty, total_format)
        worksheet.write(row, 6, total_revenue, total_format)
        worksheet.write(row, 7, total_margin, total_format)
        avg_margin = (total_margin / total_revenue * 100) if total_revenue else 0
        worksheet.write(row, 8, f'{avg_margin:.2f}%', total_format)
        
        workbook.close()
        output.seek(0)
        return output.read()
    
    def _generate_financial_excel(self):
        """Generate Financial Analysis Excel report."""
        # Build domain
        domain = []
        if self.date_from:
            domain.append(('date', '>=', self.date_from))
        if self.date_to:
            domain.append(('date', '<=', self.date_to))
        if self.branch_ids:
            domain.append(('ops_branch_id', 'in', self.branch_ids.ids))
        if self.business_unit_ids:
            domain.append(('ops_business_unit_id', 'in', self.business_unit_ids.ids))
        
        # Fetch data
        financial_data = self.env['ops.financial.analysis'].search_read(
            domain,
            ['date', 'account_id', 'ops_branch_id', 'ops_business_unit_id', 
             'move_type', 'partner_id', 'debit', 'credit', 'balance'],
            order='date desc, account_id'
        )
        
        # Create Excel file
        output = io.BytesIO()
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet('Financial Analysis')
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#70AD47',
            'font_color': 'white',
            'border': 1,
            'align': 'center',
        })
        
        currency_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        text_format = workbook.add_format({'border': 1})
        
        # Set column widths
        worksheet.set_column('A:A', 12)
        worksheet.set_column('B:B', 30)
        worksheet.set_column('C:C', 20)
        worksheet.set_column('D:D', 20)
        worksheet.set_column('E:E', 15)
        worksheet.set_column('F:F', 25)
        worksheet.set_column('G:G', 15)
        worksheet.set_column('H:H', 15)
        worksheet.set_column('I:I', 15)
        
        # Write headers
        headers = ['Date', 'Account', 'Branch', 'Business Unit', 'Move Type', 
                   'Partner', 'Debit', 'Credit', 'Balance']
        for col, header in enumerate(headers):
            worksheet.write(0, col, header, header_format)
        
        # Write data
        row = 1
        total_debit = 0
        total_credit = 0
        total_balance = 0
        
        for record in financial_data:
            worksheet.write(row, 0, record['date'], text_format)
            worksheet.write(row, 1, record['account_id'][1] if record.get('account_id') else '', text_format)
            worksheet.write(row, 2, record['ops_branch_id'][1] if record.get('ops_branch_id') else '', text_format)
            worksheet.write(row, 3, record['ops_business_unit_id'][1] if record.get('ops_business_unit_id') else '', text_format)
            worksheet.write(row, 4, record.get('move_type', ''), text_format)
            worksheet.write(row, 5, record['partner_id'][1] if record.get('partner_id') else '', text_format)
            worksheet.write(row, 6, record['debit'], currency_format)
            worksheet.write(row, 7, record['credit'], currency_format)
            worksheet.write(row, 8, record['balance'], currency_format)
            
            total_debit += record['debit']
            total_credit += record['credit']
            total_balance += record['balance']
            row += 1
        
        # Write totals
        total_format = workbook.add_format({
            'bold': True,
            'bg_color': '#E7E6E6',
            'border': 1,
            'num_format': '#,##0.00',
        })
        
        worksheet.write(row, 5, 'TOTAL:', total_format)
        worksheet.write(row, 6, total_debit, total_format)
        worksheet.write(row, 7, total_credit, total_format)
        worksheet.write(row, 8, total_balance, total_format)
        
        workbook.close()
        output.seek(0)
        return output.read()
    
    def _generate_inventory_excel(self):
        """Generate Inventory Analysis Excel report."""
        # Build domain
        domain = []
        if self.business_unit_ids:
            domain.append(('ops_business_unit_id', 'in', self.business_unit_ids.ids))
        
        # Fetch data
        inventory_data = self.env['ops.inventory.analysis'].search_read(
            domain,
            ['product_id', 'location_id', 'ops_business_unit_id', 'quantity', 
             'reserved_quantity', 'available_quantity', 'standard_price', 'stock_value'],
            order='product_id, location_id'
        )
        
        # Create Excel file
        output = io.BytesIO()
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet('Inventory Analysis')
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#FFC000',
            'font_color': 'white',
            'border': 1,
            'align': 'center',
        })
        
        currency_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        number_format = workbook.add_format({
            'num_format': '#,##0.00',
            'border': 1,
        })
        
        text_format = workbook.add_format({'border': 1})
        
        # Set column widths
        worksheet.set_column('A:A', 35)
        worksheet.set_column('B:B', 30)
        worksheet.set_column('C:C', 20)
        worksheet.set_column('D:D', 12)
        worksheet.set_column('E:E', 12)
        worksheet.set_column('F:F', 12)
        worksheet.set_column('G:G', 12)
        worksheet.set_column('H:H', 15)
        
        # Write headers
        headers = ['Product', 'Location', 'Business Unit', 'On Hand', 'Reserved', 
                   'Available', 'Unit Price', 'Stock Value']
        for col, header in enumerate(headers):
            worksheet.write(0, col, header, header_format)
        
        # Write data
        row = 1
        total_on_hand = 0
        total_reserved = 0
        total_available = 0
        total_value = 0
        
        for record in inventory_data:
            worksheet.write(row, 0, record['product_id'][1] if record.get('product_id') else '', text_format)
            worksheet.write(row, 1, record['location_id'][1] if record.get('location_id') else '', text_format)
            worksheet.write(row, 2, record['ops_business_unit_id'][1] if record.get('ops_business_unit_id') else '', text_format)
            worksheet.write(row, 3, record['quantity'], number_format)
            worksheet.write(row, 4, record['reserved_quantity'], number_format)
            worksheet.write(row, 5, record['available_quantity'], number_format)
            worksheet.write(row, 6, record['standard_price'], currency_format)
            worksheet.write(row, 7, record['stock_value'], currency_format)
            
            total_on_hand += record['quantity']
            total_reserved += record['reserved_quantity']
            total_available += record['available_quantity']
            total_value += record['stock_value']
            row += 1
        
        # Write totals
        total_format = workbook.add_format({
            'bold': True,
            'bg_color': '#E7E6E6',
            'border': 1,
            'num_format': '#,##0.00',
        })
        
        worksheet.write(row, 2, 'TOTAL:', total_format)
        worksheet.write(row, 3, total_on_hand, total_format)
        worksheet.write(row, 4, total_reserved, total_format)
        worksheet.write(row, 5, total_available, total_format)
        worksheet.write(row, 6, '', total_format)
        worksheet.write(row, 7, total_value, total_format)
        
        workbook.close()
        output.seek(0)
        return output.read()
    
    def action_download(self):
        """Download the generated Excel file."""
        self.ensure_one()
        
        if not self.excel_file:
            raise UserError(_('No Excel file has been generated yet.'))
        
        return {
            'type': 'ir.actions.act_url',
            'url': f'/web/content/ops.excel.export.wizard/{self.id}/excel_file/{self.filename}?download=true',
            'target': 'self',
        }


